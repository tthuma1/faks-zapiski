Reševanje sovpadanj v zgoščeni tabeli:
- veriženje:
	- elemente, ki se preslikajo v isto celico tabele, shranjujemo v povezanem seznamu
	- časovna zahtevnost, če imamo slabo zgoščevalno funkcijo (v najslabšem primeru) $h(k) = 0$ => $T(n) = O(n)$
	- $\alpha$ ... največja velikost koša
	- $T(n) = O(\alpha)$
	- želja: $\alpha = O(1)$ => $\alpha$ ni odvisna od števila elementov, ki jih vstavljamo; ni nujno vedno uresničljivo, včasih uspe, včasih ne
	- kaj če seznam zamenjam z iskalnim drevesom:
		- $T(n) = O(lg \; \alpha)$
- prenaslavljanje (open addressing):
	- veriženje prinese dodaten overhead za prostor, ker rabimo kazalce za strukturo
	- kako lahko shranjujemo podatke samo v tabeli
	- imamo več zgoščevalnih funkcij
	- ko je tabela bolj polna, boš rabil več funkcij
	- v m korakih moraš pregledati celotno tabelo - funkcije morajo biti povezane, da predstavljajo permutacijo (če m-krat pokličem te funkcije, bom preiskal vsa mesta)
	- prostor je omejen in ga zmanjka, ko v tabelo vstavimo m elementov - takrat bomo morali tabelo povečati in prepisati elemente:
		- zgoščevalne funkcije običajno uporabljajo modul $m$, sepravi ne bomo morali ena na ena prepisati, ampak bomo morali vse elemente na novo vstaviti (še enkrat izračunati hash)
	- brisanje elementov je težavno:
		- prosto mesto je lahko dvojna informacija - ali smo element pobrisali od tam, ali pa ga nikoli sploh ni bilo
		- rešitev: lazy delete - element samo označimo kot pobrisanega, ampak ga ne izbrišemo zares
	- funkcija h bo dvoparametrična
	- ![400](../../Images3/Pasted%20image%2020250415085817.png)
	- $h(k, i)$, $k \in U$, $h \in {0, 1, ... , m-1}$ => indeks
	- k je ključ, drug parameter pove številko poskusa - najprej zračunamo $h(k,0)$, potem $h(k, 1)$ itd. dokler ne pregledamo vseh ($h(k, m-1)$)
	- 