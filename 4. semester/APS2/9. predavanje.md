Reševanje sovpadanj v zgoščeni tabeli:
- veriženje:
	- elemente, ki se preslikajo v isto celico tabele, shranjujemo v povezanem seznamu
	- časovna zahtevnost, če imamo slabo zgoščevalno funkcijo (v najslabšem primeru) $h(k) = 0$ => $T(n) = O(n)$
	- $\alpha$ ... največja velikost koša
	- $T(n) = O(\alpha)$
	- želja: $\alpha = O(1)$ => $\alpha$ ni odvisna od števila elementov, ki jih vstavljamo; ni nujno vedno uresničljivo, včasih uspe, včasih ne
	- kaj če seznam zamenjam z iskalnim drevesom:
		- $T(n) = O(lg \; \alpha)$
- prenaslavljanje (open addressing):
	- veriženje prinese dodaten overhead za prostor, ker rabimo kazalce za strukturo
	- kako lahko shranjujemo podatke samo v tabeli
	- imamo več zgoščevalnih funkcij
	- ko je tabela bolj polna, boš rabil več funkcij
	- v m korakih moraš pregledati celotno tabelo - funkcije morajo biti povezane, da predstavljajo permutacijo (če m-krat pokličem te funkcije, bom preiskal vsa mesta)
	- prostor je omejen in ga zmanjka, ko v tabelo vstavimo m elementov - takrat bomo morali tabelo povečati in prepisati elemente:
		- zgoščevalne funkcije običajno uporabljajo modul $m$, sepravi ne bomo morali ena na ena prepisati, ampak bomo morali vse elemente na novo vstaviti (še enkrat izračunati hash)
	- brisanje elementov je težavno:
		- prosto mesto je lahko dvojna informacija - ali smo element pobrisali od tam, ali pa ga nikoli sploh ni bilo
		- rešitev: lazy delete - element samo označimo kot pobrisanega, ampak ga ne izbrišemo zares
	- funkcija h bo dvoparametrična
	- ![400](../../Images3/Pasted%20image%2020250415085817.png)
	- $h(k, i)$, $k \in U$, $h \in {0, 1, ... , m-1}$ => indeks
	- k je ključ, drug parameter pove številko poskusa - najprej zračunamo $h(k,0)$, potem $h(k, 1)$ itd. dokler ne pregledamo vseh ($h(k, m-1)$)
	- zaporedje $(h(k,0), h(k,1), h(k,2), ... , h(k,m-1))$ je permutacija $\{0,1,...,m-1\}$ => ko m-krat kličem h, bom dobil vse indekse; te klici zgoščevalne funkcije so premešanje vseh indeksov v zgoščevalni tabeli
	- ![400](../../Images3/Pasted%20image%2020250415091914.png)
	- ![400](../../Images3/Pasted%20image%2020250415091933.png)
		- vrača m različnih permutacij (vseh permutacij je m!)
	- ![400](../../Images3/Pasted%20image%2020250415092006.png)
		- problem kadar $h''$ preslika v neko število, ki ni tujo $m$
		- kako to prepričimo: m je praštevilo
		- vrne m^2 različnih permutacij, zato je boljša

Koliko bomo v povprečju iskali, preden bomo našli prosto mesto?
- če imamo lepo zgoščevalno funkcijo
- če je za vsak ključ enako verjetno, da se pojavi
- če je $\alpha$ = zasedenost tabele ($\alpha \in [0,1]$; $\alpha = 0$ je prazna tabela; 1 je polna tabela)
- => pričakovano število poskusov: $\frac{1}{\alpha} \; ln(\frac{1}{1-\alpha}) + \frac{1}{\alpha}$

![500](../../Images3/Pasted%20image%2020250415093918.png)
Slabosti, zakaj je ne uporabljamo povsod:
- porabi nekaj dodatnega prostora za kazalce v primerjavi z drevesom
- nimamo urejenosti, ker je vrstni red elementov odvisen od funkcije $h$ - zato imamo v Javi HashSet in TreeSet

- v Javi ima `Object` metodo `hashCode()`
- imamo HashTable in HashMap:
	- če program teče v dveh nitih, se HashTable sinhronizira, ampak je zato počasneje
	- HashMap uporablja drevo, HashTable pa seznam
	- zakaj `size = 2*size + 1`, da m ni večkratnik števila 2