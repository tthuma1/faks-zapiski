Prerez grafa:
- razdelitev točk v dve disjunktni podmnožici S in T
- povezave prereza so povezave med množicami S in T
- $S \cap T = \{\}$
- $S \cup T = V$

Minimalno vpeto drevo (MST):
- drevo = povezan graf brez ciklov
- rešitev ni nujno enolična - lahko imamo več enako dobrih rešitev
- rešitev je enolična v primeru različnih uteži
- minimalna povezava poljubnega prereza grafa G je gotovo del MST:
	- preprez nam pove, kako graf lahko razpade na dva dela, povezave med prerezi pa nam preprečijo, da bi graf dejansko razpadel - če je več povezav med prerezi, moramo sigurno vzeti najmanjšo izmed njimi
- dva požrešna algoritma - Prim in Kruskal:
	- nekaj bomo uredili in šli po tem vrstnem redu, na koncu bomo pri tem primeru s tem pristopom prišli do optimalne rešitve, čeprav v splošnem to ni nujno
- Prim:
	- problem rešujemo lokalno
	- s tem, ko bomo lokalno rešili problem, bomo na koncu prišli do globalne rešitve
	- najprej imamo prerez, kjer imamo v enem delu eno točko, v drugem pa preostanek grafa
	- izberemo najcenejšo povezavo prereza - novo povezano točko prestavimo na levi del prereza in to ponavljamo
	- implementacija:
		- množico $V$ razdelimo na dva dela: $V = T \cup U$
		- v $T$ dam na začetku poljubno točko $v$ ; $Q = V \backslash \{v\}$
		- za vsako točko $v$ iz $Q$ izračunam `key[v]` = cena najcenejše povezave, ki $v$ povezuje s $T$
		- `u[v]` = točka na drugi strani
	- časovna zahtevnost:
		- dodamo vse točke - n korakov
		- na vsakem koraku popravimo `key` vsem sosedom od $v$, ki so v $Q$ - vse skupaj bomo pregledali vse povezave in nobene dvakrat
		- moramo vedeti, v kateri podatkovni strukturi je implementiran graf:
			- če imamo matriko sosednosti, moramo da dobimo vse sosede, pogledati n elementov (celo vrstico) => $n \cdot n$ elementov pregledamo $T(n) = O(n^2)$
			- seznam sosednosti:
				- ko dodamo točko i, gremo samo po njenem seznamu sosedov
				- na vsakem koraku pogledamo nekaj povezav, skupaj bomo pogledali vseh $m$ povezav
				- $T(n, m) = O(n + m)$
			- kako si hranimo vrstni red `key`-jev:
				- s prioritetno vrsto
				- skupaj časovna zahtevnost: $T(n, m) = O((n + m) \cdot log\;n)$
				- 