Prerez grafa:
- razdelitev točk v dve disjunktni podmnožici S in T
- povezave prereza so povezave med množicami S in T
- $S \cap T = \{\}$
- $S \cup T = V$

Minimalno vpeto drevo (MST):
- drevo = povezan graf brez ciklov
- rešitev ni nujno enolična - lahko imamo več enako dobrih rešitev
- rešitev je enolična v primeru različnih uteži
- minimalna povezava poljubnega prereza grafa G je gotovo del MST:
	- preprez nam pove, kako graf lahko razpade na dva dela, povezave med prerezi pa nam preprečijo, da bi graf dejansko razpadel - če je več povezav med prerezi, moramo sigurno vzeti najmanjšo izmed njimi
- dva požrešna algoritma - Prim in Kruskal:
	- nekaj bomo uredili in šli po tem vrstnem redu, na koncu bomo pri tem primeru s tem pristopom prišli do optimalne rešitve, čeprav v splošnem to ni nujno

Prim:
- problem rešujemo lokalno
- s tem, ko bomo lokalno rešili problem, bomo na koncu prišli do globalne rešitve
- najprej imamo prerez, kjer imamo v enem delu eno točko, v drugem pa preostanek grafa
- izberemo najcenejšo povezavo prereza - novo povezano točko prestavimo na levi del prereza in to ponavljamo
- implementacija:
	- množico $V$ razdelimo na dva dela: $V = T \cup U$
	- v $T$ dam na začetku poljubno točko $v$ ; $Q = V \backslash \{v\}$
	- za vsako točko $v$ iz $Q$ izračunam `key[v]` = cena najcenejše povezave, ki $v$ povezuje s $T$
	- `u[v]` = točka na drugi strani
- časovna zahtevnost:
	- dodamo vse točke - n korakov
	- na vsakem koraku popravimo `key` vsem sosedom od $v$, ki so v $Q$ - vse skupaj bomo pregledali vse povezave in nobene dvakrat
	- moramo vedeti, v kateri podatkovni strukturi je implementiran graf:
		- če imamo matriko sosednosti, moramo da dobimo vse sosede, pogledati n elementov (celo vrstico) => $n \cdot n$ elementov pregledamo $T(n) = O(n^2)$
		- seznam sosednosti:
			- ko dodamo točko i, gremo samo po njenem seznamu sosedov
			- na vsakem koraku pogledamo nekaj povezav, skupaj bomo pogledali vseh $m$ povezav
			- $T(n, m) = O(n + m)$
		- kako si hranimo vrstni red `key`-jev:
			- s prioritetno vrsto
			- skupaj časovna zahtevnost: $T(n, m) = O((n + m) \cdot log\;n)$
			- prioritetna vrsta je bolje od kopice, ker ima operacijo decrease key - lahko zmanjšamo vrednost enega ključa, ko dobimo boljšo povezavo

Kruskal:
- ni nujno, da dobimo isto rešitev, ker je lahko več MST, bomo pa dobili isto ceno
- dodaja povezave dokler ne dobimo drevesa
- povezave uredi po ceni, gre po vrsti po njih in doda povezavo v MST, če ne naredi cikla
- imamo tabelo povezav:
	- za urejanje tabele $O(|E| \cdot log\;|E|)$
- točke shranjujemo v disjunktnih množicah:
	- ko dve točki povežemo, naredimo `union`, dokler ne dobimo vseh točk v eni množici
- kako vemo, da nismo naredili cikla:
	- če sta točki povezave v različnim disjunktnih množicah (v različnih drevesih), potem ne bo cikla
	- če bi povezali dve točki iz iste disjunktne množice, bi dobili cikel
```
kruskal(G):
	F = {} // povezave MST
	V = {} // točke, ki so v trenutnem MST
	E = sort(G.E) // urejeno po minimalni ceni O(m log m)
	for v in G.V: // O(n)
		makeset(v)
	for (v, u) in E: // ... m-krat, skupaj O(m * c); c je od inverznega Ackermana
		if (find(v) != find(u)): // primerjaš predstavnike disjunktnih množic - če sta različna, ne bomo naredili cikla; find() je skoraj O(1)
			union(v, u) // skoraj O(1)
			F = F.union( { (v, u) } )
			V = V.union( { v, u } )
	return F
```
- $T(n, m) = O(m \cdot log\;m)$
- problem MST je slučajno tak problem, da ga lahko požrešno rešimo (če dodajamo lokalni minimum, dobimo globalni minimum)

Barvanje grafov:
- barvamo graf tako, da sosednji dve točki nista istih barv
- poljuben zemljevid (ravninski graf) lahko pobarvamo s štirimi barvami
- kromatično število - najmanjše barvanje
- uporabno, ko imamo neka opravila, ki se ne morejo istočasno izvajati:
	- opravila, ki se ne morejo istočasno izvajati, so povezana v grafu in jih rabimo drugače pobarvati
	- npr. sestavljanje avta je iz več opravil, ena opravila se ne morejo hkrati izvajati, zato bodo morala biti drugače pobarvana - na koncu ko pobarvamo, bomo šli hkrati delati modra opravila, hkrati rdeča, hkrati zelena ...
- nimamo optimalnega algoritma, ki bi bil polinomski
- dopuščamo neoptimalnost - bo npr. proizvodnja trajala dalj časa, kot bi bilo optimalno
- psevdokod
- ![500](../../Images3/Pasted%20image%2020250520101343.png)

- pomožna metoda `lahkoPobarvam(G, v, k) -> Boolean` (Ali lahko pobarvam točko $v$ z barvo $k$?)
```
barvaj(G):
	barve[1..n] = 0
	V = uredi(G.V)
	for v in V:
		for k = 1..n:
			if lahkoPobarvam(G, v, k):
				barve[v] = k
				break
```