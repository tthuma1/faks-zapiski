### Disjunktne množice (disjoint set)
- podatki so enolični in pripadajo določeni skupini - imamo množico v kateri so podatki grupirani v podmnožice
- $S$ = množica množic
- vsaka podmnožica ima svojega predstavnika:
	- da ugotovimo, ali sta dva elementa v isti podmnožici, samo pogledamo, če imata istega predstavnika
- predstavnik:
	- lahko katerikoli element
	- se ne spremeni dokler se struktura ne spremeni
- iskanje v množici je O(lg n), s temi podmnožicami in predstavniki bomo lahko prišli do O(1)
- `makeset(x)`, `find(x)`, `union(x, y)`

Izvedbe hranjenja predstavnika:
- vsi elementi kažejo na predstavnika:
	- `makeset(x)` = O(1)
	- `find(x)` = O(1) (samo pogledaš x.parent)
	- `union(x, y)` = vsi parente moraš posodobiti, O(1) + O(n) (find da najdeš predstavnika + prevezovanje kazalcev):
		- za vsak `e` iz množice, ki ji pripada y: `e.parent = x.parent`

Izvedba z gozdom disjunktnih množic:
- vsaka disjunktna množica bo drevo, v korenu bo predstavnik
- `makeset(x)` = O(1)
- `find(x)` = O(n) (imaš izrojeno drevo - seznam)
- `union(x, y)` = samo prevežeš predstavnika ene množice da kaže na predstavnika druge množice: O(n) + O(1) (find + prevezovanje)

- izboljšava:
	- samo prvič, ko se sprehodimo do korena, bo drago, takrat vsem popravimo parenta in bo vse ostalo O(1)
	- sprehod do korena bo v bistvu rabil dvakrat več operacij, ker moramo še pointerje popravljati
- izboljšava union:
	- želimo, da bi bilo drevo čim manj globoko - bolj globokemu drevesu prevežemo manj globoko drevo

- 1. manj globoko množico pridruži bolj globoki
- 2. pri iskanju popravim kazalce na parent
- z amortizirano analizo vidimo, da je vse O(1); na začetku imamo eno drago operacijo, vse ostale pa so O(1) in se zamortizirajo

- `makeset(x)` = O(1)
- `find(x)` = O($\alpha(n)$) $\approx$ O(1)
- `union(x, y)` = O($\alpha(n)$) + O(1) $\approx$ O(1)

Implementacija:
- potrebujemo dva slovarja:
	- parent(x) ... predstavnik
	- size(x) ... št elementov v drevesu

```Python
makeset(x):
	if (parent(x) == null):
		parent(x) = x
		size(x) = 1

find(x):
	if (parent(x) != x): # če še nismo v korenu
		parent(x) = find(parent(x))

	return parent(x)

union(x, y):
	x + find(x)
	y = find(y)
	if (x == y) return
	if (size(x) < size(y)):
		(x, y) = (y, x) # v x bomo imeli množico z več elementi, v y pa z manj elementi

	parent(y) = x
	size(x) += size(y)

```