### Disjunktne množice (disjoint set)
- podatki so enolični in pripadajo določeni skupini - imamo množico v kateri so podatki grupirani v podmnožice
- $S$ = množica množic
- vsaka podmnožica ima svojega predstavnika:
	- da ugotovimo, ali sta dva elementa v isti podmnožici, samo pogledamo, če imata istega predstavnika
- predstavnik:
	- lahko katerikoli element
	- se ne spremeni dokler se struktura ne spremeni
- iskanje v množici je O(lg n), s temi podmnožicami in predstavniki bomo lahko prišli do O(1)
- `makeset(x)`, `find(x)`, `union(x, y)`

Izvedbe hranjenja predstavnika:
- vsi elementi kažejo na predstavnika:
	- `makeset(x)` = O(1)
	- `find(x)` = O(1) (samo pogledaš x.parent)
	- `union(x, y)` = vsi parente moraš posodobiti, O(1) + O(n) (find da najdeš predstavnika + prevezovanje kazalcev):
		- za vsak `e` iz množice, ki ji pripada y: `e.parent = x.parent`

Izvedba z gozdom disjunktnih množic:
- vsaka disjunktna množica bo drevo, v korenu bo predstavnik
- `makeset(x)` = O(1)
- `find(x)` = O(n) (imaš izrojeno drevo - seznam)
- `union(x, y)` = samo prevežeš predstavnika ene množice da kaže na predstavnika druge množice: O(n) + O(1) (find + prevezovanje)

- izboljšava:
	- samo prvič, ko se sprehodimo do korena, bo drago, takrat vsem popravimo parenta in bo vse ostalo O(1)
	- sprehod do korena bo v bistvu rabil dvakrat več operacij, ker moramo še pointerje popravljati
- izboljšava union:
	- želimo, da bi bilo drevo čim manj globoko - bolj globokemu drevesu prevežemo manj globoko drevo

- 1. manj globoko množico pridruži bolj globoki
- 2. pri iskanju popravim kazalce na parent
- z amortizirano analizo vidimo, da je vse O(1); na začetku imamo eno drago operacijo, vse ostale pa so O(1) in se zamortizirajo

- `makeset(x)` = O(1)
- `find(x)` = O($\alpha(n)$) $\approx$ O(1)
- `union(x, y)` = O($\alpha(n)$) + O(1) $\approx$ O(1)

Implementacija:
- potrebujemo dva slovarja:
	- parent(x) ... predstavnik
	- size(x) ... št elementov v drevesu

```Python
makeset(x):
	if (parent(x) == null):
		parent(x) = x
		size(x) = 1

find(x):
	if (parent(x) != x): # če še nismo v korenu
		parent(x) = find(parent(x)) # posodobimo kazalec na parenta, da kaže direktno na predstavnika

	return parent(x)

union(x, y):
	x = find(x) # v bistvu nas zanimajo samo predstavniki
	y = find(y)
	if (x == y) return # x in y sta v isti podmnožici
	if (size(x) < size(y)):
		(x, y) = (y, x) # v x bomo imeli množico z več elementi, v y pa z manj elementi

	parent(y) = x # večji podmnožici pripišemo manjšo
	size(x) += size(y)

```

### Razredi kompleksnosti
- ali P = NP
- naloga = konkreten primer problema
- algoritem na vhod dobi nalogo
- vrste problemov: iskalni, preštevalni, odločitveni, optimizacijski, naštevalni
- mi bomo rekli, da obstajajo samo odločitveni in optimizacijski problemi
- optimizacija:
	- imamo kriterijsko funkcijo f; med vsemi možnimi (dopustnimi) rešitvami (D) dane naloge iščemo tako, ki optimizira (min/max) funkcijo f.

Primer: poišči ceno najcenejše pot v grafu
- naloga: graf + začetek (v) in konec (u)
- D: vse poti od v do u
- optimizacija: min
- kriterijska funkcija: cena poti

- optimizacijski problem lahko velikokrat ločim z večkratnim reševanjem odločitvenega problema
- odločitven problem: ali med v in u obstaja pot s ceno x
- kako bi tu rešili optimizacijski problem z odločitvenim:
	- ali obstaja pot s ceno 1? ne
	- ali obstaja pot s ceno 2? ne
	- ...
	- ali obstaja pot s ceno x? da => to je najkrajša pot
	- če pot ne obstaja, ne bi nikoli dobili odgovora "da"

Primer barvanje grafa:
- ali lahko graf pobarvam z 1 barvo? ne
- ali lahko graf pobarvam z 2 barvama? ne
- ...
- ali lahko graf pobarvam z $\chi$ (kromatično število) barvami? da

- zahtevnost problema je definirana z zahtevnostjo algoritma
- če imamo nek algoritem, ki reši vse naloge problema v času t(n), potem je ta problem rešljiv v t(n)
- nek problem lahko razglasimo za zelo zahtevnega, ker ne poznamo dobrega algoritma
- ![600](../../Images3/Pasted%20image%2020250422100639.png)
- za nekatere algoritme se da dokazati spodnjo mejo – ne samo, da mi ne poznamo boljšega algoritma, pokazati se da, da ta sploh ne obstaja

Razred P:
- npr. urejanje zaporedja O(n log n)
- množenje matrik je rešljivo z algoritmom O(n^3), torej je polinomsko
- sem spadajo tudi boljši algoritmi, npr. bisekcija za iskanje v urejenem zaporedju (O(lg n))

- ![650](../../Images3/Pasted%20image%2020250422101027.png)
- vsak problem, ki je v P je tudi v EXPTIME
- problemi, ki grejo preko EXPTIME:
	- npr. naštej vse permutacije - ne moremo rešiti v manj časa kot n!
- ![150](../../Images3/Pasted%20image%2020250422101149.png)
- če bi želel zasesti npr. eksponentno mnogo pomnilnika, bi potreboval eksponentno mnogo časa