- B-drevo ima vse liste na istem nivoju, kar bo povzročilo, da bo imelo logaritmično globino
- b jerelativno velik (npr. 10), zato bo imel logaritem veliko osnovo, kar je super
- kolikšna je zares časovna zahtevnost iskanja:
	- ko gremo dol v eno vozlišče, rabimo pregledati b-1 elementov, da vemo, v katero poddrevo moramo iti
	- v vsakem koraku, moramo narediti $log_2b$ operacij, da izvemo v katero smer moramo iti
	- dobimo isti rezultat kot pri dvojiškem iskalnem drevesu, ker smo predpostavili, da je iti en nivo dol in primerjati elemente pri bisekciji enako drago
	- B drevo se uporablja v podatkovnih bazah, ker je dostop do enega bloka pomnilnika drag, ampak potem, ko ga imaš v predpomnilniku, je bisekcija hitra - minimiziramo število branj iz datoteke:
		- iz diska itak nikoli ne prebereš samo enega byta, ker se vedno prenašajo bloki
		- minimiziramo število branj bloka
		- ko preberemo en blok, naredimo bisekcijo in preberemo naslednji blok

B-drevo insert:
- nov element vedno vstavimo v list
- če j ev listu, kamor vstavljamo, manj kot b-1 elementov, je vse v redu in končamo
- če ima list sedaj preveč ključev, ga damo narazen:
	- oče bo sredinsko vozlišče, vsako polovica bo otrok
- kompleksnost:
	- najprej preiščemo globino, da najdemo kam moramo vstaviti element
	- potem v najslabšem primeru h-krat popravimo vozlišče
	- h-krat dol + h-krat gor => O(h)

delete:
- ko element v drevesu zbrišemo, ga moramo z nečim nadomestiti
- kateri element je najbolj primeren, da nadomesti koren:
	- podobno kot pri dvojiškem drevesu - gremo v levo vejo in potem skrajno desno
- delamo obratno od splita prej - merge (zlivanje)
- ![600](../../Images3/Pasted%20image%2020250401093342.png)
- najprej se rabimo vedno sprehoditi do lista (O(h)) in delati merge do korena (na enem nivoju je merge O(1), ker gremo do korena je O(h)) => skupaj O(h)

- ![600](../../Images3/Pasted%20image%2020250401094016.png)
- če je b velik, bomo dobili boljše rezultate
- binarno iskanje v enem nivoju (bloku) mora biti zelo poceni in je sploh ne štejemo

B+ drevo:
- pri B drevesu nas omejuje to, koliko podatkov lahko damo v eno vozlišče
	- želimo b čim bolj povečati
	- da povečamo b, moramo zmanjšati velikost enega podatka, ker je velikost bloka omejena s hardwarom
	- namesto, da je npr. cela oseba v vozlišču, so noter samo EMŠO in na koncu ima list s pravim EMŠO kazalec na ostale podatke o osebi
- v njem shranjujemo samo ključe in šele na zadnjem nivoju shranjujemo poleg ključev še vrednost
- dejanske podatke nosijo samo listi:
	- vedno rabimo iti čisto do dna
	- 