- prejšnjič: iskanje najcenejših poti s topološkim in z Dijkstra algoritmom:
	- gledamo, kam pridemo iz ene točke ven
- Bellman-Ford ravno obratno - ko pogledaš eno točko te v bistvu zanimajo obratno sosede, ki vodijo noter

Algoritem:
- Bellman-Ford:
	- dobro ker je splošen - imaš lahko cikle in negativne povezave
	- če detektiramo, da se nobena vrednost v enem koraku ne spremeni, lahko predčasno končamo zunanji for
	- od $d$ vektorjev rabimo hraniti samo prejšnjega in zdejšnjega oz. če gledamo kar trenutne vrednosti in ne gremo striktno po postopku lahko samo en $d$ hranimo
	- če ponesreči gledamo vrednosti trenutne iteravije namesto prejšnje pri računanju novih cen, bomo še vedno prišli do pravilnega rezultata in še hitreje bo

Najcenejše poti med vsemi pari:
- odgovor je matrika, ne samo vektor kot pri iskanju najcenejše poti od ene točke do ostalih
- posplošeni Bellman-Ford:
	- postopoma računam cene najcenejših poti dolžine kvečjemu `h`, `(h=1, 2, ..., n-1)`
	- $d_{ij}$ = cena najcenejše poti od $i$ do $j$
	- $d_{ij}^h$ = cena najcenejše poti od $i$ do $j$, dolžine kvečjemu $h$
	- matrika $D^h = [d_{ij}^h]_{i,j}$
- Floyd-Warshall algoritem:
	- gre inkrementalno $D^1$, $D^2$ ..., ampak namesto, da omejuje število hopov, omeji katere točke lahko uporabiš za vmesne točke
	- npr. med dvema točkama greš lahko samo skozi 1 ali 2; med dvema greš lahko skozi 1 ali 2 ali 3 ...
	- $d_{ij}^k$ = cena najcenejše poti med $i$ in $j$, če za vmesne točke uporabiš le točke 1, 2, ..., k