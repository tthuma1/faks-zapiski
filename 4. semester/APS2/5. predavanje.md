Urejeno (iskalno) drevo:
- v levem poddrevesu so vsi elementi manjši od korena, v desnem pa večji od korena
- kaj če so elementi enaki (to se ne more zgoditi pri npr. slovarju):
	- se odločimo kako bomo to handlali in to dosledno spoštujemo
- find:
	- če je drevo lepo razporejeno, potem z vsakim vozliščem razdelimo preostali del na dva dela
	- če je drevo izrojeno, bo enako hitro kot pri navadnem seznamu
- drevo se izroji, če noter vstavljamo že urejen seznam elementov
- brisanje:
	- a) brišemo element, ki nima naslednikov - ga samo odstranimo
	- b) element ima enega naslednika - samo podaljšam povezavo od starša; preusmerim povezavo iz očeta na naslednika
	- c) brišem element, ki ima dva naslednika (element V) - imamo dve možnosti:
		- x = največji element v levem poddrevesu
		- x = najmanjše element v desnem poddrevesu
		- namesto V pišemo x
		- pobrišemo x (rekurzivno z istim postopkom)
		- x ima vedno enega otroka ali nobenega, ker gremo samo po levih oz. samo po desnih vejah ustreznega poddrevesa, torej se bo rekurzija takoj na naslednjem koraku ustavila
- radi bi čim bolj plitvo drevo, ker je vse do zdaj O(h); naredimo dvojiška drevesa s čim manjšo globino
- ali imam lahko podvojene elemente v urejenem drevesu:
	- v osnovni definiciji slovarja ne dovolimo podvajanja elementov
	- moramo se zmeniti, ali duplikate pišemo v levo ali desno poddrevo
	- a) podvojene elemente pišemo v desno poddrevo
	- b) dodatni števec
- $\Omega(lg n)$, ker je globina dvojiškega drevesa z $n$ elmenti v najboljšem primeru $h = lgn$, če se bo drevo izrodilo, bomo imeli $h = n - 1$
- ![500](../../Images3/Pasted%20image%2020250318090552.png)

Uravnoteženo drevo:
- dvojiško iskalno drevo nam je všeč, ker ima logaritmično časovno zahtevno, če se ne izrodi
- uravnoteženo drevo - elementi so enakomerno razporejeni, zato je drevo plitvo
- razlika v globini med levim in desnim poddrevesom vsakega vozlišča mora biti manjša ali enaka $m$ => drevo je $m$ uravnoteženo
- faktor uravnoteženosti:
	- f = levi.visina - desni.visina
	- če sta levo in desno poddrevo enako globoki, bo f = 0
- drevo je uravnoteženo, ko je za vsako vozlišče $f \leq m$
- f nam pove v katero smer je nagnjeno (predznak) in za koliko (absolutna vrednost)

AVL drevo:
- uravnotežena drevesa pri m=1
- najstarejša uravnotežena podatkovna struktura
- posledica tega, da je drevo uravnoteženo je, da se nikoli ne izrodi
- $h = \Theta(log \; n)$
- velja (težek dokaz): $lg(n + 1) - 1 \leq h \leq 1.44 \cdot lg(n+2) - 1.3$
- konstanta 1.44 je majhna! (pri npr. merge sort je konstanta veliko večja kot pri quick sort) - nas dejansko zanima ko merimo čas, čeprav nas ne zanima pri asimptotiki
- $|f| < 2$ oz. $|f| \leq 1$
- ko se mi uravnoteženost za 1 poruši, naredim rotacijo
- leva in desna rotacija sta inverzni operaciji
- insert:
	- najprej vstavimo enako, kot v običajno iskalno drevo
	- potem popravimo uravnoteženost, če se je pokvarila
	- gremo gor od vstavljenega vozlišča in iščemo prvo neuravnoteženo vozlišče
	- ![600](../../Images3/Pasted%20image%2020250318101252.png)
- https://www.cs.usfca.edu/~galles/visualization/Algorithms.html (https://cmps-people.ok.ubc.ca/ylucet/DS/Algorithms.html)
- https://www.cs.usfca.edu/~galles/visualization/AVLtree.html
- delete:
	- ko brišemo rabimo ravno tako paziti na uravnoteženost drevesa
	- ![600](../../Images3/Pasted%20image%2020250318105228.png)
	- faktor uravnoteženosti je $|f| <= 1$ => za uravnoteženost B imamo možnosti 1, 0 in -1
	- 