
Tabela tabel (cascading arrays):
- podatke hranimo v večih tabelah
- imamo tabele velikosti 1, 2, 4, 8 ...
- vsaka tabela je lahko prazna ali polna (ne more biti na pol polna)
- podatki v posamezni tabeli so urejeni
- ali lahko hitro iščemo elemente?
	- pogeldati moramo v vse tabele ($O(lgn)$ tabel) 
	- v vsaki tabeli iščem z dvojiškim iskanjem ($O(lgn)$)
	- skupna cena iskanja = $O(lgn \cdot lgn) = O(lg^2n)$
- ![500](../../Images3/Pasted%20image%2020250304094202.png)

Slovar:
- ključ, vrednost pari
- element bomo implementirali kot razred:
```
class Elt {
	int key;
	Object value;
}
```
- insert(S, e) -> S
- find(S, key) -> elt
- delete(S, key) -> S

- kaj se zgodi, če dvakrat kličemo insert(S, e) => drugi klic se ignorira
- lahko imamo samo ključe in null vrednosti za value povsod - dobimo množico ključev in na vsak ključ je pripeta null vrednost:
	- slovar je v bistvu razširitev množice, kjer je vsakemu elementu pripet še value
- veliko izvedb z različnimi podatkovnimi strukturami:
	- ![500](../../Images3/Pasted%20image%2020250304101154.png)

Seznam:
- ni nam všeč, da je find $O(n)$ - ali bi kaj izboljšali, če imamo urejen seznam?:
	- nič se ne izboljša
	- ![500](../../Images3/Pasted%20image%2020250304104143.png)

Preskočni seznam (skip list):
- 