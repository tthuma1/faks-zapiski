- CAN bus - da izničimo vplive slablenja signala in odboja/šuma, imamo dvojno (ovito) žico - po eni žici se pošiljajo nespremenjeni podatki, po drugi pa invertirani
- če pride do odboja na eni liniji, pride tudi na drugi liniji, sprejemnik pa bo bral samo razliko med linijama
- žici CANH in CANL
Fizična plast:
- 0 (dominantni bit): CANH je visok, CANL je nizek
- 1 (recesivni bit): CANH je nizek, CANL je visok

- prehod v dominantno stanje je hitro (aktivno), prehod v recesivno stanje je počasno (preko upora)

- transciever ni del boarda, ampak ga rabimo priključiti zraven - omogoča preklop iz logičnih 0 in 1 na napetostne nivoje CAN vodila

- ![650](../../Images3/Pasted%20image%2020250506183855.png)
- vse naprave ves čas poslušajo, odzivajo pa se na podlagi identifikatorja sporočila (del vsebine sporočila), ne na naslov sprejemnika
- kadarkoli bodo naprave videle identifikator, ki pomeni npr. daj mi temperaturo motorja, bodo znale na to reagirati ali ignorirati, če ne znajo odgovoriti
- 11-bitni identifikator sporočila

- RTR = tip okvirja:
	- data frame - okvir, ki nosi informacijo (RTR = 0)
	- remote frame - okvir, ki sprašuje po podatkih (RTR = 1)
- kontrolni biti:
	- DLC = data length (4b), z njimi označimo, koliko bytov sledi kontrolnemu delu:
		- možne vrednosti 0 do 8 pri standardnem CAN
- z identifier se lahko potrudimo, da ne bo dolgega niza ničel ali enic, da ne  rabimo stuff bitov

- ACK slot:
	- tisti, ki pošilja, bo dal tja enico; tisti, ki zna na to odgovoriti, bo dal tu ničlo

- na koncu rabimo deset enic, preden lahko začnemo naslednje okvir

- CAN vodilo je namenjeno več napravam naenkrat:
	- v avtomobilu imamo lahko preko 100 naprav - dobimo več 10 metrov žice (vse to sta isti dve žici)
	- na dveh žicah je lahko več naprav
	- je multimaster vodilo - katerakoli naprava lahko kadarkoli začne pošiljati frame (razen, če se nek frame trenutno pošilja)
	- vse naprave poslušajo vodilo in spremljajo, kaj se gor dogaja
	- vsaka naprava mora od začetka okvirja ves čas natančno spremljati, kaj so dogaja na vodilu
	- če želi naprava pošiljati, mora počakati, da se konča frame in še tisti wait interval za IFS

zaznava trkov:
- naprava mora vedno, ko nekaj pošlje, še prebrati stanje na vodilu, da vidijo, če je prišlo do trka
- arbitraža: kdor je postavil recesivni bit in zaznal dominantnega na vodilu, mora prenehati s pošiljanjem, izgubi pravico do pošiljanja
- arbitraža traja samo do RTR bita (do konca identifikatorja)
- arbitraža se ugotavlja tako, da tisti, ki pošilja, vedno preverja še stanje na vodilu
- sporočila z isstim identifikatorjem morajo imeti enako strukturo naprej
- nimamo predpisanih identifikatorjev glede na proizvajalca kot pri I2C

- kako naj brez ure vem, kdaj je sredina bita:
	- nemogoče je natančno meriti čas, ampak ga rabimo samo dovolj natančno v primerjavi z dolžino bita
	- pri dolgem sporočilu se bo slej ko prej zgodila napaka - rabimo točke, kjer se bomo resinhronizirali - za to bomo uporabili fronte
	- če hočemo imeti fronte, moramo prekinjati dolge nize enakih vrednosti - stuff (vrinjeni bit) bit
	- čim imaš več kot 5 bitov enake vrednosti, moraš vmes vstaviti bit z nasprotno vrednostjo