### Generiranje vmesne kode

- pri Javi je to .class, pri C-ju se to ne vidi uporabniku prevajalnika
- vhod:
	- AST + atributi
- moramo vedeti kako velike so spremenljivke, da vemo koliko prostora rezervirati za statične spremenljivke in za klicni zapis (za avtomatske spremenljivke)
- na velikost (širino) podatkovnih tipov vpliva:
	- arhitektura CPU (kako velike registre ima CPU)
	- klicni dogovor (kako sprejmemo parametre, kako vračamo rezultate)
	- to pronica iz backenda prevajalnika do frontenda
- izhod:
	- AST + atributi + atribut vmesne kode ALI
	- samo vmesna koda

- kje je spremenljivka povemo z labelo (statična sprem.) ali z odmikom (avtomatska sprem.)
- vmesna koda ima lastne operacije za seštevanje, množenje ...

- včasih rabimo kakšne operacije, ki jih arhitektura CPU ne podpira, sami generirati softwaresko, npr. če ima naš CPU 32-bitne registre, mi pa želimo long int v C, rabimo workaround z dvema registroma:
	- podobno če hočemo floating point operacije in nimamo FPU enote - FPU operacije pretvorimo v celoštevilske ukaze, ki delajo po IEEE 754 standardu, da se obnašajo kot floating point operacije

- znati moramo operacije iz izvornega jezika na nek način prepisati v operacije, ki jih CPU razume
- lahko se zgodi da iz enega psevdoukaza dobimo nov psevdoukaz, ki se v naslednji iteraciji vmesne kode naprej prevede

- včasih linker skupaj s prevajalnikom ve, kakšni so odmiki, ker šele linker lahko ve, na katerih fizičnih naslovih bodo stvari stale => včaih prevajalnik in linker spreminjata našo kodo, ki smo jo napisali

- večina branchov naredi skoke, ki so blizu, ker so v zankah