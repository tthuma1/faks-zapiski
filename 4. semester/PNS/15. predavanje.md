- kako pridemo od vmesne kode do strojne kode
- frontend: od vnešenega programa do vmesne kode
- backend: od vmesne kode do strojnega jezika (zbirnika)
- pogosto se postavi še vmesni del (middleend), ki je namenjen optimizaciji vmesne kode
- ko pišemo prevajalnik lahko vzamemo gcc ali LLVM backend, ki na začetku postavita vmesno kodo in svoj programski jezik prevajamo v to vmesno kodo:
	- potem backend optimizira vmesno kodo
- optimizacija je lahko pred vmesno kodo - ko optimizator še ve iz katerega jezika se to prevaja (na visokem nivoju)
- optimizacija vmesne kode - kako optimizirati vmesno kodo neodvisno od vnešenega jezika
- na koncu lahko še strojno kodo optimiziramo (najbolj low level)

- seznam ukazov vmesne kode -> seznam osnovnih blokov -> generiranje strojnih ukazov (brez registrov - v strojnih ukazih so začasne spremenljivke) (določimo strojne ukaze) -> analiza začasnih spremenljivk -> dodeljevanje registrov (določimo registre)
- ko imamo strojne ukaze + registre imamo strojno kodo

- osnovni blok:
	- zaporedje ukazov, ki:
		- 1. se začne z oznako (labelo)
		- 2. se konča s skokom
		- 3. sicer ne vsebuje oznake ali skoka
- ukazi v procesorju so atomarni - se v celoti izvršijo ali ne - z osnovnimi bloki je enako:
	- ko se en blok začne izvrševati, se bo izvršil do konca; seveda v več korakih, ampak ne more se vmes končati
	- veš, da boš od labele izvršil vse ukaze in na koncu jumpal
	- ker vmes ni jump ukazov, pomeni, da se bo pri vseh ostalih ukazih PC povečal za en ukaz naprej; ko priletimo v osnovni blok, bomo vedno izvršili vse ukaze do jumpa
- CALL - spreminja PC drugače kot PC = PC+1, ampak na koncu funkcija returna in se bo izvajanje nadaljevalo naprej od CALL-a => v osnovnem bloku je lahko CALL, ker se bo tudi v tem primeru osnovni blok izvršil do konca (tudi če skočimo ven, gremo potem naprej do konca osnovega bloka)
- osnovni blok je večji od ukaza, ampak se vedno izvede v celoti