- kako pridemo od vmesne kode do strojne kode
- frontend: od vnešenega programa do vmesne kode
- backend: od vmesne kode do strojnega jezika (zbirnika)
- pogosto se postavi še vmesni del (middleend), ki je namenjen optimizaciji vmesne kode
- ko pišemo prevajalnik lahko vzamemo gcc ali LLVM backend, ki na začetku postavita vmesno kodo in svoj programski jezik prevajamo v to vmesno kodo:
	- potem backend optimizira vmesno kodo
- optimizacija je lahko pred vmesno kodo - ko optimizator še ve iz katerega jezika se to prevaja (na visokem nivoju)
- optimizacija vmesne kode - kako optimizirati vmesno kodo neodvisno od vnešenega jezika
- na koncu lahko še strojno kodo optimiziramo (najbolj low level)

- seznam ukazov vmesne kode -> seznam osnovnih blokov -> generiranje strojnih ukazov (brez registrov - v strojnih ukazih so začasne spremenljivke) (določimo strojne ukaze) -> analiza začasnih spremenljivk -> dodeljevanje registrov (določimo registre)
- ko imamo strojne ukaze + registre imamo strojno kodo

- osnovni blok:
	- zaporedje ukazov, ki:
		- 1. se začne z oznako (labelo)
		- 2. se konča s skokom
		- 3. sicer ne vsebuje oznake ali skoka
- ukazi v procesorju so atomarni - se v celoti izvršijo ali ne - z osnovnimi bloki je enako:
	- ko se en blok začne izvrševati, se bo izvršil do konca; seveda v več korakih, ampak ne more se vmes končati
	- veš, da boš od labele izvršil vse ukaze in na koncu jumpal
	- ker vmes ni jump ukazov, pomeni, da se bo pri vseh ostalih ukazih PC povečal za en ukaz naprej; ko priletimo v osnovni blok, bomo vedno izvršili vse ukaze do jumpa
- CALL - spreminja PC drugače kot PC = PC+1, ampak na koncu funkcija returna in se bo izvajanje nadaljevalo naprej od CALL-a => v osnovnem bloku je lahko CALL, ker se bo tudi v tem primeru osnovni blok izvršil do konca (tudi če skočimo ven, gremo potem naprej do konca osnovega bloka)
- osnovni blok je večji od ukaza, ampak se vedno izvede v celoti
- smo povečali enote, ki se bodo vedno ali izvršile ali ne

- vmesna koda - lahko je drevesna ali skladovna:
	- drevesna - zaporedje ukazov, znotraj katerih ima en ukaz več stavkov => je težje ugotoviti vrstni red izvajanja
	- f(g) ...:
		- spremenili smo eno veliko drevo v več majhnih, ampak smo pri tem dobili cel kup začasnih spremenljivk
		- večkrat kličemo g(5) in g(7) - zakaj tega ne smemo vreči stran:
			- ker lahko ta funkcija lahko npr. vrača svoj argument + nek števec, in ne smemo izgubiti povečanja števca
			- da bi se lahko izognili dveh klicem, bi morali vedeti, da ta funkcija nima nobenih stranskih učinkov - nič ne dela z I/O napravami, ne spreminja globalnih spremenljivk
		- to spremenjeno kodo potem razbijemo na osnovne bloke

- zakaj spremeniti kodo v osnovne bloke:
	- pogojni skoki in klici znervirajo procesor, ker mora podreti sklad in od drugod črpati operande, ki mogoče niso v predpomnilniku
	- katerakoli permuaticja osnovnih blokov bo v redu; samo ta prve ne smemo premikati, kakorkoli premešamo ostale osnovne bloke, bo v redu
	- zadnji jump nas pelje nekam ven
	- želimo optimizirati, da bodo jumpi krajši (da lahko uporabimo relativen odmik)
	- nekatere skoke lahko celo vržemo ven, če skočijo na labelo, ki je takoj naslednja - včasih lahko skoke brišemo
	- delamo permutacije blokov in včasih pogojne skoke obrnemo, da spremenimo, kdaj skočimo in kdaj pademo skozi, da minimiziramo število skokov
	- osnovne bloke razvrstim tako, da je negativna labela vedno za conditional jump
	- conditional jump nam ni všeč, ker vedno skoči, ampak ne vemo kam
	- včasih ko delamo permutacije ugotovimo, da do enega nikoli ne pridemo - unreachable code

- ne moremo preveriti čisto vseh permutacij blokov:
	- uporabimo požrešni algoritem za permutaicjo osnovnih blokov
	- začnemo s prvim blokom
	- če je na koncu jump, mu damo tistega, na katerega skače
	- če je na koncu conditional jump, damo za njega false labela
	- če je blok, ki ga hočemo dati naslednjega, že uporabljen, bomo pač to morali sprejeti, da bomo imeli slab skok (včasih bomo pri pogojnih skokih še vedno rabili dva BRANCH ukaza, čeprav nam to ni všeč)