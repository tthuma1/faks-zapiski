- klicni zapis = del sklada, ki si ga funkcija rezervira vedno, ko je poklicana:
	- prva stvar, ki jo funkcija naredi je nekaj administrativnih stvari, da se sploh lahko začne izvajati - pripravi klicni zapis in vanj spravi stvari
	- skladovni kazalec kaže na zadnjo zasedeno lokacijo
	- klicni zapis = frame; omejujeta ga spodaj skladovni kazalec in zgoraj klicni kazalec; vse vmes je klicni zapis
- zgoraj je še več klicnih zapisov (klicni zapisi prejšnjih funkcij), spodaj ni nobenih klicnih zapisov, ker tam ni nobene druge funkcije
- lokalne spremenljivke:
	- zadnjič smo jim rekli, da so avtomatske
	- pripadajo posameznemu klicu funkcije, se uničijo, ko se funkcija konča
- ko prejšnja funkcija reče `call`, se instruction pointer nastavi na naslov naslednje funkcije, naslov naslednjega ukaza, kamor se moramo vrniti, pa se shrani v link register (oz. nek poseben register, branch with link):
	- vrednost iz link registra bi se prepisala, če bi naslednja funkcija klicala neko drugo funkcijo - zato si rabimo vrednost link registra čisto na zažetku shraniti v return address
- ko ta funkcija kliče drugo funkcijo, damo argumente v registre ali na sklad:
	- prek registrov je hitreje, prek sklada rabimo, ko ne gre vse v registre (več prostora)
	- funkcija, ki jo kličemo, vrača nek rezultat - spet lahko preko sklada ali prek registrov
- argument = vrednost parametra
- parameter je vedno inicializiran, lokalne spremenljivke pa niso nujno; čeprav so obeje avtomatske lokalne spremenljivki
- argimente klica dobimo iz prejšnjega klicnega zapisa (tik nad FP)
- primer iz zvezka: x in y sta priletela iz argumentov prejšnjega klicnega zapisa in sta sedaj moja parametra; parametri funkcije so zunaj klicnega zapisa, tik nad njim
- ko iz ene funkcije kličemo drugo, moramo paziti, da si ne popacamo registrov:
	- pri klicu si je treba registre shraniti
	- registre lahko shrani tista funkcija, ki kliče, lahko tista, ki je poklicana, ali pa pol pol
	- tista funkcija, ki kliče: druga funkcija lahko dela karkoli hoče in smo mi varni
	- tista funkcija, ki je klicana: takrat mora klicoča funkcija zaupati klicani, da pravilno shrani registre - klicana funkcija ve, koliko registrov bo porabila in lahko shrani manj registrov
	- bolj se splača, da klicana funkcija shrani registre, ker je boljši performance
	- pol pol: klicoča in klicana funkcija se zmenita, katera shrani kaj
- začasne spremenljivke:
	- imamo veliko spremenljivk, ampak nujno rabimo še en register - če nam zmanjka registrov, nove spremenljivke shranimo med začasne spremenljivke
- čim več argumentov si želimo prenašati prek registrov in čim manj prek sklada:
	- pri tem mora biti zelo natančen dogovor, kateri argumenti ostanejo v registrih in kateri gredo na sklad - klicni dogovor (calling convention)
	- klicni dogovor določa kaj gre v registre in kaj v sklad, kako so parametri zloženi, kako se rezultati vračajo ipd.
	- klicni dogovor določi proizvajalec procesorja, poleg tega ga določi še OS (tipično napisan v C-ju)
- če imamo statično spremenljivko, moramo vedeti, na katerem naslovu je, kako velika je
- pri avtomatskih (lokalnih) spremenljivkah moramo vedeti:
	- velikost (dobimo iz tipa)
	- odmik lokalne spremenljivke od klicnega kazalca; lokalne spremenljivke imajo odmik negativen (pišemo jih navzdol), parametri pa imajo odmik pozitiven (so navzgor od FP)
	- pri odmikih moramo upoštevati še pomnilniško poravnanost - ali so npr. char lahko kjerkoli, ali morajo biti poravnani na 4B

- statična povezava (static link, SL):
	- omogoča nam, da imamo gnezdene funkcije
	- lokalna spremenljivka v f3 bo večkrat v pomnilniku - enkrat za vsak klic f3
	- v SL je vedno naslov vrednosti FP od nekoč prej
	- z vsakim nivojem globje, rabimo en dostop do pomnilnika več:
		- dostop do spremenljivke i1, je iz f2 in f3 drag - zato so lokalne spremenljivke dobre
- ko zlagam arugmente, dam najprej gor statično povezavo in potem argumente (vrednosti parametrov)