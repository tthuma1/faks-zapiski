- klicni zapis = del sklada, ki si ga funkcija rezervira vedno, ko je poklicana:
	- prva stvar, ki jo funkcija naredi je nekaj administrativnih stvari, da se sploh lahko začne izvajati - pripravi klicni zapis in vanj spravi stvari
	- skladovni kazalec kaže na zadnjo zasedeno lokacijo
	- klicni zapis = frame; omejujeta ga spodaj skladovni kazalec in zgoraj klicni kazalec; vse vmes je klicni zapis
- zgoraj je še več klicnih zapisov (klicni zapisi prejšnjih funkcij), spodaj ni nobenih klicnih zapisov, ker tam ni nobene druge funkcije
- lokalne spremenljivke:
	- zadnjič smo jim rekli, da so avtomatske
	- pripadajo posameznemu klicu funkcije - se naredijo vsakič, ko se funkcija kliče in uničijo, ko se funkcija konča
- ko prejšnja funkcija reče `call`, se instruction pointer nastavi na naslov naslednje funkcije, naslov naslednjega ukaza, kamor se moramo vrniti, pa se shrani v link register (oz. nek poseben register, branch with link):
	- vrednost iz link registra bi se prepisala, če bi naslednja funkcija klicala neko drugo funkcijo - zato si rabimo vrednost link registra čisto na zažetku shraniti v return address
- ko ta funkcija kliče drugo funkcijo, damo argumente v registre ali na sklad:
	- prek registrov je hitreje, prek sklada rabimo, ko ne gre vse v registre (več prostora)
	- funkcija, ki jo kličemo, vrača nek rezultat - spet lahko preko sklada ali prek registrov
- argument = vrednost parametra
- parameter je vedno inicializiran, lokalne spremenljivke pa niso nujno; čeprav so obeje avtomatske lokalne spremenljivki
- argimente klica dobimo iz prejšnjega klicnega zapisa (tik nad FP)
- primer iz zvezka: x in y sta priletela iz argumentov prejšnjega klicnega zapisa in sta sedaj moja parametra; parametri funkcije so zunaj klicnega zapisa, tik nad njim
- ko iz ene funkcije kličemo drugo, moramo paziti, da si ne popacamo registrov:
	- pri klicu si je treba registre shraniti
	- registre lahko shrani tista funkcija, ki kliče, lahko tista, ki je poklicana, ali pa pol pol
	- tista funkcija, ki kliče: druga funkcija lahko dela karkoli hoče in smo mi varni
	- tista funkcija, ki je klicana: takrat mora klicoča funkcija zaupati klicani, da pravilno shrani registre - klicana funkcija ve, koliko registrov bo porabila in lahko shrani manj registrov
	- bolj se splača, da klicana funkcija shrani registre, ker je boljši performance
	- pol pol: klicoča in klicana funkcija se zmenita, katera shrani kaj
- začasne spremenljivke:
	- imamo veliko spremenljivk, ampak nujno rabimo še en register - če nam zmanjka registrov, nove spremenljivke shranimo med začasne spremenljivke
- čim več argumentov si želimo prenašati prek registrov in čim manj prek sklada:
	- pri tem mora biti zelo natančen dogovor, kateri argumenti ostanejo v registrih in kateri gredo na sklad - klicni dogovor (calling convention)
	- klicni dogovor določa kaj gre v registre in kaj v sklad, kako so parametri zloženi, kako se rezultati vračajo ipd.
	- klicni dogovor določi proizvajalec procesorja, poleg tega ga določi še OS (tipično napisan v C-ju)
- če imamo statično spremenljivko, moramo vedeti, na katerem naslovu je, kako velika je
- pri avtomatskih (lokalnih) spremenljivkah moramo vedeti:
	- velikost (dobimo iz tipa)
	- odmik lokalne spremenljivke od klicnega kazalca; lokalne spremenljivke imajo odmik negativen (pišemo jih navzdol), parametri pa imajo odmik pozitiven (so navzgor od FP)
	- pri odmikih moramo upoštevati še pomnilniško poravnanost - ali so npr. char lahko kjerkoli, ali morajo biti poravnani na 4B

- statična povezava (static link, SL):
	- omogoča nam, da imamo gnezdene funkcije
	- lokalna spremenljivka v f3 bo večkrat v pomnilniku - enkrat za vsak klic f3
	- v SL je vedno naslov vrednosti FP od nekoč prej
	- z vsakim nivojem globje, rabimo en dostop do pomnilnika več, da pridemo do spremenljivk, ki so definirane na nižjih nivojih:
		- dostop do spremenljivke i1, je iz f2 in f3 drag - zato je bolje uprorabiti lokalne spremenljivke, da je dostop hitrejši
- ko zlagam arugmente, dam najprej gor statično povezavo in potem argumente (vrednosti parametrov)
- statična povezava je v bistvu "skrit" argument, ki ga programer ne vidi, ampak vedno je tam (če jezik dovoljuje gnezdene funkcije); ki se spremeni v skrit parameter
- v Pythonu imamo self, v Javi imamo this - pri Pythonu je self vedno parameter, this v Javi je skrit parameter, ki ga pošlje avtomatsko

- C daje prednost hitrosti - zato nima gnezdenih funkcij; npr. Pascal daje prednost modularnosti in zato ima gnezdene funkcije

- display tabela:
	- je hitrejša, ker imamo manj dostopov do pomnilnika
	- na nivoju 1 in 2 je isto hitro, na nivoju 0 pa rabimo en dostop do pomnilnika, namesto dveh - če gremo vsaj dva nivoja višje do spremenljivke, si prihranimo dostope do pomnilnika
	- problem: moramo vedeti, kolikšna je maksimalna globina v programu - je preprosto, če je program v eni datoteki, če pa je v večih datotekah, moramo vzeti max globino od vseh datotek (to sicer niti ni težko) - to moramo vedeti, da naredimo dovolj veliko display tabelo
	- če pripravim tabelo kazalcev (display tabelo), pomeni da za npr. 100 globine rezerviram 800 B => ne porabimo veliko dodatnega prostora za tabelo

- ko pošljem funkcijo kot parameter, pošljem kazalec na prvi ukaz funkcije - če bi imel C gnezdene funkcije, bi imeli težave, ker C pusti vračati funkcije (returnamo pointer na funkcijo, na prvi ukaz funkcije) (primer v zvezku):
	- če ima zunanja funkcija neko lokalno spremenljivko in se `g` kliče po tem, ko se je `f` končal, `m` ne bo več obstajal, ker je umrl skupaj s `f`
	- to zna npr. Haskell bolje, ker ko vrača funkcijo, ne vrne naslova na prvi ukaz funkcije, ampak vrne closure (vrne funkcijo in spremenljivke, ki jih uporabi, da zagotovi, da je `m` nekje shranjen, ko pridemo do `g`)