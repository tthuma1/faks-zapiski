1. leksikalna analiza:
	- program v izvorni kodi razrežemo na besede - dobimo leksikalne simbole (seznam leksikalnih simbolov) (LS)
2. sintaksna analiza:
	- med leksikalno analizo smo samo razrezali program na besede, nismo se pa vprašali ali so v pravem vrstnem redu
	- sintaksna analiza se vpraša ali je siznam leksikalnih simbolov tak, da so leksikalni simboli v pravem vrstnem redu
	- če so v pravem vrstnem redu, nam sintaksna analiza naredi drevo izpeljav - LS da v drevo
	- vidimo strukturo svojega programa v drevesu
	- ta drevesa ponavadi niso čisto taka kot bi si želeli => naredimo abstraktno sintakso
3. abstraktna sintaksa:
	- dobimo abstraktno sintaksno drevo (AST)
	- včasih namesto napake v sintaksi dobimo npr. spremenljivka ni definirana
4. semantična analiza:
	- ali so vse spremenljivke definirane, ali so pravih tipov, glede na to, kaj delamo z njimi
	- dobimo abstraktno sintaksno drevo + atributi
	- tu se konča analiza našega programa v izvorni kodi, se lotimo tvorjenja prevoda
5. klicni zapisi:
	- tvorimo obliko klicnih zapisov
	- kaj se dogaja na skladu, kje v pomnilniku je kakšna spremenljivka
	- klicni zapis je del sklada, ki je dodeljen posamezni funkciji, ko je klicana
	- v tej fazi naredimo načrt, kako bo del sklada, ki je del konkratne funkcije izgledal, ko se funkcija izvaja
	- dobimo AST + atributi + klicni zapisi
6. generiranje vmesne kode:
	- v tej fazi se tvori vmesna koda - to ni ne izvorna, ne tisto kar želimo rezultat prevajalnika
	- pri Javi je to bytecode, računalnik brez JVM ne more izvajati tega
	- zakaj sploh?
		- včasih jo rabimo
		- če hočemo generirati strojno kodo, je običajno lažje, če gremo iz enega jezik v drugega in potem v strojno kodo - imeli bomo krajše, enostavnejše korake
	- dobimo vmesno kodo, lahko je bolj ali manj primerna za izvajanje naprej
7. linearizacija vmesne kode
	- vmesno kodo še naprej poenostavimo, jo naredimo še bolj podobno zbirniku
	- dobimo linearizirano vmesno kodo
	- linearizirana je zato, da jo lahko izvajamo korak po korak kot strojni jezik - od tu naprej lahko uporabimo tolmač (interpreter) in izvedemo originalni program
	- Java npr. bytecode zapiše v .class datoteko in potem to poženemo s tolmačem
	- lahko je tudi tolmač in vse te faze prevajalnika v enem programu
	- lahko bi si ko dobimo linearizirano vmesno kodo izbrali en specifičen procesor - v nadaljevanje pošljemo lin. vmesno kodo in generiramo stojno kodo
8. generiranje strojne kode:
	- ukazi, ne registri; delamo se, da imamo poljubno mnogo registrov (lahko tudi rečemo, da imamo tisoče registrov, ker se bo to potem še popravimo)
9. analiza spremenljivk (registrov):
	- izračunamo v katerem delu programa je kateri izmed tistih ogromno registrov res uporabljenih
	- kje je kakšen od navideznih registrov res uporabljen
	- če ugotovimo da je npr. en register uporabljen samo na začetku in drugi samo na koncu, ju lahko damo v en fizični register
10. dodaljevanje registrov:
	- od 5000 navideznih registrov določimo v kateri fizični register gre vsak
	- če nam ne uspe, moramo za kakšnega izmed registrov predvideti, da ga bomo dali na sklad (zraven klicnih zapisov)
11. izpis prevoda:
	- dodamo npr. headerje in vse skupaj zapišemo v neko izhodno datoteko
	- dobimo program v ciljni kodi (običajno je to zbirni jezik, ne strojni)
	- gcc vrne izvršjivo datoteko (a.out)
	- lahko dobimo obj datoteko (a.o) - to je datoteka v zbirnem jeziku, ne v strojnem

	- načeloma si želimo, da bi znal prevajalnik tudi optimizirati našo izvorno kodo  - največ optimizacij se dogaja pri generaciji vmesne kode, pri generaciji strojne kode in po dodajanju registrov

- do vključno generacije vmesne kode je "sprednji del" (frontend), naprej je zadnji del prevajalnika

GCC:
- C => vmesna koda => x86
- v isto vmesno kodo lahko prevedem tudi C++, Fortran, Javo, Go ...

- ko imamo enkrat lepo definirano vmesno kodo in prehod do x86, rabimo za vsak naslednji prevajalnik delati le polovico dela
- ko se pojavi npr. ARM, RISC-V lahko dobimo prevajalnik za novo arhitekturo za polovico dela, ker imamo do vmesne kode že narejene
- lahko vzamemo backend od GCC in napišemo samo frontend in dobimo prevajalnik za vse procesorje
- če želimo dodati prevajalnik za nek eksotičen procesor, lahko samo napišemo svoj backend in vzamemo od GCC frontend in dobimo za celo množico programskih jezikov prevajalnik
- zato se splača delitev na frontend in backend

- clang prevajalniki imajo isto zgodbo:
	- sprednji del je od clang, zadnji del pa je LLVM (low level virtual machine)