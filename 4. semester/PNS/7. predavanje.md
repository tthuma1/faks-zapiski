- Java nam pomaga še z npr. ali je nek del kode nedosegljiv, funkcija ne vrača rezultata ...

### Semantična analiza
- vhod = AST
- izhod = AST + atributi
- atribut je vrsta podatka, ki ga nalepimo na posamezno vozlišče drevesa:
	- npr. unikatna številka vozlišča; če ima drevo n vozlišč, hočemo vsakemu dati eno številko
	- imamo različne razrede z dodatnimi atributi
	- zakaj moramo izračunati atribute? da preverimo, da so stvari v redu in da bomo kasneje znali generirati prevod
- po koncu semantične analize bomo vedeli, ali se program lahko prevede (vemo, da je vse v redu definirano); od tu naprej se začne sinteza
- ko semantična analiza reče, da je program pravilen, to samo pomeni, da je v skladu s pravili programskega jezika, ne da dela tisto, kar programer hoče
- npr. C včasih prevede program, ki je v nasprotju z jezikom:
```C
int f(int x, int y){
	int *p;
	p = &x;
	printf("%d", p[1]);
	return *p;
}
```
- `p[1]` je nasleden int za `x`, ampak ne vemo zares, kaj je tam (mogoče je y, mogoče je kaj drugega)
```c
int f(int *x) {
	printf("%d", *x);
	return *x;
}
f(NULL);
```
- ^ dobimo segmentation fault, ker uporabniški program nima dostopa do naslova 0x0000
```c
int x = 0;
print("%d", 5/x);
```
- pri semantični analizi prevajalnik v splošnem ni sposoben ugotoviti, da bo prišlo do npr. deljenja z 0; pri zgornjem primeru bi še šlo
```c
int x = f(7);
print("%d", 5/x);
```
- ^ kako lahko vemo, da bo f(7) vrnil 0
- vedno lahko napišem tako funkcijo f(), da prevajalnik ne more ugotoviti, kaj bo vrnilo

- pri semantični analizi imamo cel kup problemov, ki bi jih radi zaznali, ampak jih ne moremo
- tudi v Javi se da napisati program z nedosegljivo kodo, ki je Java ne bo zaznala
```java
if (true) System.exit(1);
...
```

1. razreševanje imen:
	- postopek, kjer preverimo, ali so vsa imena, ki jih uporabimo, ustrezno prej definirana
2. preverjanje tipov:
3. \* to ni vse: semantična analiza je še mnogo več