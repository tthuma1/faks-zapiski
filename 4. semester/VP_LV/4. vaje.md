- pwn_3 in pwn_6
- `objdump -d main | grep "<win>"`
- `x/10gx $rsp`
- `objdump -d main | grep "<win>" -A 30`
- `rax` je splošnonamenski register, `eax` je isto, ampak 32-bit
- ![200](Images3/Pasted%20image%2020250324133621.png)
- ^ vrednost, ki je za 8 odmaknjena od rbp se primerja z `rax`
- ![200](Images3/Pasted%20image%2020250324133643.png)
- v `rdi` in `rsi` grejo argument ob klicu
- v bistvu primerjamo `0xdeadbeef` z argumentom (`0xdeadbeef` je v `rax` oz. `eax`, argument pa v `rdi` in tudi v `-0x8(%rbp)`)
- ![200](Images3/Pasted%20image%2020250324134520.png)
- ^ tu se `0xdeadbeef` nastavi na `rax`
- ROP - return oriented programming:
	- ne samo zalaufamo neko zadevo, ampak chainamo majhne dele kode, da nastavimo registre tako, kot jih rabimo
	- ROP gadget
	- `ROPgadget --binary main`
	- gadgeti imajo majhno število ukazov in na koncu `ret`
	- na koncu imamo v funkcijah `leave` (premakne base pointer; `leave -> pop $rbp`) in `ret` (premakne ret_addr v instruction pointer; `ret -> pop $rip`)
	- na koncu je pri nas samo `ret` brez `leave`, ker se potem ne ukvarjamo s tistim, kar ostane na stacku
- hočemo nastaviti `rdi` in `rpi` na pravilno vrednost
- `ROPgadget --binary main | grep rdi`
- prav bi nam prišlo `pop rdi` - to premakne stvar, na katero kaže vrh stacka v `rdi`
- `ROPgadget --binary main | grep "pop rdi"`
- pop še premakne stack pointer za en naslov gor

- rabimo nastaviti še `rsi`
- `ROPgadget --binary main | grep "pop rsi" | grep ret`
- ![300](Images3/Pasted%20image%2020250324135913.png)
- ROP chain = chainani ROP gadgeti

- `x/20gx $rsp`
- ![500](Images3/Pasted%20image%2020250324141052.png)
- ^ memory takoj po tem, ko se požene gets
- ![600](Images3/Pasted%20image%2020250324141236.png)
- na RBP so šli B-ji, pri vsakem pop se stack pointer premakne, RIP se je spremnil z `pop rip` oz. `ret`
- 