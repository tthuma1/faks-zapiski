Return oriented programming
- izvajamo veliko majhnih kosov kode (gadgets), ki spremenijo neke registre in jih sestavimo skupaj v sebi dopadljivo zaporedje
- manjša kot je kocka, več stvari lahko zgradimo z njo, lahko jo reusamo

Gadgets:
- `leave` in `ret` ukaza
- leave:
```
mov rsp, rbp
pop rbp
pop rip
```
- base (frame) pointer nam pove naslov prejšnjega stacka, da lahko popravimo stack pointer nazaj
- 1. korak: rsp premaknemo na mesto, kjer je kazal rbp
- 2. korak: dobimo nov rbp s pop
- 3. korak: ret addr se zapiše v rip, da potem skočimo na ta naslov (PC se nastavi na rip, ne PC=PC+1)

- imamo mnogo "pop/ret" kombinacij
- v posamezne registre lahko vstavimo poljubne vrednosti:
	- če ima neka oseba dostop do nečesa, je to najbrž neka vrednost v registru
	- nastavimo poljubno vrednost in namesto da skačemo na win funkcijo, si jo lahko sami sestavimo iz gadgetov
	- npr. funkcije, ki nastavi moj account na admin ni, ampak jo lahko sestavimo iz gadgetov
	- ne skoči na win funkcijo ampak skoči na kos kode, naredi kar želiš in skoči na naslednji kos kode in ponavljaj

- če bomo veliko gadgetov sestavljali skupaj, bomo verjetno kaj polomili
- zelo zamudno sestavljanje

Primer:
- nikjer se ne kliče funkcija win
- prejšnji teden:
	- prepišemo canary in v ret addr napišemo naslov win funkcjie, ki ga dobimo za disassembly
- vemo, kateri argument funkcije je na katerem registru (če bi bilo preveč argumentov, bi šli na stack)
- https://syscall.sh
- ![600](../../Images3/Pasted%20image%2020250313084544.png)

- syscall-i so v tabeli, torej če bi enega hoteli pobrisati, bi morali vse offsete spremeniti (vse vrstice zamakniti gor; x64 ima manj syscallov, ker je bilo itak vse treba spremeniti in smo ven pometali še stvari, ki jih ne raibmo