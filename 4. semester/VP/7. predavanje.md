### Avtentikacija, avtorizacija, enkripcija

- openID, OAuth

Avtentikacija:
- ugotavljamo identiteto uporabnika; "ti si Janez"
- ne želimo, da vsi lahko vidijo tisto, kar mi vidimo
- ne želimo, da se lahko kdorkoli lahko predstavi kot kdorkoli
- ime in geslo, certifikati (si pass), MFA, passkey
- problem MFA, če imaš preko SMS:
	- nekdo ti lahko ukrade SMS avtentikacijo, če hijacka tvoj ISP (SS7)
	- sim swapping
- kako prisluškovati GSM klicem:
	- postaviš svojo anteno in rečeš, da boš ti dal key

- kaj lahko Mirko naredi, ko ugotovimo, da je Mirko - avtorizacija nam pove, katere operacije lahko posamezni uporabnik oz. skupine delajo
- vedno, ko avtentikacija sloni na neki tretji entiteti (sigenca), je to spet ranljivo, ker nimamo nadzora nad tem sistemom

Avtorizacija:
- npr. nočemo, da si študent sam vpiše oceno
- potrjevanje/omogočanje operacije
- npr. potrjevanje transkacije v banki:
	- banka ima nek ruleset, kaj je normalna transakcija
	- če si ravnokar v Ljubljani in je prišla neka transakcija iz Londona, te bo banka poklicala, če si to res ti naredil
	- avtorizacija ni nujno samo od ene osebe (ti sebi avtoriziraš transakcijo), ampak lahko tudi od več oseb (banka)
- od tu naprej že verjamem, da je Jože res Jože; vseeno je lahko morebitna dodatna preverba
- ne zagotavlja ali je kanal, po katerem delam to operacijo res varen - za to rabimo enkripcijo

Enkripcija:
- samo jaz in ti veva, o čem se pogovarjava
- jaz z zasebnim ključem podpišem, on pa z javnim ključem preveri, da sem res jaz podpisal
- včasih smo še vedno ranljivi s človeškim faktorjem, ki lahko izda zaupne podatke
- HTTPS certifikati:
	- pogleda datum veljavnosti certifikata
	- Certification Authority izdaja certifikate, mu zaupamo, je vse v redu, dokler jim ne ukradejo ključev, ker potem si lahko v njihovem imenu izdamo certifikat za neko spletno stran, ki ni zares naša

- ![300](../../Images3/Pasted%20image%2020250410090031.png)

Primeri storitev in standardov:
- (PHP) session, OpenID, OAuth
- nekega uporabnika ne želimo ves čas spraševati, če je to res on
- ne želimo za vsak app, ki ga naredimo imeti še svojega sistema za avtentikacjo
- želimo minimizirati effort, da ne implementiramo vedno skoraj iste stvari - single sign on (npr. od Google, Githuba)
- ko uporabimo SSO, povemo, do česa vsega lahko dostopa aplikacija, ki jo avtoriziramo (npr. pri Github SSO ji damo dostop, da lahko dela commite, ne pa da dela nove repozitorije); omejimo katere podatke o tebi lahko bere neka aplikacija (npr. Google ji bo dal tvoje ime, ampak ne tvoje telefonske)

PHP session:
- `$_SESSION` spremeljivka
- ![500](../../Images3/Pasted%20image%2020250410091212.png)

Problemi:
- na vsakem sistemu se rabiš na novo avtorizirati, ves čas moraš iste podatke dajati na različne sisteme
- to je problem tudi za firme, ker nimaš nekega uporabnika poenotenega
- poskus reševanja s caching serverjem, ki hrani seje:
	- še vedno omejeno samo na produkte ene firme (enititete)
- problematike:
	- kraja piškotov
	- več sej se breaka, ko imamo več tabov