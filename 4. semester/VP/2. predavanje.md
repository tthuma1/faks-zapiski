- sklad: dajemo vrednosti gor in dol
- kopica: gor hranimo podatki, ki so preveliki za na sklad

- ![600](../../Images3/Pasted%20image%2020250227082229.png)
- malloc = računalniku rečemo, da naj nam da spomin, lahko ga da ali pa ne; je sistemski klic:
	- pomembno tudi iz vidika varnosti vedeti, kam lahko nek proces dostopa, če imamo neke skrivnosti (ključe), ne morejo drugi procesi tistega brati in pisati
- ko dajemo neke konstante v program, grejo na stack
- heap in stack rasteta eden proti drugemu - to je že malo zaščita, da ne zraste preveč - takrat rabimo povečati procesno sliko

malloc:
- vrača void pointer
- `ptr = (int*) malloc(100 * sizeof(int));`
- ne veš koliko velik je int, zato rabiš sizeof
- `if (ptr == NULL)` => pomeni, da nismo dobili pomnilnika
- za sprostitev - free
- calloc in realloc
- calloc je kot malloc, ampak da vse še na 0
- če hočemo array povečati, rabimo realloc
- sistemski klici so dragi

- `a[0]` - v oklepaju povemo odmik od `a`
- `*(p + 0) = p[0]`

- `free` samo reče, da ne boš več uporabljal spomina, ampak ga ne izbriše; OS ta del prostora lahko da nekomu drugemu, ki potem čez piše
- če naredimo `malloc`, `free`, `malloc`, se bo drugi malloc najbrž izvedel na istem delu, proba reclaimat ta prostor; dobimo isti prostor, ker je tam v segmentu prazen prostor + hočemo ohranjati pomnilniško lokalnost (stvari, ki nam hkrati prav pridejo, jih želimo imeti čim bližje v pomnilniku, da jih več pride na predpomnilnik)

printf:
- `printf("%.0f", 13.5)` - izpiše 14, ker format zaokroži

scanf:
- bere do presledka
- če vpišemo daljši string, kot smo alocirali prostora, nam bo C še vedno pustil, ker bomo pisali po delu heapa, ki je del našega programa, če tudi nismo alocirali tega dela heapa; lahko prepišemo stvari, ki so naprej na heapu, čeprav tist del ni res del stringa, ki ga hočemo s scanf prebrati
- zato ne uporabljaš scanf

gets:
- stack smashing = na stack pišemo več kot nam je dovoljeno
- na stack damo med vrednosti, ki jih želimo uporabiti, "kanarčke" (8 bytov številka)
- ko prepišemo kanarčka, proces vidi, da je kanarček mrtev (tista številka ni taka kot bi morala biti) in se ubije
- lahko preskočiš kanarčka oz. ga prepišeš z isto vrednostjo in proces ne bo opazil, da si pisal tam
- ![400](../../Images3/Pasted%20image%2020250227095436.png)
- če preskočimo kanarčka, lahko pišemo po return addressu in skočimo v neko funkcijo, za katero nismo avtorizirani

fgets:
- če vpišemo predolg string, ga odreže