- rasterizacija in prekrivanje = polnjenje trikotnikov z interpolacijo

### Podatkovne strukture

Grafične aplikacije:
- ne samo kako nekaj narisati na enkran, ampak veliko objektov, ki so vezani na to, kako je narejena animacija, kakšna muzika se predvaja
- uporabljamo grafične pogono (game engines):
	- nam dajo orodja za hitrejši razvoj
	- dela memory management za veliko količino objektov - kdaj bodo kateri prikazani na ekranu

Scene graph:
- imamo veliko objektov v sceni, ohranja samo tiste objekte, ki so lahko izrisani na ekranu
- z znanjem do sedaj bi vsak izmed predmetov postavili v svet s transformacijo KS posameznega modela - za vsak objekt posebej rabimo svoj KS (svojo matriko) s katero bomo množili nek predmet da ga postavimo v prostor
- če premaknemo samo mizo, se bo premaknila samo miza, ne pa tudi objekti na njej
- povemo kako so objekti povezani med sabo - hierarhičen pogled na svet
- ![400](../../Images2/Pasted%20image%2020241211104358.png)
- če premaknemo nek predmet, se mora premakniti tudi vsi, kar je na grafu pod njim
- naredimo več razredov:
	- vsi razredi so iz razreda Node
	- Group - skupina Node-ov
	- transformGroup - dela s transformacijami
	- leaf - lahko vključuje luč ali podatke o 3D objektu (mesh, normale, tekstures)
- ![400](../../Images2/Pasted%20image%2020241211104636.png)
- M1 nam pove, kje na mizi se nahaja roža
- namesto da pišemo svojo matriko za vsak objekt, se sprehodimo od začetka proti objektu in vmes množimo matrike
- če spremenimo M0, bo imeli to vpliv na vse pod njim - se premakne miza in vse na njej
- pomaga pri risanju osebkov:
	- osebek opišemo kot skelet, imamo neke točke okrog katerih se okončine lahko vrtijo

Skeletne figure:
- imamo spet hierarhije skeletov
- različne aktivnosti zahtevajo različen pogled na hierarhije - primer robot flying vs swinging
- drugi nameni hierarhij:
	- optimizacija prostora v pomnilniku
	- do listov lahko pridemo po več poteh - npr. pri mizi imamo 4 noge, samo enkrat potrebujemo lokacije oglišč v KS modela, ampak vsaka noga ima svojo transformacijo - gremo po vseh možnih poteh do lista
	- ![300](../../Images2/Pasted%20image%2020241211112944.png)

- axis aligned bounding box - kocke, ki opisujejo volumen predmeta, so poravnane s KS kamere
- bounding box spheres - sfera iz središča objekta, ki zajema celoten objekt:
	- hitro lahko ugotovimo kateri predmeti ne bodo vidni, jih lahko vržemo stran
	- predstavimo grupo in kar je izven bounding boxa sploh ne pošljemo v cevovod

- v scene graphu imamo metrike, da glede na oddaljenost predmeta izbiramo med različnimi nivoji natančnosti prikaza - ko je predmet daleč, pošljemo malo poligonov, ker bo porabilo par pikslov na zaslonu, ko je predmet blizu ga prikažemo z več poligoni

Backface colouring:
- v cevovod pošljemo samo predmete, ki so v vidnem polju kamere

Megatexturing:
- povežemo eno veliko high quality teksturo in naložimo samo tist njen del, ki je viden na zaslonu

Z-buffer:
- tisto kar je za nekim objektom, ne vidimo

- osmiška drevesa - naredijo bounding box iz manjših bounding boxov

### Teksture

- prej smo samo povedali oglišča in barvo + normalo, notranjost pa se poračuna z interpolacijo barv ali normal
- danes - s teksturami lahko pri nizki ločljivosti oglišč podtaknemo teksutro, s katero povemo podrobnosti o ogliščih in potem geometry shader doda oglišča - prednost programirljivih cevovodov z geometry shaderjem
- v osnovi so teksture nastale za dodajanje barvnih podrobnosti na površino predmetov
- polje vrednosti rgba
- najbolj optimalno 64x64, 128x128 ..., danes lahko tudi drugačne dimenzije
- ko jih enkrat damo grafični kartici opisujemo v KS tekstur, ker je naslednja faza lepljenje tekstur - povemo, kako bomo to teksturo lepili na predmete (trikotnike), ik jih pošiljamo skozi geometrijo
- prej smo geometrijo opisovali samo s koordinatami 3D predmeta, zdaj imamo še podatke o koordinatah v KS teksture

KS teksture:
- koordinate (0,0) do (1,1), ne glede na to koliko pikslov je njena ločjivost
- ![200](../../Images2/Pasted%20image%2020241211114700.png)
- texsel - pretvarja med KS strukture in piksli, ki predstavljajo naš objekt

- t_0 = točka v KS teksture
- ![350](../../Images2/Pasted%20image%2020241211114838.png)
- problem - lahko gledamo na objekt od blizu ali daleč - lahko vidimo en piskel teksture čez cel zaslon ali pa ogromno pikslov teksture v enem pikslu na zaslonu

Lepljenje tekstur:
- ravninsko:
	- predmet poravnamo s KS teksture in potem prilepimo teksturo kot bi jo projecirali na objekt
	- če se premikamo po z, je barva konstantna
	- način na katerega izračunamo koordinate u in v - vzamemo x in y koordinate predmeta, jih normaliziramo na KS teksture, da je med najbolj ekstremnimi točkami
	- normaliziramo na vrednosti med 0 (min) in 1 (max) - $\frac{x - min}{max - min}$
- sferično:
	- okoli predmeta ovijemo sfero in to sfero skrčimo na naš predmet
	- naredimo prehod iz x, y, z (kartezičnega KS) v sferični koordinatni sistem - pove rotacijo okoli osi x in y ter oddaljenost od izhodišča
	- normaliziramo kota med 0 in 1
- cilindrično:
	- ohranimo vertikalo kot kartezično vrednost in se samo vrtimo okoli osi
- prostorsko lepljenje tekstur:
	- modeliramo okolje oz. 