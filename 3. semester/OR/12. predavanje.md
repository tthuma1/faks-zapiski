- časovniki - ko pridejo do konca se sproži prekinitveno servisni program (ISR), da ne rabimo porabljati procesorja da čaka na konec časovnika

- novejši prediktorji:
	- "loop counter":
		- če imamo neko zanko, ki se npr. 32-krat ponovi, si loop counter to zapomni in potem vsako 32-to predikcijo obrne
		- števec, ki šteje periodo zanke (kolikokrat se zanka zavrti)
		- če imamo kratko zanko, se ne splača, da gremo operande vedno na novo brati iz pomnilnika, zato jih obdrži kar na skladu
	- vrnitveni prediktor (sklad):
		- da vemo skočni naslov iz podprograma, pogledamo na sklad
		- povratni naslovi so znani, je samo navaden sklad
	- nevronske mreže (MLP):
		- počasno, da izračunamo uteži
		- percepton (AMD) - izračunaš uteži za vhode (zgodovino), dobiš vsoto in potem imaš funkcijo, ki glede na to vrednost pove, ali je pogoj izpolnjen ali ne
		- nadzorovano učenje - modelu povemo, kaj je prav
		- operacija množenja ni tako enostavna za računalnik
		- ![400](../../Images2/Pasted%20image%2020241217121227.png)
		- predikcija se izračuna glede na zgodovino in perceptone - perceptoni so odvisni od naslova
	- korelacijski:
		- G-SHARE
		- kombinira lokalno in globalno
		- namesto da gledamo samo branch address, gleda še zgodovino (10 zadnjih bitov naslova + 10 zadnjih pogojev), nad tem naredi XOR, da se razprši
		- ![500](../../Images2/Pasted%20image%2020241217115223.png)
		- ![300](../../Images2/Pasted%20image%2020241217115320.png)
	- hibridni:
		- rabi malo več časa, ampak je boljši
		- imamo več prediktorjev od najbolj zanesljivega do najmanj zanesljivega
		- spet izračunamo hash iz zgodovine in naslova
		- TAGE - poleg globalnega in lokalnega prediktorja, primerja še po različnih dolžinah globalne zgodovine - predikcija po daljši zgodovini je boljša
- če je prediktor bolj enostaven bo hitrejši, ampak manj zanesljiv - lahko jih zložimo enega za drugim - najprej napove hiter, če potem počasnejši napove drugače, se cevovod pobriše, ampak je še vedno nižja cena, kot če se še počasnejši zmoti
- prediktorji niso vezani na procese:
	- ko pride do context switch se logika procesa zamenja in prediktorji rabijo nekaj napačnih napovedi, preden se naučijo za novi proces
	- prediktorji odvisni od procesa, različni prediktorji vključeni odvisno od procesa, ki teče

Skočni naslovi:
- če napovemo, da bo pogoj resničen, rabimo tudi skočni naslov imeti čim prej na voljo
- hkrati z ugotavljanjem pogoja ugotavljamo tudi skočni naslov
- zadnje skočne naslove shranjujemo v poseben predpomnilnik za skočne ukaze - branch target buffer (BTB):
	- to je asociativni pomnilnik - imamo en del, kjer hitro išče in pomnilniški del
	- v asociativnem delu najdemo neko vrstico
	- asociativni pomnilnik je HW rešitev, ki nam omogoča, da iščemo po vsebini, ne samo po ključu; imamo primerjalnike, ki primerjajo vhod z vsebino; uporabno pri iskanju blokov, kateri najvišji biti se ujemajo, v pomnilniškem naslovu imamo del za blok in offset znotraj bloka
	- v asociativni del damo naslov branch ukaza
	- v pomnilniškem delu imamo skočni naslov
	- ko pridemo naslednjič do istega brancha, dobimo njegov skočni naslov iz bufferja
	- če najdemo naslov v tem bufferju, je to tudi napoved za skok (pogoj bo izpolnjen) - preprosta 1-bitna tabela
	- lahko damo zraven še prediktorske bite (zadnje globalne rezultate)
	- če pogoj ni izpolnjen, sprosti tisti del predpomnilnika
	- vsebina:
		- zadnji skočni naslovi skokov z izpolnjenim pogojem (če pogoj ni izpolnjen, si ne rabimo nič hraniti, ker je itak PC=PC+1)
	- CAM pomnilnik - naslovljiv z vsebino, ne z naslovom, iščemo čim daljše ujemanje
- IF (prevzem ukaza):
	- vmes še dostop do BTB, tudi če ni branch naslov, ker nič ne izgubimo s tem
	- če je zadetek:
		- v PC daj skočni naslov (smatraš, da je to branch ukaz in da je predikcija true)
	- če je zgrešitev:
		- statična predikcija neizpolnjenega pogoja (smatraš, da je predikcija false)
	- vrne naslov in predikcijske bite in se zduži z napovedjo pogoja
- v sodobnih CPE:
	- "enota za prevzem ukazov" (IF):
		- predpomnilnik:
			- branje ukazov
			- zgrešitve (zamenjave blokov)
		- skočna predikcija
		- za več ukazov hkrati
	- ![500](../../Images2/Pasted%20image%2020241217123511.png)

### Večperiodne operacije

- različne kompleksnosti operacij (npr. množenje vs seštevanje)
- cilj ena perioda za vse operacije:
	- ne sme biti predolga
	- ne sme dodati preveč dodatne logike
- kompromis:
	- večina operacij v 1 $t_{CPE}$
	- kompleksnejše operacije več $t_{CPE}$
- problem pri funkcijskih enotah (FE znotraj ALE)
- specializirane FE za npr. floating point
- izzivi večperiodnih FE:
	- dodatne strukturne nevarnosti, ker so nekatere naprave več period nedosegljive
	- če vse enote naenkrat končajo, pride veliko stvari naenkrat v MA - MA tega ne more vsega naenkrat shandlat, ima manjšo dimenzijo
	- več podatkovnih nevarnosti (en ukaz mora počakati drugega)
	- ![400](../../Images2/Pasted%20image%2020241217124211.png)
	- ko je neka funkcijska enota zasedena, ne sprejema novih vhodov
- poleg cevovodne različice CPE, razdelimo tudi FE na cevovod - cevovodna realizacija FE:
	- operacija se še vedno enako časa izvaja
	- če se bi želeli prilagoditi najpočasnejši enoti, bi morali zelo povečati urino periodo in bi bilo vse počasi - tako urina perioda ostane enaka
	- vsako urino periodo lahko lahko enota sprejme nov vhodni operand - rešimo strukturne nevarnosti
	- ![500](../../Images2/Pasted%20image%2020250107103242.png)
	- + zmanjšamo strukturne nevarnosti, ker se neka FE lahko hitreje sprosti
	- - podatkovne nevarnosti so večje:
		- več ukazov v izvajanju (lahko pride več ukazov naenkrat v MA in WB)
		- ni premoščanja med posameznimi FE, ker bi preveč zakompliciralo zadevo (zato mora npr. seštevanje najprej do konca počakati množenje)
	- primer:
		- ![500](../../Images2/Pasted%20image%2020241217124857.png)
		- od 17 period izvedbe je 10 period ko nekdo čaka

- rešitve:
	- razvrščanje ukazov (ali programer ali prevajalnik)

Dinamično razvrščanje ukazov:
- podobno kot lahko programer razvršča ukaze, to lahko dela tudi prevajalnik z optimizacijami, tu pa CPE razvršča ukaze
- ![300](../../Images2/Pasted%20image%2020241217125017.png)
- IDIV se bi lahko prej izvedel, ker je neodvisen od prejšnjih + deljenje je itak najbolj počasna operacija
- način delovanja CPE, kjer se lahko spremeni vrstni red izvedbe ukazov s ciljem zmanjšanja števila čakalnih period
- Tamalusov algoritem
- ![600](../../Images2/Pasted%20image%2020241217125740.png)
- želimo narediti FE čim bolj zaposlene, da je čim manj čakalnih ciklov
- ID stopnja se razdeli na dva dela:
	- 1. izstavitev ukaza:
		- dekodiranje
		- preverjanje strukturnih nevarnosti:
			- "čakalne vrste" pred FE, kamor dajamo ukaze, ki so namenjene tej FE
			- če je rezervacijska postaja prazna, gre ukaz noter v FE
		- se dogaja "in-order" - enak vrstni red, kot smo ukaze brali iz pomnilnika
	- 2. branje operandov:
		- preverja podatkovne nevarnosti
		- ko jih ni več, se ukaz izvede
		- deluje "out-of-order" - na koncu vse rezultate upoštevamo v pravilnim vrstnem redu, vmes pa niso nujno v pravem redu
		- npr. ko se množenje zaključi, seštevanje neha čakati, ker je dobilo manjkajoči operand in gre v izvedbo
- EX izvršitev ukaza
- WB:
	- shranitev rezultatov v registre in glavni pomnilnik
	- poteka "in-order"
- ko pridejo rezultati iz FE, imamo povratne zanke v rezervacijske postaje, da tisti ukazi, ki čakajo zaradi podatkovnih nevarnosti dobijo pravilne operande in se lahko izvedejo
- + poveča hitrost - bolj izkoriščene FE, manj čakanja
- + učinkovit tudi pri zgrešitvah v predpomnilniku - če pride do zgrešitve, še vedno lahko nadaljuje
- - kontrolne nevarnosti ostanejo (kontrolne nevarnosti so že tako največji problem):
	- problem zgrešitev v PP, izgubimo 10 ciklov za zgrešitev na prvem nivoju
	- ne moremo realizirati predikcije, ker ne moremo ustaviti ukazov, ko jih enkrat spustimo v cevovod; ni mehanizma za razveljavitev ukazov