- paralelizem na nivoju ukazov ima svoje omejitve - v praksi dobimo drugačne rezultate od idealnih (izračunanih)
- imamo programe, ki so bolj primerni za te mehanizme in manj primerne (imajo veliko naključnosti)
- večnitnost - program moramo spremeniti (prej je bil cevovod tak, da nismo rabili nič spreminjati):
	- določeni resursi ostanejo skupni
	- če gre ena nit v zgrešitev, se druga nit lahko nadaljuje
	- nit je lahko ali kompletno drugi program, ali pa mi razdelimo en program na več delov
- ![400](../../Images2/Pasted%20image%2020250114102956.png)
- če frekvenco povečamo, bo preveč toplote
- za več CPE ni bilo programov
- daljši cevovod - več stopenj ne pomeni nujno hitrejši izvedbe (max 10 do 20 stopenj)
- večnitnost - pridobimo okoli 30% več zmogljivost in povečamo izkoriščenost jedra

### Paralelizem na nivoju niti
Nit (thread):
- zaporedje ukazov, ki se izvršuje neodvisno
- je lahko del programa (npr. spletni strežni, za vsakega klienta svoja nit) ali samostojen program (bolj redek problem)
- ni več transparentna - program je treba ustrezno spremeniti
- HW podpora:
	- skupni resursi (FE, predpomn, registri) - manj dodatne logike za njihovo delovanje
	- ločeni resurski (reorder buffer, retirement unit (enota za zaključitev ukazov), fetch), tiste stvari, ki je smiselno, da so ločene, jih ločimo

Načini realizacije večnitnosti:
- drobnozrnati pristop (fine grain):
	- hitro preklapljamo med nitmi (vsako periodo)
	- ko nit preklapljamo, rabimo veliko stanja niti shraniti, zato to ni najbolje
	- - zapletena implementacija
	- najbrž se bolj splača pustiti nit, da dela dalj časa
	- idealno bi bilo n-stopenj cevovoda in n niti, da bi bila potem vsaka stopnja neodvisna med sabo (redko v praksi, ker ponavadi želimo, da se en program hitro izvede, ne skupek programov)
- grobozrnata:
	- preklopi redkejši
	- + enostavna implementacija
	- + boljše za manjše število niti (kar je tipična situacija)
	- - več izgub ciklov, ker pustimo niti malo dlje, ne glede na to, če čaka na nekaj
	- se deli na različne izvedbe, nekatere hitreje preklapljajo, nekatere pa počasneje

- niti ne dajamo v rotacijo, če nima nič za delati

- lahko izvajamo več ukazov za različne niti naenkrat:
	- za večizstavitvene CPE
	- AMD SMT
	- Intel HyperThreading
	- hkrati se lahko izvajajo ukazi iz različnih niti - še večja izkoriščenost
	- primer Intel:
		- ![600](../../Images2/Pasted%20image%2020250114105049.png)
		- nekateri viri so skupni, nekateri pa ne

- včasih imamo dve niti, ki hočeta velik del procesorja - se malo stepeta in bi bolje imeti več jeder
- boljše razmerje med pridobljeno hitrostjo in energijsko učinkovitostjo
- manj porabe virov, kot je dejanska pohitritev

CISC:
- iz C programskega jezika pretvorimo v CISC assembly in CPE pretvori v mikroukaze
RISC:
- iz C prevajamo direktno v enostavne RISC-like ukaze

- ukazno pretokovno računanje - ukazi določajo kaj se bo zgodilo in potem CPE direktno to dela
- če ves čas izvajamo neko enostavno operacijo (npr. multiply accumulate pri digitalnem procesiranju signalov (konvolucija)) - kaj če bi celo strukturo CPE prilagodili temu ukazu (HW izvedba):
	- ![150](../../Images2/Pasted%20image%2020250114105820.png)
	- podatkovno pretokovni računalniki - prilagodimo zgradbo podatkom

Maxeler podjetje:
- iz Jave prevede v FPGA (programirljivo vezje, ki ga sestavimo iz nekih gradnikov)
- CPE so bolj učinkoviti če so direktno na siliciju, pri FPGA je nek kompromis, da je lažje za izdelavo
