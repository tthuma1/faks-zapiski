Mikroprogramske KE vs trdoožičena KE:
- mikroprogramska:
	- + fleksibilnost - z lahkoto dodamo nove mikroukaze, hitro za razvoj; lahko imamo različne zbirnike za isto elektroniko in potem deluje kot drug računalnik (lahko imamo eno organizacijo in več arhitektur)
	- možnost realizacija različnih arhitektur
- trdoožičena:
	- + hitrejša
	- - kompleksnejša (potrebnih več logičnih vezij)

- včasih je bil CISC bolj smiselen, ker je bilo branje iz pomnilnika počasno in smo želeli čim več stvari narediti z enim branjem
- primer manj varnosti za več hitrosti: če lahko beremo nek del RAM-a samo, če imamo neke pravice, lahko najprej preberemo RAM in vmes gledamo ali imamo pravice, namesto da bi najprej preverili pravice in potem brali RAM
- pri cevovodni izvedbi rabimo ukaze razdeliti na mikrooperacije

Trdoožičena KE:
- vsak ukaz razdelimo na tri elementarne korake:
	- ![350](../../Images2/Pasted%20image%2020241126104006.png)
	- vsak strojni ukaz rabi enako število elementarnih korakov
- če je elementarni korak 0, je IRLOAD=1:
	- ![400](../../Images2/Pasted%20image%2020241126104100.png)
- immed load:
	- če je irbit7=1, pomeni da imamo 16-bitni ukaz, ki ima takojšnji operand
- pc load:
	- imamo pogojni in brezpogojni skok, da povečamo PC po izvedbi ukaza
	- b7=1 pomeni, da je skok, sicer ga ni
	- ![600](../../Images2/Pasted%20image%2020241126104936.png)

- V/I so pri trdoožičeni KE enaki, izhodne kontrolne signale pa generiramo z logičnimi vezji

- ko imajo vsi ukazi enako število korakov, lahko naredimo cevovodno različico - branje do ukaza, dekodiranje ukaza, execute, dostop do pomnilnika in write back v registrsko enoto:
	- sem ne moremo dati bolj kompleksnih ukazov (npr. jnez), ker sta to v bistvu dva ukaza (najprej preveri zastavico in potem jump), zato take ukaze pretvorimo v več ukazov
	- kompleksne ukaze damo ven in obdržimo enostavne ukaze, ki lahko naredijo isto kot kompleksni ukazi, ko jih damo skupaj
	- lahko izvajamo 5 ukazov, vsak v svoji stopnji