Izčrpno preiskovanje:
- podvrsta grobe sila, včasih rečemo da je isto
- bruto force po definiciji napada problem
- izčrpno preiskovanje je za optimizacijske probleme, kjer iz vseh možnih rešitev iščemo optimalno
- reševanje kombinatoričnih problemov
- primer: par najbližjih točk:
	- n^2 vseh parov
	- časovna zahtevnost O(n^2)
- primer: največji podseznam
	- pogledaš vse možne podsezname - izberemo vse pare indeksov `i` in `j` med katerima naredimo vsoto elementov in pogledamo, če je to največja vsota do sedaj
	- izčrpno preiskovanje nam da O(n^3)
```
for i
	for j
		for k in range[i, j]
```
- primer: trgovski potnik
	- št. zaporedij n! => O(n!)

Sestopanje:
- najprej gremo po eni poti, če se ne izide, naredimo backtrack (sestopanje) in gremo po drugi poti
- drevo prostora stanj:
	- ![400](../../Images2/Pasted%20image%2020241119135845.png)
	- sestopanje delamo s skladom

- razanje (prunning drevesa):
	- upoštevamo le dopustne izbire, da ne rabimo dejansko celega drevesa pregledati
	- želimo odrezati čim večji del drevesa
- primer labirint:
	- če ima npr. drevo branching factor (faktor vejitve) 4, in globino n, bomo imeli $4\cdot4\cdot ...$ = 4^n možnih poti
	- pri podani nalogi imamo povsod v bistvu samo 2 branching factor
- primer kraljice na šahovnici:
	- prvo kraljico postavimo zgoraj levo in potem za naslednjo vrstico postavimo, če se napadata, naredimo backtrack
	- lahko generiramo vse možne rešitve ali samo prvo rešitev

- generiranje podmnožic:
```
// s = delna resitev
// k = indeks
def gen_subsets(list, s, k):
	if(k == n):
		print(s) // imamo celo resitev
		return
	// ali dodamo k-ti element ali ne
	gen_subsets(list, s, k + 1)
	gen_subsets(list, s + list[k], k + 1)

gen_subsets(list, [], 0)
```
- da generiramo kombinacije, damo na začetek if, da preverimo, ali smo že prišli do te rešitve

- permutacije:
	- na začetek damo k-ti element (k gre od 0 do n-1) in rekurzivno naredimo permutacijo preostalega dela
	- ko pridemo ven iz rekurzije, moramo popraviti seznam nazaj
```
def gem_perms(list, k):
	n = len(list)
	if k == n - 1:
		print(list)
		return

	for i in range(k, n):
		swap(list, k, i)
		gen_perms(list, k + 1)
		swap(list, k, i)
```