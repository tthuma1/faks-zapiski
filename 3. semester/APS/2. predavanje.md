Preverjanje pravilnosti:
- testni primeri:
	- pripravimo vhode in pravilne izhode
	- unit testi
	- lahko naredimo veliko testov, ampak s tem nismo dokazali da naš algoritem pravilno deluje, ker ponavadi ne moremo pokriti vseh možnih vhodov
	- to ni popolno testiranje
	- lažje je pokazati nepravilnost delovanja kot pravilnost
- kaj delamo ko testiramo algoritem?
	- znanstvena metoda - lahko stvari preverimo, testiramo, če dobimo isti rezultat kot tisti, ki je nekaj naredil
	- več eksperimentov (unit testov) kot naredimo, bolj verjamemo, da je hipoteza (da je naš algoritem pravilen) pravilna - ponavadi ne moremo 100% dokazati, da neka hipoteza drži
- formalni dokaz:
	- treba matematično izpeljati, prek lastnosti algoritma pridemo iz lastnosti vhodov do lastnosti izhodov

Sled algoritma (trace):
- algoritem izvajamo na papir ali računalnik in sproti izpisujemo pomembne podatke, kako se spreminjajo tekom delovanja

## Analiza algoritmov

- koliko časa porabimo, da dobimo rezultat
- kako pridemo do nekega rezultata v najkrajšem možnem času
- na kakšen načinu napišemo algoritem, da bo porabil najmanj časa

Viri algoritma:
- analiza algoritmov odgovarja na dve vprašanji:
	- katere vire rabimo za izvajanje algoritma
- kaj so sploh možni viri: čas in prostor
- čas: realni čas, procesorski čas, število operacij (primerjav, dostopov do pomnilnika, ...)
- prostor: poraba pomnilnika (št. celic, bytov)
- energija: poraba električne energije (npr. damo merilec v vtičnico, vemo da je poraba GPU večja in to upoštevamo, ...)
- komunikacija: v porazdeljenih sistemih - pasovna širina, št. paketov
- koliko vira potrebujemo za izvajanje algoritma

- katere in koliko virov potrebuje algoritem za izvajanje v nekem modelu računanja
- model računanja: abstrakten procesor, ki nudi osnovne operacije (plus minus krat...), ene stanejo več kot druge (množenje je dražje kot seštevanje) - štejemo koliko določenih operacij se zgodi
- v realnosti nas zanimajo samo nekatere operacije, ostale pa zanemarimo (rečemo, da je njihova cena 0) - to bo naš model računanja
- v našem modelu računanja bomo veliko stvari zanemarili

Od česa je odvisna zahtevnost algoritma:
- od algoritma samega
- algoritme =skoraj= implementacija
- od modela računanja (odvisno katere operacije zanemarimo), x86 in ARM imata različne ukaze
- od naloge, ki jo podamo (od vhodnih podatkov):
	- velikost naloge: npr. v bitih
	- 