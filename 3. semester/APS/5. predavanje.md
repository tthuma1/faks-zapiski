Povezani seznami v polju:
- če je dinamična alokacij težavna (malo pomnilnika) - IoT
- mogoče sta malloc in free prepočasna
- polja imajo indekse namesto kazalcev, ampak oboje kaže na neko lokacijo v pomnilniku
- indeksi kot kazalci
- rabimo hraniti in elemente in kazalec na naslednji element
- dve polji: eno hrani elemente, drugo pa pove, kdo je naslednik od i-tega elementa
- namesto null kazalca imamo -1
- povedati moramo, kje v polju se nahaja prvi element

- pri seznam lahko dodajanje na začetku in lahko odvzemanje na začetku
- pop: `i = first; first = next[first]; free(i)`
- push: recimo da dodamo na indeks 4 (imamo podan indeks neke prazne celice):
```
item[4] = x;
next[4] = first;
first = 4;
```
- allocate() vrne indeks proste celice
- ob pop rabimo naši podatkovni strukturi povedati, da je celica zdaj prosta
- kako najdem prosto celico:
	1. sprehod od začetka do konca, prazna celica ima lahko neko posebno vrednost - O(n)
	2. pri praznih celicah je tudi `next` zaenkrat prazen - lahko prazne celica povežemo v še en seznam:
		- `free = 4;` - free je kazalec na prvi prosti element
		- dva povezana seznama v enem polju - en povezuje zasedene celice, drugi pa proste celice
		- dobivanje proste celice: allocate je pop operacija na seznamu prostih
		- free(i) je push na seznamu prostih
- prazen seznam:
	- `first = -1`, `free = 0`
- da naredimo dvakrat večjo tabelo:
	- rezerviramo dvakrat večjo tabelo, kopiramo stari seznam v prvo polovico seznama in drugo polovico dodaš v seznam prostih

Persistenca:
- hranjenje zgodovine sprememb
- $l$ je seznam, x je nov Node
- samo s hranjenjem prvega elementa smo si zapomnili cel seznam, hkrati pa vidimo kakšno je bilo stanje seznama na neki točki
- za funkcijkse programske jezike
- vse spremenljivke si delijo pomnilnik (seznam b je del seznama c)
- če spremenimo en item (`b.item = "novo"`), se bo vse, kar je vezano na to spremenilo, ker je deljeno v pomnilniku - funkcijski jeziki zato ne omogočajo spreminjanja