
Predstavitev dreves:
```
class TreeNode {
	item : any
	left, right : TreeNode
}
```

d-tiško drevo:
```
class TreeNode {
	item : Obj
	childs: [TreeNode] (dolžine d)
}
```
- `childs` je kazalec na seznam kazalec (referenca na seznam referenc)

- da imamo spremenljivo število otrok - za `childs` uporabimo povezani seznam
```
class TreeNode {
	item : Obj
	firstChild : ChildNode
}

class ChildNode {
	child : TreeNode
	next : ChildNode (kazalec na naslednji sibling)
}
```
- predstavitev s povezanim seznam je uporabna, če imamo redka drevesa (d je velik, ampak po večini ni vseh otrok)

3)
```
class TreeNode {
	item : Obj
	firstChild : TreeNode
	nextSibling : TreeNod
}
```
- `firstChild` pomeni naslednji nivo, `nextSibling` pomeni isti nivo

Eksplicitna predstavitev dvojiškega drevesa v polju:
- imamo polja `left`, `right` in `items` in na i-tem mestu hranimo indeks levega in indeks desnega potomva

Implicitna predstavitev:
- položaj otrok in staršev vemo glede na položaj i-tega elementa v pomnilniku
- imamo neko implicitno funkcijo, ki nam pove odnos med elementi
- zelo všeč nam bodo celovita drevesa, se bomo trudili, da so naša drevesa uravnotežena
- globina celovitega drevesa: `lg(n)`

### Kopica (heap)

- garbage collector rezervira podatke na kopici

Vrsta s prednostjo:
- poleg vrednosti elementa `x`, dodamo še prioriteto `p`
- prioriteta je lahko del elementa
- če imamo array elementov, si shranimo last index, dequeue je da se sprehodimo po celem array in poiščemo tistega, ki ima največji priority, enqueue je samo vnos na last+1:
	- lahko sortiramo seznam in potem dequeue samo vzame prvi element, enqueue pa poišče prvi element, ki ima manjšo prioriteto in vrine pred njim
	- noben od teh načinov nam ni všeč, ker je pri obeh ena operacija O(1), druga pa O(n)

- kopica je celovito dvojiško drevo