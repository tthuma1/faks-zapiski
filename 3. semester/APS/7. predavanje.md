- koren je element z največjo prioriteto (je min ali max, odvisno od vrste kopice)
- za remove naredimo `siftDown`

```
// indeks last je zadnji indeks v polju
// items je polje
fun siftDown(p): // p je indeks elementa, ki ga moramo sift downat
	c = 2*p + 1 // levi otrok
	while c <= last:
		if c+1 <= last && items[c+1] > items[c]: // desni obstaja in je večji od levega
			c = c+1
		// sedaj c hrani indeks večjega otroka
		if items[p] >= items[c]:
			break // imamo že max-heap
		swap(items, c, p)
		p = c
		c = 2*p + 1
```

- največ `h`-krat bomo premaknili element dol (element leze dol, bomo imeli največ `h` zamenjav) => O(logn)
- c se povečuje krat dva po vsaki iteraciji zanke, torej se bo log(n)-krat pomnožilo preden pridemo do konca

Odstranjevanje iz kopice:
- najlažje je odstraniti `last` element
- če želimo odstraniti koren, moramo potem narediti še siftDown
```
fun dequeue():
	x = a[0]
	swap(items, 0, last)
	last -= 1
	siftDown(0)
	return x
```

- časovna zahtevnost: O(logn):
	- vse je O(1), razen siftDown je O(logn), torej je vse O(logn)

- vrsta s prioriteto = abstraktna podatkovna struktura
- kopica = implementacija vrste s prioriteto
- 