Polje kot zaporedje (sequence):
- da dobimo i-ti element polja - rabimo vedeti začetni naslov in potem + i \* velikost elementa
- za insert rabiš najprej vse elemente premakniti za eno desno, da ne overwritamo vrednosti
- pri delete samo prestavimo vse elemente za eno v levo do tistega, ki ga želimo deltati
- find, delete, insert so O(n)

Polje kot vreča in množica:
- podobno kot sklad
- pri množici pazimo še na duplikate
- addUnique je O(n + n) = O(n)
- remove je O(n)

Karakteristični bitni vektor:
- npr. hranimo samo vrednosti od 0 do 9
- vrnemo true/false za vsak element
- števila so v omejenem intervalu
- lahko naredimo implementacijo po bitih:
```
fun add(x):
	items |= 1 << x;

fun find(x):
	return items & (1 << x);

fun remove(x):
	items &= ~(1 << x);
```
- operacije še vedno ostanejo O(1), ampak porabi manj prostora
- za vrečo bi namesto true/false hranili koliko ponovitev nekega elementa je noter

- s polji imamo hitre dostopa in lahko neke druge strukture še implementiramo

### Povezani seznam

- linked list, imamo kazalce
- referenčni tipi v Javi (Integer, String, array, ArrayList) si delijo stanje (se vedno prenašajo po referenci, ker so lahko veliki in bi bilo kopiranje drago)

Kazalec (pointer):
- hrani nek pomnilniški naslov
- da dobimo vrednost, moramo dereferencirati kazalec
- reference so podobno kot kazalci, ampak ne moremo delati pointer arithmetic; prijazni kazalci, ki avtomatsko dereferencirajo

Kazalčne podatkovne strukture:
- v bistvu bomo v Javi vse delali z referencami, ne kazalci
- imamo vozlišča (node), ki predstavljajo podstukture
- node-i so lahko različne podstrukture
- so dinamični, ker lahko poljubno dodajamo kazalce