- kako mikorkrmilnik ve, kje se začne naš program - pogledamo dokumentacijo, kje naj bi se začel prvi ukaz - imamo en branch, ki vedno na začetku skoči na ta naslov
- ideja, če imamo dva programa, ki se oba na začetku naložita na naslov 0\x20:
	- lahko pri drugem programu povečamo vse naslove za neko vrednost, da se ne prekrivata več - uporabimo indeksni register, s katerim offsetamo vse naslove
	- lahko napišemo nov program (OS), ki če imamo dva programa s konfliktnimi naslovi, naj pri enem programu inkrementira naslove, da se ne prekrivata več
- dva programa in eno jedro v CPE - programa se izmenjujeta (časovno multipleksiranje):
	- ko želimo skočiti iz prvega programa na drugega, moramo imeti nek skok na drugi program - pri tem se rabi prvi program zavedati drugega in obratno
	- lahko imamo prekinitve - notranji ali zunanji signal, ki povzroči, da se izvajanje v CPE prekine in skoči na nek naslov v pomnilniku, kjer se nahaja ISR - s tem preprečimo, da bi se en program usedel na CPE in ga ne bi spustil
	- imamo tretji program (OS), ki se zaveda vseh ostalih programov in izvaja skoke med njimi, poskuša čim bolj pravično razporediti čas izvajanja; skoke izvaja, ko pride do prekinitve v CPE
	- ^ upravljanje s pomnilnikom in razvrščanje procesov
- če imamo npr. dva temperarturna senzorja in vsak rabi svoj isti program - naredimo dve instanci istega procesa:
	- ko skačemo med procesi, želimo vedeti, na kateri del enega procesa moramo skočiti (kje smo bili nazadnje) - OS si mora zapomniti procesno sliko, kjer je končal prvi program (registri, PC ...), da jo potem lahko naloži nazaj, ko prvi proces spet dobi procesorski čas
	- ^ upravljanje s procesi
- če imamo npr. dva temperaturna senzorja od različnih proizvajalcev:
	- neka pomnilniška lokacija se uporablja kot mesto za komunikacijo z V/I napravami (registre V/I naprav prepišemo v glavni pomnilnik) - za vsako napravo bodo imele iste vrednosti lahko različen pomen če sta napravi od različnih proizvajalcev, imajo različne refresh rate-e
	- uporabimo gonilnik (driver), ki se ukvarja s komunikacijo s to napravo in mi ga uporabljamo samo na visokem nivoju , da ne rabimo samo pisati nizkonivojske kode za komunikacijo
	- namesto, da imamo gonilnik znotraj naše kode za uporabo senzorja, gonilnik premaknemo v OS in vedno, ko želimo komunicirati s senzorjem, uporabimo ta gonilnik v OS; nimamo posebej instance gonilnika za vsak program, ki uporablja senzor, ampak vsi uporabljajo isto instanco v OS
	- ^ upravljanje z V/I
- ne rabimo vedno OS:
	- npr. če imamo samo en program, ker OS porabi procesorski čas in pomnilnik
- za namizne računalnike je najpomembnejši del upravljanje z V/I napravami, ker je ogromno V/I naprav, ki jih lahko imamo