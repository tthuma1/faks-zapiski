Niti:
- bolj učinkovito izkoriščimo procesor z enim jedrom
- lahko sočasno razporedimo med več jedri
- če dodamo ogromno jeder, ne bo linearna pospešitev

- v jedro damo lahko minimalen nabor funkcij, ostalo pa izvedemo kot uporabniški programi (npr. Windows task manager)
- mikrojedro - minimalen nabor funkcij, ki jih rabi jedro

Proces vs. nit:
- razporejevalnik razporeja niti
- nit je osnovna enota razporejanja
- nit = lightweight proces
- kdo si lasti vire - proces (task) razervira vire za vse niti
- niti so last celotnega procesa

MS DOS:
- ena nit = en proces
- ima en program counter

Tradicionalni Unix:
- več procesov, ena nit na proces
- en program counter

Windows, Linux, Mach, Solaris, IBM-ov OS/2:
- poleg multiprogramiranja imamo tudi multinitenje
- več procesov, več niti na proces

JVM:
- Java RTE = en proces, več niti na proces (en velik proces od Jave)

Proces:
- enota alokacije pomnilnika in zaščite virov, ne kot enota razporejanja

Struktura niti:
- na PCB rabiš identitete za vsako nit - bolj smiselno je da naredimo posebej nadzprni blok vsake niti (Thread control block)
- rabimo imeti odlagalne sklade
- ![600](Pasted%20image%2020240318134545.png)
- vsaka izmed niti potrebuje svoj kontekst, svoj PCB
- še vedno rabimo kontekst celotnega procesa in user address space (preveden program + vhodni podatki)
- kernel stack je v shared address space-u (skupni viri vseh procesov)
- kako predstavimo niti znotraj procesne slike:
	- po procesu se je prej sprehajal en PC, sedaj ima poleg tega še vsaka nit še svoj PC

Prednosti niti:
- hitrost ustvarjanja:
	- hitreje, ker rabimo znotraj procesne slike, ki že obstaja narediti nove PC-je, te PC-ji postanejo del procesne slike, ki že obstajajo
	- 10-krat-ish hitrejše od ustvarjanja procesa
- hitrejše zaključevanje, ker je znotraj iste procesne slike
- preklopni čas:
	- za procese zamenjava konteksta (context switch)
	- če preklapljamo med niti istega procesa, ne rabimo vržti celega procesa iz procesorja
	- samo začnemo izvajati drug PC znotraj iste procesne slike
- deljenje virov in medsebojna komunikacija:
	- za komunikacijo med procesi se rabi vedno vpletati OS - časovno potratno
	- komunikacija med niti se ne rabi opirati na OS, ne rabi nobenih funkcij OS, ker lahko niti direktno med sabo komunicirajo
	- imamo sinhronizacija med nitmi, ki je veliko hitrejša, kot sinhronizacija med nitmi, ker se OS ne rabi vpletati

Primeri uporabe:
- Excel ... delovanje v ozadju:
	- imamo eno nit, ki prevarja ali je treba osvežiti program in eno nit, ki dela izračune, ko je treba
	- imamo sistem, ki je pripravljen na nov ukaz, še preden se je izvršil prejšnji
- Word ... in asinhrono procesiranje:
	- autosave - ena nit spremlja kaj pišemo, ena nit shranjuje kar naredimo

Stanja niti (nitni model stanj):
- ali so kakšna stanja še vedno upravljana na nivoju procesa?:
	- exit
	- blocked/suspend - če damo procesno sliko na sekundarni pomnilnik, smo morali dati vse niti tja
- katera stanja se vežejo na nit:
	- vseh ostalih 5 iz modela s sedmimi stanji

Primer učinkovitosti niti:
- RPC v Unix, LPC v Windows
- Remote procedure call za komunikacijo med dvema računalnikoma:
	- ![500](Pasted%20image%2020240318141945.png)
	- ^ proces čaka na odgovor od RPC, preden gre naprej
	- ![500](Pasted%20image%2020240318142002.png)
	- ^ medtem, ko ena nit čaka na odgovor od RPC, se druga nit izvaja
- učinkovitost se še bolj pozna, če imamo več procesov:
	- ![500](Pasted%20image%2020240318142152.png)

Načini izvajanja niti:
- pri procesih - mode switch (iz uporabniškega v jedrni nivo)
- izvajanje na uporabniškem nivoju (User level threat - ULT):
	- znotraj same aplikacije se naredi upravljanje z niti
	- OS ne ve za te niti, ker se z njimi dela na nivoju aplikacije
- izvajanje na sistemskih nivoju (Kernel level threads):
	- jedro združuje procesno sliko in njene niti
	- OS se niti zaveda, razporejanje je na nivoju OS
	- preslikava ena na ena
- kombinacija:
	- npr. na uporabniškem nivoju imamo tri, na jedrni nivo preslikamo samo dve niti
	- več sinhronizacije na uporabniškem nivoju?
	- ob pravilnem načrtovanju lahko združi pozitivne lastnosti obeh pristopov
	- Solaris do verzije 9

ULT:
- definirane na uporabniškem nivoju
- aplikacija razporeja niti znotraj edinega procesa (niti), ki obstaja na OS
- + ne delamo mode switch, pri razporejanju ne rabimo privilegijev, vse je na uporabniškem nivoju
- + sami lahko priredimo razporejanje
- + vsi OS niti ne podpirajo -> te aplikacije lahko tečejo na vsakem OS
- - ko dejansko pride do V/I zahteve, bo ta blokiral cel proces in vse niti z njo
- - če sistemski nivo vidi en proces z enim PC, če imamo dejansko na voljo več jeder, potem sočasno izvajanje ni mogoče, ker se lahko izvaja samo sistemska nit

KLT:
- preslikava ena na ena - vsaka nit postane nit na sistemskem nivoju
- - in + od ULT se zamenjajo
- + jedro lahko razporeja več niti istega procesa med več procesorjev
- + rutine jedra so lahko večjedrne
- + če je blokirana ena nit procesa, lahko zdaj jedro izvaja drugo nit istega procesa
- - ko delamo preklop na drugo nit istega procesa, to zahteva preklop v jedrni način (mode switch)
- danes pretehta KLT kot bolj uporaben, zato se to uporablja na vseh desktop OS (Windows, moderen Unix)

Kombinacija:
- npr. na uporabniškem nivoju imamo tri, na jedrni nivo preslikamo samo dve niti
- v specifičnih primer se bolje obnaša
- ![600](Pasted%20image%2020240318143342.png)
- v generalnem za desktop OS, razmerje med kompleksnostjo in pohitritvijo ni vreden

Aplikacije, ki jih potrebujemo:
- fork v Unix = pripravljenje procesne slike za nov proces
- null fork = isto, samo ne napolniš procesne slike
- signal wait - pošiljanje signala za čakanje za sinhronizacijo dveh procesov ali dveh niti

Primer ULT:
- ![](Pasted%20image%2020240318144044.png)
- b) čeprav je proces zaradi V/I zahteve blokiran, je nit še vedno v načinu izvajanja - cel proces je blokiran
- c) v izvajanje gre drug proces, proces gre v ready, niti v uporabniškem nivoju so še vedno v running (se nič ne zgodi, ker je ključne informacija na procesnem (sistemskem) nivoju)
- d) nit 2 gre iz running v blocked, nit 1 gre iz ready v running; na sistemskem nivoju procesor na zazna nič, ne rabi delati context switcha
- tudi ULT ima svoje prednosti, čeprav se v desktop OS ne uporablja

Razmerja med nitmi in procesi:
- ![500](Pasted%20image%2020240318144532.png)
- ![500](Pasted%20image%2020240318144710.png)
- ^ 1:M uporabno za cloud computing; nit se seli med procesi ali pa med posameznimi računalniškimi sistemi
- ^ M:N več niti se lahko menja med več procesi

- tradicionalni Unix - več procesov, ena nit na proces
- moderen Unix - več procesov, več niti na proces
- OS/2 je IBM-ov OS za desktop računalnike

---

Več jeder/več procesorjev:
- več jeder je ne enem čipu - so bližje skupaj, omogočajo hitrejše usklajevanje, hitrejša komunikacija med jedri kot med čipi
- več procesorjev = več čipov, rabimo jih povezati z vodilom (bus) - počasnejše usklajevanje
- pravo sočasno izvajanje

Učinkovitost večnitne aplikacije v večjedrnem procesorju:
- Gene Amdahl:
	- Amdahlov zakon (osnovne omejitve vzporednega izvajanja)
	- v IBM so razvijali glavne arhitekture - IBM 360, Amdahl je bil chief architect
- Grey research:
	- pionirji superračunalništva
- ![](Pasted%20image%2020240318150156.png)
- f = del, ki ga pospešimo (paraleliziramo)
- 1 - f = del, ki ga ne pospešimo
- večina problemov je takih, da ne moreš celega procesa paralelizirati, ampak lahko samo en del

Ali Amdahlov zakon zajema tudi rezporejanje in zagotavljanje skladnosti (koherentnosti) predpomnilnika (vsako jedro ima svoj L1 in L2 predpomnilnik, L3 predpomn. je skupen za vsa jedra)?
- ne
- ali lahko zanemarimo ta čas? Ne

- ![500](Pasted%20image%2020240318152630.png)
- ![500](Pasted%20image%2020240318152655.png)
- ^ imamo neko prelomno točko, ko je čas za razporejanje prevelik, zato je speedup manjši
- OS doda overhead za razporejanje procesov
- strojna oprema doda overhead za skladnost predpomnilnikov (če gre poces iz jedra 1 v jedro 2, je treba tudi podatke iz L1 od jedra 1 prenesti v L1 od jedra 2)

Realni primeri aplikacij, ki skoraj optimalno izkoriščajo več jeder:
- neodvisne zahteve, ki grejo do strežnikov
- specializirane podatkovne baze, ki omogočajo neodvisne zahteve do baze; imamo veliko vzporednih neodvisnih transakcij
- ![450](Pasted%20image%2020240318153339.png)

- ![500](Pasted%20image%2020240318153937.png)
- SIMD - grafične kartica (množenje matrik), blockchain pametne pogodbe in coin mining, umetna inteligenca (globoko učenje)
- MIMD - današnji procesorji
- master/slave:
	- tesno povezan naslovni prostor
	- tipična za nadzarovanje računalniškega sistema:
	- problem, če gospodar odpove, sužnji nimajo nič za delati
- lahko bi imeli enakovredne procesorje, ki prevzamejo breme od drugih procesorjev, ko te crknejo - to je SMP:
- clusterji (ohlapno povezan naslovni prostor) - en del računalnika je v eni stavbi, drug v drugi ...

SMP:
- ![500](Pasted%20image%2020240318154125.png)
- tightly coupled main memory
- vsi procesorji razporejajo procese zase
- problem skaldnost predpomn. rešujemo strojno

Mikrojedro:
- evolucija:
	1. monolitni OS - vse v jedrnem načinu
	2. plastni OS
	3. mikrojedrni OS - Mach, delno Windows (vse module ima izvedene izven jedra, ti komunicirajo z jedrom)
- zakaj je mikrojedro mikro:
	- je majhno
	- vsebuje le bistvene funkcije OS
	- vse storitve delujejo na podlagi predajanja sporočil (message passing)
- osnovne funkcionalnosti (predajanje sporočil (message passing)):
	1. preverjanje sporočil - najprej je treba preveriti, ali gre za avtentično sporočilo, ali ima prave pravice za to kar hoče
	2. predajanje sporočil
	3. dostop do strojne opreme
- + omogoča fleksibilnost in modularno nadgrajevanje

Monolitno jedro:
- 