Niti:
- bolj učinkovito izkoriščimo procesor z enim jedrom
- lahko sočasno razporedimo med več jedri
- če dodamo ogromno jeder, ne bo linearna pospešitev

- v jedro damo lahko minimalen nabor funkcij, ostalo pa izvedemo kot uporabniški programi (npr. Windows task manager)
- mikrojedro - minimalen nabor funkcij, ki jih rabi jedro

Proces vs. nit:
- razporejevalnik razporeja niti
- nit je osnovna enota razporejanja
- nit = lightweight proces
- kdo si lasti vire - proces (task) razervira vire za vse niti
- niti so last celotnega procesa

MS DOS:
- ena nit = en proces
- ima en program counter

Tradicionalni Unix:
- več procesov, ena nit na proces
- en program counter

Windows, Linux, Mach, Solaris:
- poleg multiprogramiranja imamo tudi multinitenje
- več procesov, več niti na proces

JVM:
- Java RTE = en proces, več niti na proces (en velik proces od Jave)

Proces:
- enota alokacije pomnilnika in zaščite virov, ne kot enota razporejanja

Struktura niti:
- na PCB rabiš identitete za vsako nit - bolj smiselno je da naredimo posebej nadzprni blok vsake niti (Thread control block)
- rabimo imeti odlagalne sklade
- ![600](Pasted%20image%2020240318134545.png)
- vsaka izmed niti potrebuje svoj kontekst, svoj PCB
- še vedno rabimo kontekst celotnega procesa in user address space (skupni viri vseh procesov, shared memory space)
- kako predstavimo niti znotraj procesne slike:
	- po procesu se je prej sprehajal en PC, sedaj ima poleg tega še vsaka nit še svoj PC

Prednosti niti:
- hitrost ustvarjanja:
	- hitreje, ker rabimo znotraj procesne slike, ki že obstaja narediti nove PC-je, te PC-ji postanejo del procesne slike, ki že obstajajo
	- 10-krat-ish hitrejše od ustvarjanja procesa
- hitrejše zaključevanje, ker je znotraj iste procesne slike
- preklopni čas:
	- za procese zamenjava konteksta (context switch)
	- če preklapljamo med niti istega procesa, ne rabimo vržti celega procesa iz procesorja
	- samo začnemo izvajati drug PC znotraj iste procesne slike
- deljenje virov in medsebojna komunikacija:
	- za komunikacijo med procesi se rabi vedno vpletati OS - časovno potratno
	- komunikacija med niti se ne rabi opirati na OS, ne rabi nobenih funkcij OS, ker lahko niti direktno med sabo komunicirajo
	- imamo sinhronizacija med nitmi, ki je veliko hitrejša, kot sinhronizacija med nitmi, ker se OS ne rabi vpletati

Primeri uporabe:
- Excel ... delovanje v ozadju:
	- imamo eno nit, ki prevarja ali je treba osvežiti program in eno nit, ki dela izračune, ko je treba
	- imamo sistem, ki je pripravljen na nov ukaz, še preden se je izvršil prejšnji
- Word ... in asinhrono procesiranje:
	- autosave - ena nit spremlja kaj pišemo, ena nit shranjuje kar naredimo

Stanja niti (nitni model stanj):
- ali so kakšna stanja še vedno upravljana na nivoju procesa?:
	- exit
	- blocked/suspend - če damo procesno sliko na sekundarni pomnilnik, smo morali dati vse niti tja
- katera stanja se vežejo na nit:
	- vseh ostalih 5 iz modela s sedmimi stanji

Primer učinkovitosti niti:
- RPC v Unix, LPC v Windows
- Remote procedure call za komunikacijo med dvema računalnikoma:
	- ![500](Pasted%20image%2020240318141945.png)
	- ^ proces čaka na odgovor od RPC, preden gre naprej
	- ![500](Pasted%20image%2020240318142002.png)
	- ^ medtem, ko ena nit čaka na odgovor od RPC, se druga nit izvaja
- učinkovitost se še bolj pozna, če imamo več procesov:
	- ![500](Pasted%20image%2020240318142152.png)

Načini izvajanja niti:
- pri procesih - mode switch (iz uporabniškega v jedrni nivo)
- izvajanje na uporabniškem nivoju (User level threat - ULT):
	- znotraj same aplikacije se naredi upravljanje z niti
	- OS ne ve za te niti, ker se z njimi dela na nivoju aplikacije
- izvajanje na sistemskih nivoju (Kernel level threads):
	- jedro združuje procesno sliko in njene niti
	- OS se niti zaveda, razporejanje je na nivoju OS
	- preslikava ena na ena
- kombinacija:
	- npr. na uporabniškem nivoju imamo tri, na jedrni nivo preslikamo samo dve niti
	- več sinhronizacije na uporabniškem nivoju?
	- ob pravilnem načrtovanju lahko združi pozitivne lastnosti obeh pristopov
	- Solaris do verzije 9

ULT:
- definirane na uporabniškem nivoju
- aplikacija razporeja niti znotraj edinega procesa (niti), ki obstaja na OS
- + ne delamo mode switch, pri razporejanju ne rabimo privilegijev, vse je na uporabniškem nivoju
- + sami lahko priredimo razporejanje
- + vsi OS niti ne podpirajo -> te aplikacije lahko tečejo na vsakem OS
- - ko dejansko pride do V/I zahteve, bo ta blokiral cel proces in vse niti z njo
- - če sistemski nivo vidi en proces z enim PC, če imamo dejansko na voljo več jeder, potem sočasno izvajanje ni mogoče, ker se lahko izvaja samo sistemska nit

KLT:
- preslikava ena na ena - vsaka nit postane nit na sistemskem nivoju
- - in + od ULT se zamenjajo
- + jedro lahko razporeja več niti istega procesa med več procesorjev
- + rutine jedra so lahko večjedrne
- + če je blokirana ena nit procesa, lahko zdaj jedro izvaja drugo nit istega procesa
- - ko delamo preklop na drugo nit istega procesa, to zahteva preklop v jedrni način (mode switch)
- danes pretehta KLT kot bolj uporaben, zato se to uporablja na vseh desktop OS (Windows, moderen Unix)

Kombinacija:
- npr. na uporabniškem nivoju imamo tri, na jedrni nivo preslikamo samo dve niti
- v specifičnih primer se bolje obnaša
- ![600](Pasted%20image%2020240318143342.png)
- v generalnem za desktop OS, razmerje med kompleksnostjo in pohitritvijo ni vreden

Aplikacije, ki jih potrebujemo:
- fork v Unix = pripravljenje procesne slike za nov proces
- null fork = isto, samo ne napolniš procesne slike
- signal wait - pošiljanje signala za čakanje za sinhronizacijo dveh procesov ali dveh niti

Primer ULT:
- ![](Pasted%20image%2020240318144044.png)
- b) čeprav je proces zaradi V/I zahteve blokiran, je nit še vedno v načinu izvajanja - cel proces je blokiran
- c) v izvajanje gre drug proces, proces gre v ready, niti v uporabniškem nivoju so še vedno v running (se nič ne zgodi, ker je ključne informacija na procesnem (sistemskem) nivoju)
- d) nit 2 gre iz running v blocked, nit 1 gre iz ready v running; na sistemskem nivoju procesor na zazna nič, ne rabi delati context switcha
- tudi ULT ima svoje prednosti, čeprav se v desktop OS ne uporablja

Razmerja med nitmi in procesi:
- ![500](Pasted%20image%2020240318144532.png)
- ![500](Pasted%20image%2020240318144710.png)
- ^ 1:M uporabno za cloud computing; nit se seli med procesi ali pa med posameznimi računalniškimi sistemi
- ^ 



