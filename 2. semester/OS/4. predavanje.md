Niti:
- bolj učinkovito izkoriščimo procesor z enim jedrom
- lahko sočasno razporedimo med več jedri
- če dodamo ogromno jeder, ne bo linearna pospešitev

- v jedro damo lahko minimalen nabor funkcij, ostalo pa izvedemo kot uporabniški programi (npr. Windows task manager)
- mikrojedro - minimalen nabor funkcij, ki jih rabi jedro

Proces vs. nit:
- razporejevalnik razporeja niti
- nit je osnovna enota razporejanja
- nit = lightweight proces
- kdo si lasti vire - proces (task) razervira vire za vse niti
- niti so last celotnega procesa

MS DOS:
- ena nit = en proces
- ima en program counter

Tradicionalni Unix:
- več procesov, ena nit na proces
- en program counter

Windows, Linux, Mach, Solaris, IBM-ov OS/2:
- poleg multiprogramiranja imamo tudi multinitenje
- več procesov, več niti na proces

JVM:
- Java RTE = en proces, več niti na proces (en velik proces od Jave)

Proces:
- enota alokacije pomnilnika in zaščite virov, ne kot enota razporejanja

Struktura niti:
- na PCB rabiš identitete za vsako nit - bolj smiselno je da naredimo posebej nadzorni blok vsake niti, vsaka nit dobi svoj kontrolni blok (Thread control block)
- rabimo imeti odlagalne sklade
- ![600](Pasted%20image%2020240318134545.png)
- vsaka izmed niti potrebuje svoj kontekst, svoj PCB
- še vedno rabimo kontekst celotnega procesa in user address space (preveden program + vhodni podatki)
- kernel stack je v shared address space-u (skupni viri vseh procesov)
- kako predstavimo niti znotraj procesne slike:
	- po procesu se je prej sprehajal en PC, sedaj ima poleg tega še vsaka nit še svoj PC

Prednosti niti:
- hitrost ustvarjanja:
	- hitreje, ker rabimo znotraj procesne slike, ki že obstaja narediti nove PC-je, te PC-ji postanejo del procesne slike, ki že obstajajo
	- 10 do 70-krat-ish hitrejše od ustvarjanja procesa
- hitrejše zaključevanje, ker je znotraj iste procesne slike
- preklopni čas:
	- za procese zamenjava konteksta (context switch); ni treba preklopa med procesi
	- če preklapljamo med niti istega procesa, ne rabimo vržti celega procesa iz procesorja
	- samo začnemo izvajati drug PC znotraj iste procesne slike
- deljenje virov in medsebojna komunikacija:
	- za komunikacijo med procesi se rabi vedno vpletati OS - časovno potratno
	- komunikacija med niti se ne rabi opirati na OS, ne rabi nobenih funkcij OS, ker lahko niti direktno med sabo komunicirajo
	- imamo sinhronizacija med nitmi, ki je veliko hitrejša, kot sinhronizacija med nitmi, ker se OS ne rabi vpletati

Primeri uporabe:
- Excel ... delovanje v ozadju:
	- imamo eno nit, ki prevarja ali je treba osvežiti program in eno nit, ki dela izračune, ko je treba
	- imamo sistem, ki je pripravljen na nov ukaz, še preden se je izvršil prejšnji
- Word ... in asinhrono procesiranje:
	- autosave - ena nit spremlja kaj pišemo, ena nit shranjuje kar naredimo

Stanja niti (nitni model stanj):
- ali so kakšna stanja še vedno upravljana na nivoju procesa?:
	- exit
	- blocked/suspend - če damo procesno sliko na sekundarni pomnilnik, smo morali dati vse niti tja
- katera stanja se vežejo na nit:
	- vseh ostalih 5 iz modela s sedmimi stanji

Primer učinkovitosti niti:
- RPC v Unix, LPC v Windows
- Remote procedure call za komunikacijo med dvema računalnikoma:
	- ![500](Pasted%20image%2020240318141945.png)
	- ^ proces čaka na odgovor od RPC, preden gre naprej
	- ![500](Pasted%20image%2020240318142002.png)
	- ^ medtem, ko ena nit čaka na odgovor od RPC, se druga nit izvaja
- učinkovitost se še bolj pozna, če imamo več procesov:
	- ![500](Pasted%20image%2020240318142152.png)

Načini izvajanja niti:
- pri procesih - mode switch (iz uporabniškega v jedrni nivo)
- izvajanje na uporabniškem nivoju (User level threat - ULT):
	- znotraj same aplikacije se naredi upravljanje z niti
	- OS ne ve za te niti, ker se z njimi dela na nivoju aplikacije
- izvajanje na sistemskih nivoju (Kernel level threads):
	- jedro združuje procesno sliko in njene niti
	- OS se niti zaveda, razporejanje je na nivoju OS
	- preslikava ena na ena
- kombinacija:
	- npr. na uporabniškem nivoju imamo tri, na jedrni nivo preslikamo samo dve niti
	- več sinhronizacije na uporabniškem nivoju?
	- ob pravilnem načrtovanju lahko združi pozitivne lastnosti obeh pristopov
	- Solaris do verzije 9, potem so šli nazaj na KLT

ULT:
- definirane na uporabniškem nivoju
- aplikacija razporeja niti znotraj edinega procesa (niti), ki obstaja na OS; OS se ne zaveda obstoja niti
- + ne delamo mode switch, pri razporejanju ne rabimo privilegijev, vse je na uporabniškem nivoju
- + sami lahko priredimo razporejanje
- + vsi OS niti ne podpirajo -> te aplikacije lahko tečejo na vsakem OS
- - ko dejansko pride do V/I zahteve, bo ta blokiral cel proces in vse niti z njo
- - če sistemski nivo vidi en proces z enim PC, če imamo dejansko na voljo več jeder, potem sočasno izvajanje ni mogoče, ker se lahko izvaja samo sistemska nit

KLT:
- preslikava ena na ena - vsaka nit postane nit na sistemskem nivoju
- - in + od ULT se zamenjajo
- + jedro lahko razporeja več niti istega procesa med več procesorjev
- + rutine jedra so lahko večjedrne
- + če je blokirana ena nit procesa, lahko zdaj jedro izvaja drugo nit istega procesa
- - ko delamo preklop na drugo nit istega procesa, to zahteva preklop v jedrni način (mode switch)
- danes pretehta KLT kot bolj uporaben, zato se to uporablja na vseh desktop OS (Windows, moderen Unix)

Kombinacija:
- npr. na uporabniškem nivoju imamo tri, na jedrni nivo preslikamo samo dve niti
- v specifičnih primer se bolje obnaša
- ![600](Pasted%20image%2020240318143342.png)
- v generalnem za desktop OS, razmerje med kompleksnostjo in pohitritvijo ni vreden

Aplikacije, ki jih potrebujemo:
- fork v Unix = pripravljenje procesne slike za nov proces
- null fork = isto, samo ne napolniš procesne slike
- signal wait - pošiljanje signala za čakanje za sinhronizacijo dveh procesov ali dveh niti

Primer ULT:
- ![](Pasted%20image%2020240318144044.png)
- b) čeprav je proces zaradi V/I zahteve blokiran, je nit še vedno v načinu izvajanja - cel proces je blokiran
- c) v izvajanje gre drug proces, proces gre v ready, niti v uporabniškem nivoju so še vedno v running (se nič ne zgodi, ker je ključne informacija na procesnem (sistemskem) nivoju)
- d) nit 2 gre iz running v blocked, nit 1 gre iz ready v running; na sistemskem nivoju procesor na zazna nič, ne rabi delati context switcha
- tudi ULT ima svoje prednosti, čeprav se v desktop OS ne uporablja

Razmerja med nitmi in procesi:
- ![500](Pasted%20image%2020240318144532.png)
- ![500](Pasted%20image%2020240318144710.png)
- ^ 1:M uporabno za cloud computing; nit se seli med procesi ali pa med posameznimi računalniškimi sistemi
- ^ M:N več niti se lahko menja med več procesi

- tradicionalni Unix - več procesov, ena nit na proces
- moderen Unix - več procesov, več niti na proces
- OS/2 je IBM-ov OS za desktop računalnike

---

Več jeder/več procesorjev:
- več jeder je ne enem čipu - so bližje skupaj, omogočajo hitrejše usklajevanje, hitrejša komunikacija med jedri kot med čipi
- več procesorjev = več čipov, rabimo jih povezati z vodilom (bus) - počasnejše usklajevanje
- pravo sočasno izvajanje

Učinkovitost večnitne aplikacije v večjedrnem procesorju:
- Gene Amdahl:
	- Amdahlov zakon (osnovne omejitve vzporednega izvajanja)
	- v IBM so razvijali glavne arhitekture - IBM 360, Amdahl je bil chief architect
- Grey research:
	- pionirji superračunalništva
- ![](Pasted%20image%2020240318150156.png)
- f = del, ki ga pospešimo (paraleliziramo), regulira nivo paralelizacije
- 1 - f = del, ki ga ne pospešimo
- večina problemov je takih, da ne moreš celega procesa paralelizirati, ampak lahko samo en del

Ali Amdahlov zakon zajema tudi rezporejanje in zagotavljanje skladnosti (koherentnosti) predpomnilnika (vsako jedro ima svoj L1 in L2 predpomnilnik, L3 predpomn. je skupen za vsa jedra)?
- ne
- ali lahko zanemarimo ta čas? Ne
- Amdahlov zakon ne upošteva "režiških stroškov"

- ![500](Pasted%20image%2020240318152630.png)
- ![500](Pasted%20image%2020240318152655.png)
- ^ imamo neko prelomno točko, ko je čas za razporejanje (čas za režijo) prevelik, zato je speedup manjši
- OS doda overhead za razporejanje procesov
- strojna oprema doda overhead za skladnost predpomnilnikov (če gre poces iz jedra 1 v jedro 2, je treba tudi podatke iz L1 od jedra 1 prenesti v L1 od jedra 2)

Realni primeri aplikacij, ki skoraj optimalno izkoriščajo več jeder:
- neodvisne zahteve, ki grejo do strežnikov
- specializirane podatkovne baze, ki omogočajo neodvisne zahteve do baze; imamo veliko vzporednih neodvisnih transakcij
- ![450](Pasted%20image%2020240318153339.png)

- ![500](Pasted%20image%2020240318153937.png)
- SIMD - grafične kartica (množenje matrik), blockchain pametne pogodbe in coin mining, umetna inteligenca (globoko učenje)
- MIMD - današnji procesorji
- master/slave:
	- tesno povezan naslovni prostor
	- tipična za nadzarovanje računalniškega sistema:
	- problem, če gospodar odpove, sužnji nimajo nič za delati
- lahko bi imeli enakovredne procesorje, ki prevzamejo breme od drugih procesorjev, ko te crknejo - to je SMP:
- clusterji (ohlapno povezan naslovni prostor) - en del računalnika je v eni stavbi, drug v drugi ...

SMP (simetrično multiprocesiranje):
- ![500](Pasted%20image%2020240318154125.png)
- tightly coupled main memory
- vsi procesorji razporejajo procese zase
- problem skaldnost predpomn. rešujemo strojno

Mikrojedro:
- evolucija:
	1. monolitni OS - vse v jedrnem načinu
	2. plastni OS
	3. mikrojedrni OS - Mach, delno Windows (vse module ima izvedene izven jedra, ti komunicirajo z jedrom)
- zakaj je mikrojedro mikro:
	- je majhno
	- vsebuje le bistvene funkcije OS
	- vse storitve delujejo na podlagi predajanja sporočil (message passing)
- osnovne funkcionalnosti (predajanje sporočil (message passing)):
	1. preverjanje sporočil - najprej je treba preveriti, ali gre za avtentično sporočilo, ali ima prave pravice za to kar hoče
	2. predajanje sporočil (vse se dogaja na podlagi predajanja sporočil)
	3. dostop do strojne opreme
- + omogoča fleksibilnost in modularno nadgrajevanje

- ![500](Pasted%20image%2020240318155436.png)
- monolitno jedro:
	- messy koda
- plastni OS (layered kernel):
	- smiselno, vendar interakcija je možna samo med posameznimi nivoji (če hoče file system z I/O rabi vmes še čez eno); neko sporočilo rabi čez več nivojev, namesto direktno do HW
	- - vse deli se izvajajo v jedrnem (priviligiranem načinu)
	- iz vidika varnost je težko zagotoviti ustrezno varnost, ker imamo toliko interakcij med plastmi
- mikrojedro:
	- privilegije damo samo mikrojedru
	- zgoraj imamo v nepriviligiranem načinu vse ostale storitve OS (driverji, virutal memory manager, pager ...)
	- Mach točno sledi definiciji; v Windows pa neki deli OS tečejo v jedrnem načinu, zato je to delno mikrojedro
- primer: aplikacija zahteva del procesne slike, ki še ni v glavnem pomnilniku, zato pošlje pagerju sporočilo, naj ga prenese:
	- ![500](Pasted%20image%2020240318155621.png)
- page fault processing:
	- napaka strani, če ne najdemo strani v glavnem pomnilniku gremo v navidezni pomnilnik
	- ostranjevanje in segmentacija, kaj se dogaja v SW in kaj v HW
	- aplikacija želi prenos strani iz navideznega pomn. v glavni pomn., da se lahko aplikacija izvaja naprej (za to skrbi pager - ostranjevalec; da to naredi rabi address-space function call, da dostopa do glavnega in navideznega (sekundarnega) pomnilnika; potem pošlje ACK nazaj jedru, ki to pošlje naprej aplikaciji)

- proces je vir na višjem nivoju
- več jeder omogoča pravo sočasno izvajanje niti

- prednosti mikrojedrne organiziranosti OS:
	1. imamo API (enoten vmesnik za zahteve procesov, ki deluje na osnovi sporočil)
	2. enostavna razširljivost, omogoča dodajanje novih storitev (dodajanje novih škatlic)
	3. fleksibilnost (lahko enostavno odstraniš nepotrebne aplikacije)
	4. prenosljivost (prenos OS na drugačen procesor zahteva prilagoditev komunikacije s HW, ostalo lahko ostane enako)
	5. zanesljivost (ker je majhno, ga je lažje testirati)
	6. podpora porazdeljenemu sistemu (mikrojedro ve, kam mora sporočilo - ga lahko preusmeri porazdeljenemu, širšemu OS)
	7. objektno usmerjeni OS (OS sestavimo kot kocke)

Windows razmerje med procesi in viri:
- ![500](Pasted%20image%2020240325135226.png)
- procesi jedra so enostavni, implementirani kot objekti
- je nov ali kopija drugega procesa
- ima lahko več niti
- imajo vgrajeno funkcionalnost za sinhronizacijo
- naklonjenost niti je lahko trda ali mehka za vsako jedro:
	- trda - ves čas se izvaja na istem jedru
	- mehka - si želiš priti na isto jedro, ampak če ne gre, greš na drugo jedro
- da proces ve, katere pravice ima, ima access token (žetonček); vsi otroci procesa imajo isti žeton (iste pravice); žetonček služi identifikaciji procesa (za pravice)
- virtualni naslovni prostor
- viri v tabeli objektov:
	- ima ročice na niti, datoteke, shared memory space
	- procesna slika vsebuje deljen pomnilnik prostor (shared memory space), da se funkcionalnosti jedra ne podvajajo med procesi
- naslovni prostor se spreminja le preko upravitelja pomnilnika (memory manager); memory manager je modul v OS; OS se ga direktno ne zaveda (podobno kot file manager), imaš pa posebno funkcijo, ki se ga zaveda
- če v tabeli objektov nimamo povezave na žetonček, ga ne moremo spreminjati - če smo admin, imamo tudi povezavo na žetonček v tabeli objektov in lahko spreminjamo pravice procesov
- tudi žetonček je objekt (vsaka stvar v Windowsih je objekt - tudi proces)
- če žetončka ni v tabeli objektov, proces ne more spreminjati svojih atributov (pravic); če bi bil (če smo admin), lahko proces spreminja svoje pravice
