- usmerjanje izpisa:
	- `>` prepiše celo datoteko
	- `>>` doda na konec datoteke
- `for i in {1..100}; do ./semafor1.sh; done`
- `uniq -c` prešteje koliko je vsakega elementa
- zaporedno izvajanje, ne paralelno
- če hočemo, da se ukazi vzporedno izvajajo, damo vmes `&` => `for i in {1..100}; do ./semafor1.sh & done`

- datotečni semaforji - na začetku naredimo datoteko - če nam jo je uspelo narediti, smo na kritičnem področju, lahko delamo, sicer nismo in čakamo (while loop); ko končamo zbrišemo to datoteko
- na začetku `touch script.lock`, na koncu `rm script.lock`
- operacija preverjanja in ustvarjanja `script.lock` mora biti atomična; vmes se ne sme zgoditi context switch - vgrajeni ukaz za datotečne semaforje:
	- `lockfile script.lock` in `rm -r script.lock`
	- `lockfile` je implementacija "preveri ali datoteka obstaja in če ne, jo ustvari, sicer se vrti v zanki", je atomičen
	- `lockfile` implementira blocked vrsto, preverja na 8 sekund => traja dlje da se zmenijo
- `pstree $$` - vsi otroci prejšnjega ukaza

Montiroji:
- Programski modul namesto spremenljivke:
	- pri semaforjih imamo več dela za programerja s spremenljivkami
	- če imamo nek modul, nam preuzame breme, ker so noter vse potrebne pogojne spremenljivke
	- vsebina modula je dosegljiva le znotraj modula => izoliranost => lažji nadzor
	- proces vstopi v modul s klicem njegove funkcionalnosti
	- znotraj modula je lahko le en proces v izvajanju
	- čakamo podobno kot semWait in semSignal
	
	- v primeru semaforja je vzajemno izključevanje in sinhronizacija delo programerja
	- pri monitorjih, je vzajemno izključevanje že narejeno, programer skrbi samo za sinhronizacijo
	- ![400](../../Images/Pasted%20image%2020240408144533.png)

Predajanje sporočil oz. message passing:
- podobno kot pri mikrojedru
- poskrbimo za sinhronizacijo in komunikacijo med procesi
- poenostavitev dolžnosti programerja:
	- programer mora pošiljati zahteve v nabiralnik
	- (mikrojedro sporočilo verificira in prepošlje)
- uporabno tudi pri večprocesorskih in porazdeljenih sistemih
- osnovni dve operaciji za izmenjavo sporočil:
	- `send(dest, msg)` in `receive(src, msg)`
- komunikacija prek osrednjega člena - mailbox
- ![500](../../Images/Pasted%20image%2020240408144920.png)
- omogočamo večjo fleksibilnost, ker ločujemo pošiljatelja od prejemnika, se ne rabita zavedati drug drugega
- format sporočila:
	- ![300](../../Images/Pasted%20image%2020240408145038.png)
	- control information - lahko bi dali še prioriteto, zaporedno številko sporočila ...

### Sočasnost: smrtni objem in stradanje

- ko implementiramo vzajemno izključevanje lahko pride do problemov smrtnega objema in stradanja (smrtni objem je ključni problem)

- ![600](../../Images/Pasted%20image%2020240408145517.png)
- smrtni objem: imamo dva procesa, vsak dobi v last en vir, za nadaljnje izvajanje potrebuje vir, ki ga ima drugi => noben ne more nadaljevati, ker v neskončnost čakata drug na drugega, če nimamo ustreznih mehanizmov zaznavanja
- stradanje: imamo ready prioritetne vrste, enega z majhno prioriteto, se nikoli ne bo izvajal, ker imajo vsi višjo prioriteto - ni tako problematičen, ker se bo eventually tudi ta z majhno prioriteto izvedel

Potencialni smrtni objem:
- primer: križišče dveh enakovrednih cest, vsi avti čakajo na svojega desnega, čakajo v neskončnost; noben še ni vzel vira (sredina ceste), ampak vsi so že nakazali, kaj potrebujejo
- ![300](../../Images/Pasted%20image%2020240408150053.png)

Dejanski smrtni objem:
- primer: vsi avti zapeljejo na pol v središče, noben ne more več naprej
- ![300](../../Images/Pasted%20image%2020240408150105.png)

Kako take probleme naslavljamo že pri načrtovanju programov:
- v fazi načrtovanja nastavimo, da do smrtnega objema ne bo prišlo
- načtrovanje: analiza zahtev, fazno načrtovanje, implementacija, testiranje, vzdrževanje
- diagram skupnega napredka (joint progress diagram):
	- ![500](../../Images/Pasted%20image%2020240408151950.png)
	- ko imamo pravokotno črto - zamenjava konteksta
	- rešitev: zamenjamo vrstni red ukazov pri P
	- ![500](../../Images/Pasted%20image%2020240408152331.png)

Diagram napredka:
- orodje za načrtovanje izvajanja brez smrtnega objema
- problem: ko imamo veliko procesov (več kot 3) si ne moremo narisati

Graf alokacije virov (resource allocation graph):
- vse dimenzije večih procesov imamo v 2D
- glavni gradniki: krog (proces), kvadrat (vir), puščica (get ali release), pika (števnost vira)
- ko najdemo na sliki cikel, ki ga ne moremo obrniti, pride do smrtnega objema
- ![400](../../Images/Pasted%20image%2020240408153009.png)
- pri desnem primeru, lahko eno requests puščico obrnemo, ker je prost vir, in nimamo več cikla