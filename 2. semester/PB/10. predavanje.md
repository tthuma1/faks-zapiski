Zaprtje množice atributov:
- štartamo z neko podmnožico atributov in množico funkcionalnih odvisnost
- katere vse atribute lahko dosežemo s tem
- ![350](../../Images/Pasted%20image%2020240425144021.png)
- ![400](../../Images/Pasted%20image%2020240425144145.png)
- kandidati za ključ: $K^+ = R$
- vemo, da D nujno rabimo, ker ne moremo do njega priti prek drugih odvisnosti
- ![500](../../Images/Pasted%20image%2020240425144627.png)
- za tiste atribute, ki so na obeh straneh, ne moremo vedeti ali morajo biti v ključu ali ne

Elmasari-Navathe algoritem:
- ko nas zanima samo en ključ
- začnemo s celo relacijo in odstranjujemo po en ključ,
- če je $\{K-X\}^+ = R$, potem ta atribut X zagotovo ni v ključu - ga damo ven, sicer ga pustimo
- O(n) glede na število atributov v R
- če gremo po drugem vrstne redu, lahko dobimo drugačen ključ, če je več ključev
- ni pogost v praksi
- ![500](../../Images/Pasted%20image%2020240425145327.png)

Saiedian-Spencer:
- za določanje vseh ključev
- O(2^n) v splošnem, v praksi blizu O(n), ker se v praksi hitreje konča
- rabimo upoštevati, tudi atribute, ki niso v nobeni odvisnosti - jih damo v $L$
- $L$ = množica atributov, ki so samo na levih straneh funkcionalnih odvisnosti
- $R$ = množica atributov, ki so samo na desnih straneh funkcionalnih odvisnosti
- atributi, ki so v $L$ bodo v vseh ključih
- atributi iz $R$ ne bojo v nobenem ključu
- atributi iz $B$ mogoče so, mogoče pa ne - rabimo pogledati vse podmnožico, začnemo z najmanjšo podmnožico in gremo gor (moč 1, moč 2 ...), dokler ne najdemo ključa
- če za nek X ugotovimo, da $L$ z njegovo pomočjo postane ključ, potem rabimo samo gledati podmnožice velikost kot je velik X
- ![450](../../Images/Pasted%20image%2020240425150006.png)
- ![450](../../Images/Pasted%20image%2020240425150220.png)
- če ne bi bila nobene podmnožica $B$ moči 1 dovolj, da dobimo ključ, probamo s podmnožicamo moči 2, potem 3, itd. dokler ne dobimo ključa

- ključi nam tudi služijo kot omejitve (NOT NULL, UNIQUE)
- ključi omogočajo enolično identifikacijo

Normalizacija:
- ene oblike tabel so slabše od drugih - imajo več redundance podatkov (ena stvar zapisana na več mestih)
- Normalizacija je postopek, s katerem pridemo do množice primernih (primerno strukturiranih) relacij, ki ustrezajo potrebam uporabe; prestrukturiranje tabel iz ene oblike v drugo
- lastnosti primernih relacij:
	- Relacije imajo minimalen nabor atributov -> zgolj tiste, ki so potrebni za pokritje potreb poslovnega sistema
	- Atributi, ki so logično povezani, so zajeti v isti relaciji
	- Med atributi relacij je minimalna redundanca -> vsak atribut (razen tujih ključev) je predstavljen samo enkrat
- želimo odpraviti redundanco, da so operacije čim enostavnejše (npr. spreminjanje je treba samo na enem mestu) in rabimo čim manj diska
- nad manjšo tabelo se bodo operacije izvajale hitreje

Ažurirne anomalije:
- nastanje pri DML operacijah s tabelo
- ![400](../../Images/Pasted%20image%2020240425152836.png)
- pri INSERT:
	- lahko se zatipkamo pri vpisovanju naslova
	- če želimo samo en oddelek zapisati, ki nima nobenega zaposlenega, bo moralo biti vse ostalo NULL, čeprav to ni vedno v redu
- pri DELETE:
	- Brisanje edinega člana oddelka: izgubimo tudi vse informacije o tem oddelku
- pri UPDATE:
	- ko se oddelek preseli, rabimo vse vrstice zaposlenih popraviti
- rešitev - damo oddelke v svojo tabelo
- z normalizacijo dobimo obliko, pri kateri ne more priti do ažurirnih anomalij

Prva normalna oblika:
- atribut ne more biti množica; ima samo eno vrednost
- relacija nima sestavljenih atributov (vrednost ne more biti relacija)
- ima definiran primarni ključ in določene funkcionalne odvisnosti
- ![500](../../Images/Pasted%20image%2020240425153733.png)

Druga normalna oblika:
- je v prvi normalni obliki in ne vsebuje parcialnih odvisnosti (tiste, kjer je na levi strani del ključa, ne cel ključ)
- ![125](../../Images/Pasted%20image%2020240425154046.png)
- želimo jo dati v tako obliko, da posameznih odvisnosti sploh ne bo mogoče prekršiti => za vsako parcialno odvisnost naredimo novo relacijo in v originalni relaciji ohranimo samo levo stran odvisnosti
- če je PK samo iz enega atributa, je vedno v drugi normalni obliki, ker ne moremo imeti parcialnih odvisnosti
- ![550](../../Images/Pasted%20image%2020240425154312.png)
- ![500](../../Images/Pasted%20image%2020240425154428.png)
- odvisnost šifra predmeta -> naziv je parcialna => damo jo v svojo tabelo
- v vsaki tabeli so podatki zapisani v bolj kompakten način
- slabost manjših tabel: da nazaj sestaviš podatke moraš izvajati stike, ki so računsko zahtevni; višje ko gremo po normalnih oblikah, slabša bo performansa stikov

Tretja normalna oblika:
- izločimo tranzitivne odvisnosti (atribut, ki ni del PK določa atribut, ki ni del PK; se izvajajo zunaj PK)
- ![500](../../Images/Pasted%20image%2020240425154913.png)
- rešitev: levo in desno stran odvisnosti damo v svojo tabelo in levo stran odvisnosti pustimo v originalni tabeli
- ![550](../../Images/Pasted%20image%2020240425155050.png)
- pst (poštna številka) -> kraj je tranzitivna odvisnost => jo damo v svojo tabelo, v originalni relaciji ohranimo pst
- Normalizacija relacijske sheme R v ρ:
	- ![550](../../Images/Pasted%20image%2020240425155409.png)
	- ![400](../../Images/Pasted%20image%2020240425155535.png)
	- desno stran problematičnih relacij označimo za izločanje, ne damo pa jih takoj ven - kar ostane na koncu damo (kar še nismo označili za izločanje), damo na koncu v ρ

Striktna 2. in 3. NO:
- iz nje izhaja Boyce-Coddova normalna oblika
- gledamo vse kandidate za ključ, ne samo tistega, ki smoga izbrali za PK
- Pogoje za drugo in tretjo normalno obliko preverjamo glede na VSE kandidate za ključ in ne samo glede na primarni ključ
- Torej: izraz "primarni ključ" zamenjamo z "neki kandidat za ključ"

Denormalizacija:
- včasih z normalizacijo stvari postanje prepočasne
- zaradi performans se lahko odrečemo višjim normalnim oblikam
- ko normaliziramo glede na neko odvisnost, onemogočimo kršenje te odvisnosti, ampak pri npr. BCNO lahko to povzroči izgubo teh omejitev, ki jih določajo odvisnosti; da omejitve ohranimo, prekršimo pravila normalizacije
- prve in druge NO nikoli ne kršimo
- ![450](../../Images/Pasted%20image%2020240425162357.png)

Preverjanje denormalizacije z omejitvijo:
- namesto, da imamo tabelo z vsotami časov, v originalni tabeli preverimo, da je Cas_Skupaj res vsota
- ![400](../../Images/Pasted%20image%2020240425162523.png)
- namesto omejitve, bi lahko naredili trigger na insert in update, ki avtomatsko nastavi Cas_Skupaj, da ga ne rabimo ročno vnašati
- lahko bi naredili pogled, ki doda skupni čas, skupnega časa pa ne hranimo direktno v tabeli
- pri npr. smučarskih skokih bi bil update samo dvakrat, select pa večkrat, zato je bolje narediti trigger kot pogled
- če nas zavira preveliko število stikov, naredimo denormalizacijo

### Konceptualno načrtovanje

- če imamo veliko tabel (10+)
- grafična predstavitev PB, iz slike se običajno bolj znajdemo; tudi če se nam zdi trivialno
- ER in R modeli

Trije nivoji načrtovanje:
- Konceptualni model:
	- grafična predstavitev
	- neodvisen od SUPB
- Logični model:
	- predstavitev relacij
	- normalizacija
	- zberemo vrsto podatkovnega modela (npr. relacijski podatkovni model)
	- odvisen od SUPB
- Fizični model:
	- tabele v podatkovni bazi (SQL skripta)
	- tu delamo indekse, optimizacije, denormalizacija, sprememba parametrov SUPB
	- fizična implementacija tabel v obliki datotek na disku
- ![450](../../Images/Pasted%20image%2020240425164129.png)

Konceptualno načrtovanje:
- rabimo stik z naročnikom
- opredelitev zahtev
- pomensko iz zahtev izdelamo strukturo PB
- je kritično, da prav razumemo naročnika - tudi laik (naročnik) lahko razume grafični model
- "orodje za komunikacijo razvijalca z naročnikom"
- neodvisno od podatkovnega modela
- moramo upoštevati poslovna pravila
- Tehnike konceptualnega načrtovanja:
	- ![500](../../Images/Pasted%20image%2020240425164745.png)