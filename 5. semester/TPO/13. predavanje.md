- do zdaj smo pogledali zajem zahtev, nizko in visokonivojsko načrtovanje, implementacije

### Testiranje

Kaj je testiranje PO:
- pri PO imamo dosti abstraktnih stvari, ki so na začetku nejasne, zato je važno, da preverimo, ali naša implementacija res dela tisto, kar smo načrtovali
- preverimo, ali izdelek ustreza zahtevam/pričakovanjem naročnika in razvijalca
- testiramo na umetnih podatkih, za katere vemo pravilno rešitev
- osredotočanje na iskanje napak:
	- ali smo nekaj narobe načrtovali ali smo se pri implementaciji nekaj zmotili
- testiranje nam ne zagotavlja, da je naš program čisto pravilen, ampak se samo potrudimo, da poiščemo čim več napak
- lahko imamo različne cilje pri testiranju (Bezierjevi nivoji testiranja):
	- nivo 0: enačimo testiranje z debuggiranjem - če smo odkrili kakšno napako, jo moramo odpraviti, ampak ni nujno, da smo to napako načrtno iskali
	- nivo 1: dokazovanje, da je vse v redu; demo, kjer pokažemo, da vse dela
	- nivo 2: dokazovanje, da ni vse v redu; kot testerji iščemo napake; razvijalci se trudijo narediti nekaj, kar dela, testerji pa jim nasprotujejo in začnejo tekomvati, namesto sodelovati, kar ni OK
	- nivo 3: skušamo smiselno iskati in odpraviti napake; zavedamo se, da napake najbrž so in izvajamo ukrepe, s katerimi jih iščemo in če jih je veliko, se moramo bolj potruditi, da jih odpravimo, če jih je malo, nas mogoče ne skrbi toliko
	- nivo 4: nivo 3 + standardizirano; imamo določen proces, kjer so testne skupine in testni postopki

- testiranje je del verifikacije in validacije:
	- verifikacija: ali program ustrezna zahtevam oz. vsem stvarem, ki smo jih prej rekli, da jih bo program imel; sem spada tudi dokumentacija
	- validacija: ali se naš produkt sklada s tem, kar je hotel uporabnik - to dosežemo z uporabniškim testiranjem

Napaka (defekt):
- nekaj, kar je narobe narejeno v zahtevah, načrtu, kodi ...
- nima nujno nekega učinka
- napake je možno odkriti
- vzrok za odpoved
- vrste:
	- napake pri zajemu zahtev:
		- napačna zahteva: nismo pravilno razumeli naročnika in smo si narobe zapisali
		- manjkajoče zahteve: nismo zajeli vseh zahtev
		- preveč zahtev
	- napaka pri načrtovanju
	- napaka pri implementaciji:
		- napačna implementacija: načrt je v redu zamišljen, ampak ga nismo implementirali na tak način
		- programska napaka: npr. sintaktična napaka
	- napake pri testiranju:
		- napačni testi
		- manjkajoči testi
		- napake pri popravljanju - s tem, ko nekaj popravimo, naredimo novo napako
	- najhuje je, če ugotovimo, da smo pri zahtevah nekaj narobe naredili in je bilo potem vse naprej narobe

Odpoved:
- posledica napake
- pri testiranju želimo priti do odpovedi, da razumemo, kje je napaka
- problem v delovanju sistema (npr. program nekaj narobe odgovori ali ni dovolj natančen)
- lahko jo zaznamo kot odstopanje od pričakovanega delovanja

Namen testiranja:
- pokazati, da program pravilno dela tisto, kar mora delati:
	- moramo se osredotočiti na funkcionalne zahteve
- iščemo, kje program dela nepravilno - pomankljivosti, ki jih bomo morali odpraviti

Cilj:
- odkrivamo čim več pomanjkljivosti

- pregled kode s testiranjem:
	- gledamo kodo, če je vse v redu, brez da bi poganjali
	- ne razmišljamo, ali program kot cel pravilno dela, ampak samo ali je nek odsek čudno napisan - take napake odstranimo takoj, ker so majhne, hiter fix; se osredotočiš na nek odsek kode in gledaš, če je logično napisano
- testiranje:
	- testiramo komponente in najdemo pogoje, kjer koda ne deluje kot načrtovano
	- šele kot odkrijemo, da nekje koda ne dela tako, kot bi mogla, se začnemo spraševati po vzroku napake
	- lahko testiramo tudi performanso - moramo se zmeniti, katere vrste napak bomo iskali
	- ugotovitev, zakaj pride do nekega odstopanja, ni vedno lahko

Vrste napak:
- algoritmična napaka:
	- nismo dobro razmislili postopka izvedbe
	- želimo pisati tako, da je čim lažje razumljivo, včasih za to lahko žrtvujemo hitrost
- sintaktične napake:
	- lahko gre skozi prevajalnik, ampak smo se zatipkali; nismo zares želeli tega napisati
- računske napake in napake pri natančnosti:
	- npr. napake pri float računanju
- napake preobremenitve:
	- pri preobremenitvi ne pričakujemo, da bo sistem deloval, ampak pričakujemo, da se ne sesuje, npr. ne smejo se podatki pokvariti/izgubiti
- napaka kapacitete:
	- sistem moramo imeti zasnovan tako, da lahko obdela npr. 300 študentov, ampak mi imamo arraye, ki lahko hranijo samo 100 študentov
- napake v dokumentaciji:
	- dokumentacijo se uporablja pri vzdrževanju, zato nas bo to veliko stalo
- napake časovnega usklajevanja:
	- ko pridemo do nekega koraka, morajo biti predhodni koraki že izvršeni
- prepustnost ali napake v performansah:
	- npr. nek izračun traja predolgo časa
- napake pri obnovitvi sistema:
	- kaj se zgodi v primeru, če je treba obnoviti podatke - želimo jih čim manj (nič) izgubiti, ko se sistem sesuje
	- lahko se izgubijo tisti, ki so se v tistem trenutku obdelovali, ampak tisti, ki so bili že shranjeni, morajo ostati
- napake HW in SW:
	- SW mora zaznati, če se HW čudno obnaša
- napake pri standardih in postopkih:
	- tudi če program pravilno napišemo, smo mogoče narobe izvedli postopek

Trije nivoji testiranja:
- testiranje enot:
	- enota = najmanjši del, ki ga ne moremo več razbiti (npr. neka funkcija/metoda)
	- pogledamo, da vsaka komponenta sama po sebi v redu dela
- integracijski test:
	- preverimo usklajenost komponent ene z drugo - ali se stvari v redu sestavijo skupaj
- test sistema:
	- vse zložimo skupaj; na sistem gledamo kot celoto in ga testiramo z različnih vidikov:
		- funkcionalni test - ali dela vse tisto, kar smo pričakovali
		- performančni test - ali je varen, odziven
		- tu se testiranje s pogleda razvijalca približno neha
		- sprejemni test - uporabniki preverijo, ali so dobili res to, kar so želeli
		- test namestitve - če je treba naš sistem namestiti na produkcijsko okolje, moramo testirati, da se je vse pravilno namestilo; sistem testiramo v produkciji

- pri agilnem razvoju je npr. testiranje enot že vpleteno v razvoj

- tesitranje = izvajanje programa na umetnih podatkih
- testni primer = neka izbira vhodnik podatkov, ki jih posredujemo programu in ugotovimo ali rezultat odstopa od pričakovanega
- test = končna množica testnih primerov:
	- lahko imamo več testov, kjer vsak pokrije en del sistema; imamo več množic testnih primerov

- kdo izvaja testiranje:
	- programerji - ko pišeš program, ga hkrati testiraš:
		- najbrž ne boš ujel vseh napak
	- tester - nekdo, ki je seznanjen s postopki testiranja in z orodji za testiranje:
		- pogosto so to novi programerji, ker samo slediš postopkom in se seznanjaš s kodo, ne rabiš nujno vse kode razumeti
		- je del projektne ekipe - če se s projektom mudi, lahko malo manj testira, zato da bo projekt uspel:
			- zato namesto tega lahko uporabimo neodvisno skupino za testiranje
	- neodvisna skupina za testiranje:
		- ni vezana na projekt
		- držijo nivo kvalitete, da je projekt kvalitetno narejen
	- uporabnik

Funkcionalno testiranje:
- testiranje ali vse dela prav; to preverimo za vse funkcionalne zahteve
- izhajamo iz zahtev/uporabniških zgodb

Nefunkcionalno testiranje:
- niso nujno povezani s funkcionalnostmi - testiramo npr. odzivni čas, varnost

Statično in dinamično testiranje:
- statično (brez poganjanja kode):
	- pregled kode:
		- peer review - ostali razvijalci pogledajo tvojo kodo; ti boš dobil za pregledati kodo od drugih
		- lahko si narediš nek opomnik stvari, ki jih pogosto narediš narobe in pri pregledu gledaš, da nisi ponovil teh napak
		- walkthrough - en razvijalec kaže kaj je naredil in kako je naredil, ostali pa ga sprašujejo; kot razširjen peer review
		- inspection - imamo neka pravila, kako mora biti koda napisana (glede oblike, poimenovanj spremenljivk) in pogledamo, če je v novi kodi vse to skladno
- dinamično (s poganjanjem kode):
	- naredimo si množico testnih primerov in kodo poženemo z njimi
	- rabimo gonilnik komponent:
		- naš modul sodeluje z drugimi moduli - če te drugi moduli še niso na voljo, jih rabimo pofejkati

- ko najdemo odstopanje, moramo odkriti zakaj je prišlo do odstopanja, potem popravimo, potem pogledamo, da nismo kaj za nazaj pokvarili s popravkom

Delitev glede na kaj testiramo:
- enote, komponente, skupina komponent ...

Različni pogledi:
- črna škatla:
	- testiramo nek sistem, za katerega vemo, kaj naj bi počel in mu damo podatke in gledamo izhode
	- ne zanima nas, kako sistem v notranjosti dela
	- "naš sistem kot celota mora biti dovolj odziven"
	- cilji so bolj splošni, ne testiraš nekega manjšega dela, ampak ponavadi nek daljši potek uporabe
	- slabost: tester lahko nič ne ve o sistemu, ampak ko najde napako, rabimo nekoga, ki razume kodo
	- lahko se zgodi, da ne testiramo nekih problematičnih področij, ker ne razumemo, da bi jih morali
- bela škatla:
	- poznamo vse podrobnosti kode
	- ponavadi izvaja programer za svoje stvari
	- lažje odpravimo napake, ker vemo, kaj testiramo
	- slabost: manjka širši pogled - če napaka ni taka, da smo se nekaj zatipkali, ampak rabimo malo širše pogledati na sistem
- sive škatla - nekaj vmes:
	- imamo testerje, ki vejo npr. kakšne podatkovne strukture in algoritme smo uporabili; ve neke stvari, ki so relevantne zanj, ampak ne pozna vseh detajlov implementacije
	- s tem lahko testiranje naredi bolj relevantno

Testiranje enot:
- vse, kar napišemo, je treba malo stestirati
- enota = najmanjši del, ki ga ne moremo več razbiti (metoda, funkcija, vnosni obrazec)
- testira programer sam, testira se v izolaciji, brez klica drugih metod
- bela škatla
- izvajamo potrditvene teste, ki nam povejo, da vsi pričakovani podatki v redu delajo + nepričakovani vhodi (robni pogoji)
- trije koraki:
	- pregled kode:
		- ponavadi se ne gremo dokazovati pravilnosti kode, ker je to težko
	- prevajanje kode:
		- predvsem sintaktične napake
	- dinamično testiranje:
		- priprava in izvedba testnih primerov; poženemo program s testnimi primeri

Testiranje integracije:
- sistem je sestavljen iz komponent, ki medsebojno interaktirajo
- različne komponente običajno razvijajo različni ljudje
- testiramo medsebojno delovanje
- to, kar testiramo mora ustrezati vmesnikom, ki povežejo različne komponente med sabo
- predpostavimo, da se vsaka komponenta in njen vmesnik že obnaša tako, kot je v specifikacijah (testiranje enot je že opravljeno)
- rabimo več udeležencev
- rabimo nekoga, ki bo komponente sestavil skupaj
- napake ne izhajajo iz posameznih komponent, ampak iz interakcije med enotami

Vrste vmesnikov:
- parametri:
	- nekaj pošlješ (parametre) in dobiš odgovor - preveriš, če je odgovor OK
- deljen pomnilnik:
	- zelo veliko različnih stvari se lahko dogaja s pomnilnikom, zato je težje zaznati vzrok neskladja
- procedure:
	- časovne uskladitve, najprej ena komponenta naredi X in potem šele druga lahko naredi Y
- predajanje sporočil:
	- komponente si pošiljajo sporočila - sporočila so lahko karkoli, zato je to težje testirati

Napake vmesnikov:
- napačna uporaba vmesnika
- ne razumemo, kaj vmesnik dela
- napake zaradi časovnega usklajevanja - vmesnik smo v redu uporabili, ampak časovnica delovanja komponent se ni poklopila

Integracija:
- komponente testiramo v pravilnem vrstnem redu - vsaka komponenta pripada nekem sloju hierarhije in gremo sloj po sloj, da lahko hitreje ugotovimo vzrok napake
- od spodaj navzgor, od zgoraj navzdol, kombinacija:
	- katerega bomo izbrali?
		- bottom up je najbolj priljubljen
		- odvisno, kaj želimo testirati najprej, da lahko čim prej pokažemo uporabniku

Bottom up testiranje:
- najprej zgradimo vsako komponento posebej in potem iz njih sestavimo vedno večje komponente - najprej testiramo metode, potem testiramo razred, potem skupino razredov ...
- včasih se pojavi problem, da rabimo neko komponento, ki smo jo naredili na nizkem nivoju, poklicati iz nekega višjega modula:
	- v tej fazi te nadrejene komponente še nimamo narejene, zato rabimo narediti navidezen modul, ki nam bo klical komponento - temu rečemo gonilnik
- prednosti: naravno nam je tako testirati
- slabost: dolgo časa nimamo pogleda na celoten sistem - ne moremo vmes uporabniku nič dati, ker nimamo do konca stestirano

Top down testiranje:
- najprej testiramo vrhno komponento, ki kliče vse druge podsisteme (npr. nek meni, ki lahko vse različne stvari pokaže)
- potem gremo dol, dokler ne pridemo do najbolj osnovnih komponent
- spet imamo problem, da iz višjih komponent ne moremo klicati nižjih, če te ne obstajajo:
	- nadomestimo nižje komponente s stub (nastavek), ki se odzove z nekim pravilnim odzivom (pofejka pravilen rezultat)
- prednost: vmes lahko uporabniku kažemo, kako nam gre (ves čas imaš občutek, kot da imaš že vse narejeno, samo še en košček moraš)

Kombinacija (sandwich):
- delamo malo bottom up in malo top down in se srečamo na sredini (na ciljnem nivoju)
- lahko različno kombiniramo pristop

Testiranje sistema:
- funkcionalni, performančni in sprejemni test je vedno treba narediti
- test namestitve lahko spustimo
- po testiranju integracije imamo sistem, za katerega moramo preveriti ali pravilno implementira načrt
- na nivoju integracije se ukvarjamo z nižjenivojskimi vprašanji ("Ali ta metoda kliče drugo metodo na pravilne način?")
- razvijalec ozko gleda samo svojo stvar - sedaj rabimo širši pogled na celoten sistem
- gledamo, ali smo res naredili tisto, kar je želel naročnik
- cilj je odkrivanje napak, ne odprava

- načrt testiranja:
	- ko ga pišemo, moramo pisati tudi smernice za odpravo napak
	- mora vsebovati:
		- kaj je namen in kaj so cilji testiranja sistema
		- kakšni so testni primeri
		- kakšni so testi
		- zakaj, kdo, kako, kdaj testiramo
- izvajanje testiranja
- analiza testov - primerjava rezultatov testov s pravimi rezultati:
	- če kaj ni v redu, sledi odprava napak

- pri odpravljanju napak lahko vnesemo nove napake
- regresijsko testiranje:
	- množica avtomatiziranih testov, ki jih vedno znova poganjamo, da pogledamo, če naš sistem še vedno dela pravilno po tem, ko smo ga popravili

- štirje koraki:
	- funkcionalni test
	- performančni test
	- sprejemni test
	- namestitveni test

Kdo izvaja testiranje:
- testiranje enot: programer
- integracije:
	- programer v sodelovanju s testno ali razvojno skupino
- sistema:
	- testna skupina, ki je lahko neodvisna od razvojne

Funkcionalni testi:
- ali vse funkcionalnosti delujejo tako, kot bi morale
- npr. pri studis ali lahko prijavim študenta, izrednega študenta ...
- izvajajo razvijalci oz. testna skupina

Performančni test:
- testiramo nefunkcionalne zahteve
- lahko obsega več vrst testiranja:
	- ponavadi testiramo vsaj ali je UX uporaben, ali uporabnik zna in razume uporabljati sistem
	- performanse: ali se v redu odziva, kaj se zgodi pri preobremenitvi
	- varnost
- pristop črne škatle
- vrste performančnega testa:
	- obremenitveni - kje je breaking point
	- količinski - performance under massive data volumes, da se sistem ne sesuje pod velikimi obremenitvami, ampak samo ne deluje
	- konfiguracijski test
	- kompatibilnostni test - ali naš sistem dela v skladu z nekim drugim sistemom
	- regresijski test
	- varnostni test - sledenje, kaj je kdo naredil, kdo je dostopal do sistema
	- časovni - ali so vse operacije časovno pravilno usklajene
	- okoljski - včasih zadeva vpliva na ostale sisteme v okolju
	- test kakovosti - da je naša koda v skladu s pravili/standardi
	- test obnovitve sistema
	- test vzdrževanja - ali nove spremembe po predaji pokvarijo trenutno produkcijo
	- test dokumentacije - ali je dokumentacija v skladu s kodo
	- test človeških faktorjev - ali je UI/UX v redu za človeka
	- test dostopnosti - za invalide, da je dostop sistem (velike črke, high contast)
	- test skalabilnosti - kako lahko sistem skaliramo ob večji obremenitvi
	- test obravnave izjem

Sprejemno testiranje:
- če uporabnik na začetku pove zahteve in mu potem šele na koncu pokažemo, se lahko zgodi, da smo ga narobe razumeli
- pri agilnih metodah te nevarnosti ni, ker je uporabnik ves čas zraven pri razvoju
- preverjanje glede na opis zahtev uporabnika
- izvaja ga uporabnik/naročnik oz. on nam pove, kaj naj naredimo da testiramo

Primerjalni test:
- postavimo okvirje kaj bomo testirali in različne sisteme testiramo znotraj tega okolja
- naročnik pripravi množico testnih primerov, ki predstavljajo tipične pogoje, pod katerimi bo deloval sistem
- za vsak testni primer ocenimo performanso

Pilotni test:
- preverimo naš sistem z vidika uporabnika, ampak kot poskusni pilot - nastavimo neko delovanje in skušamo simulirati navadno uporabo z vidika uporabnika
- gledamo, ali nam kaj manjka
- lahko se npr. nastavimo na en tip uporabnika, da si ne naredimo preveč dela, in preverimo ali za to skupino uporabnikov vse OK dela - izberemo neko tipično uporabo sistema
- manj formalen in strukturiran kot primerjalni test

Alfa test:
- med razvojem testiramo
- običajno to delajo razvijalci, lahko je tudi nekaj uporabnikov

Beta test:
- testirajo uporabniki
- je že zelo delujoča verzija, ampak mogoče ne čisto brez napak
- želimo dobiti veliko testerjev v kratkem času
- želimo pokazati naš sistem širši publiki, da dobimo user base

Vzporedno testiranje:
- imamo nov sistem, za katerega še nismo prepričani, ali v redu dela - poženemo ga skupaj s starim sistemom
- uporabniki se v tem času naučijo uporabljati nov sistem
- smotano, ker rabimo oba sistema vsklajevati, da dobita iste vhodne podatke - zato tega ne delamo dolgo časa

Testiranje namestitve:
- namestitev:
	- namestimo v produkciji (v okolju, kjer se bo dejansko uporabljal)
	- določimo uporabniške račune, pravice, priklopimo naprave ...
- če pogoji ob sprejemnem testiranju niso enaki dejanskim pogojem uporabe, moramo narediti še test namestitve
- ali smo vse nastavili tako, kot mora biti:
	- ali je sistem v produkciji dovolj odziven, pravilno dela ...
- želimo imeti testno okolje, ki je čim bolj podobno produkcijskem
- če dobimo veliko več uporabnikov, kot smo pričakovali, bomo v problemih

- testiramo vse od programiranja do uporabnika/naročnika


