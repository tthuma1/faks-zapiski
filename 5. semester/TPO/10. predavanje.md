Dober načrt:
- koristijo nam izkušnje, obstoječi storkovnjaki

Načrtovanje arhitekture:
- lahko naredimo neko rešitev, ki je čisto enaka že obstoječi - minimalna kreativnost in minimalno tveganje
- lahko imamo max kreativnost, ampak potem je tudi max tveganje - to rabimo, ko moramo nekaj na novo odkriti
- rabimo se odločiti o porazdeljenosti sistema, uporabljenem arhitekturnem stilu ...
- rezultat je načrt arhitekture

Uporaba obstoječih rešitev:
- kloniranje:
	- zelo malo spremenimo obstoječo rešitev
	- npr. SAP - kloniraš in spremeniš nekatere nastavitve
- referenčni model:
	- kako se neko stvar v konkretni domeni naredi na pravilni način (npr. prevajalnik)
	- kako se razgradi sistem na glavne komponente
- arhitekturni stil (vzorec):
	- niso vezani na specifično domeno, se jih poslužimo zato, da dosežemo rešitev, ki ima določene značilnosti
	- splošne rešitve, ki jih lahko uporabimo v različnih domenah ali pa kombiniramo med seboj
	- npr. pristo odjemalec/strežnik, peer-to-peer, uporaba git repozitorija
	- npr. trinivojska arhitektura spletne strani - imamo kombinacijo odjemalec/strežnik arhitekture in arhitekture ločevanja baze, poslovne logike in odjemalca

Proces načrtovanja:
- iterativno izboljšujemo
- na začetku se odločimo, kako bomo odgovorili na vse zahteve, potem kakšen arhitekturni stil bomo uporabljali in izboljšamo
- pri zahtevah smo imeli: zajem, analiza in modeliranje, dokumentiranje zahtev, pregled
- tu imamo: modeliranje, analiziranje, dokumentacija, pregled
- modeliranje:
	- zasnujemo model
	- eksperimentiramo z možnimi načini, kako bomo zasnovali arhitekturo
	- dekompozicija - model razdelimo na več koščkov, ki predstavljajo posamezno koščke oz. modele
- analiza:
	- pogledamo, če model zajema vse, kar smo želeli in če ne, ga popravimo
- dokumentacija:
	- zapišemo odločitev
- preverjanje:
	- 1. ali smo vse naredili korektno
	- 2. ali je vse to res to kar uporabnik rabi (ali se ujema z uporabnikovimi zahtevami)
- končni rezultat je načrt arhitekture PO

### Modeliranje arhitekture

- skušamo težko razumljivo stvar zapisati na preprost način z modelom, ki poudari pomembne značilnosti in skrije ostale, da imamo lažjo razpravo
- več modelov = več pogledov na en sistem
- podobno kot pri UML, kjer smo imeli različne diagrame za različne poglede na sistem:
	- velik del UML je uporaben za modeliranje načrta, ne samo za modeliranje zahtev
- lahko uporabimo ER diagram za modeliranje podatkov

Zbirka modelov:
- pomaga odgovoriti na vprašanje, ali predlagana arhitektura ustreza specifikaciji zahtev

Uporaba arhitekturnih modelov:
- z modelom bolje razumemo naš sistem, bolj vemo katere komponente bodo kaj počele, stvari postanejo jasnejše, ker jih moramo opisati
- ko razmišljamo o uporabi drugih sistemov, lahko zasnujemo stvari tako, da znova uporabimo kar že imamo narejeno = varčevanje
- vidimo če bomo v novem sistemu razvili del, ki je uporabljen še nekje drugje
- vidimo, katere dele (komponente) sploh imamo in si lahko organiziramo delo
- lahko sklepamo npr. kakšni bodo stroški, kakšne bodo performanse, kako dolgo bo trajal razvoj
- lahko bomo izbrali najboljše tehnike za razvoj posameznih komponent
- podpora uprabljavskim odločitvem:
	- imamo upravo (npr. podjetje), za katero razvijamo PO - uprava za vodenje podjetja rabi neko analizo nekih podatkov
	- z našim delom podpremo v najboljši meri poslovanje podjetja za katerega delamo rešitev z nekimi funkcionalnosti, ki koristi upravi - uprava si z našim sistemom lahko pomaga, da so bolj učinkoviti
- razumevanje tveganj:
	- npr. učenje novih tehnologij

### Dekompozicija sistema

- skušamo uporabiti najboljše rešitve za sestavljanje arhitekture
- na neki točki ne obstaja neka dobra rešitev - jo moramo sami razviti
- dekompozicija = razbijemo sistem na več komponent
- problem večkrat razbijemo - vedno na manjše kose, dokler ne pridemo do enot
- enota = komponenta, ki je ni smiselno razbijati naprej in je tipično razvit na en način (z eno tehnologijo)
- postopoma razstavljamo sistem na vedno manjše komponente
- od zgoraj navzdol pristop:
	- iz ene splošne stvari razbijem zadevo na manjše bolj podrobne stvari in potem še na manjše in manjše
- od spodaj navzgor pristop:
	- imamo ločene sisteme, za katere vemo, da jih moramo uporabiti in jih sestavimo skupaj v cel sistem
	- to ni tipično za dekompozicijo
- dobimo nivoje dekompozicije
- kaj pomenijo povezave med škatlami:
	- 1. povezanost - med dvema deloma je neka interakcija
	- 2. vsebovanost - škatla, ki vsebuje druge škatle
	- 3. izvedba - ko prideš do konca, se lahko pokaže, da določen del sistema razviješ skupaj (v isti tehnologiji oz. v istem modulu, čeprav sta logično ločena)
- na koncu narišemo škatlice, ki se povezujejo

Metode načrtovanja:
- funkcionalna dekompozicjia:
	- razvijamo sistem, ki ima različne funkcionalnosti - vsako funkcionalnost je svoja škatla
	- npr. studis ima dele s katerimi delamo vpis, razpis izpitov, vnos ocen, vnos diplom, analize - vsak izmed teh delov bo svoja škatla
- v značilnosti usmerjeno načrtovanje (feature-oriented design):
	- značilnost = funkcionalnost, ampak z vidika uporabnika
	- ko razvijalci razbijejo sistem, določijo funkcionalnosti
	- uporabniki zadeve vidijo drugače; drugačne stvari povežejo skupaj
	- npr. ko se študent prijavi na izpit, mora še preveriti ali mora plačati za izpit:
		- z vidika funkcionalnosti je izdaja računa ločena
		- z vidika uporabnika gre to skupaj z vpisom
	- so bližje uporabniškemu pogledu na sistem
- podatkovno usmerjena dekompozicija:
	- podatki so lahko grupirani na nek način
	- npr. vse podatke o vpisih imaš v enem delu, vse podatke o plačilih v drugem delu
	- lahko je zelo podobno značilnostim in funkcionalnostim ali pa zelo drugačno
	- če hranimo en del podatkov nekje in drug del drugje, rabimo to opisati:
		- npr. podatke o profesorjih imamo v eni evidenci in o študentih v drugi evidenci
- procesno usmerjena dekompozicija:
	- imamo nek postopek oz. proces, ki ima neke aktivnosti/faze/korake, ki predstavlja vsak eno škatlo
- dogodkovno usmerjena dekompozicija:
	- stvari se razstavijo na komponente okoli dogodkov, ki se zgodijo v času razvoja PO
- objektno usmerjeno načrtovanje:
	- celoten sistem razumemo kot svet z entitetami (razredi), ki imajo tipe in delajo objekte
	- posamezne škatle so razredi
- katero metodo bomo izbrali je odvisno od:
	- našega znanja, kaj razvijamo
	- vsaka škatla mora biti neka logična enota/modul, za katero se točno ve, kaj sodi tja - pomembno vodilo za razvoj, npr. eno škatlo dela en razvijalec, drugo drug
	- rabimo nekoga z izkušnjami, ki dobro razume posledice neke razdelitve

Kakovost načrta arhitekture:
- validacija:
	- ali imamo tisto, kar je naročnik od nas zahteval
	- ali so vse zahteve ustrezno dosežene
- verifikacija:
	- ali je naš načrt bil narejen na pravilni način; da nismo nič spregledali/preskočili
	- ali smo na pravilni način zgradili sistem

### Modeli in pogledi na arhitekturo sistema

- vsak arhitekturni model prikazuje en pogled na sistem
- vse skupaj sestaviš v eno sliko, ki te opozori, če kaj manjka
- za celoten pogled arhitekture rabiš 4+1 modelov (1 povezuje vse skupaj)
- 4 pogledi:
	- logični, pocesni, fizični, razvojni
	- ![600](../../Images4/Pasted%20image%2020251204123041.png)
	- konceptualni - če je vse OK,  lahko naredimo vse primere uporabe - smo primerno opisali arhitekturo

### Arkitekturni stili

- pri zgradbah nam arkitekturni slog predstavlja neka uporabljena načela, ki naredijo nek značilen rezultat
- pri PO arhitekturni stil vpliva na nefunkcionalne kvalitete izdelka tako, da jih bolj ali manj naslovijo:
	- npr. doseganje performans, zagotavljanje varnosti
- arhitektura določa osnovno strukturo, arhitekturni stil jo dopolni
- se uveljavijo skozi čas

- imajo:
	- določena pravila, elemente, tehnike
- skušajo opredeliti našo strukturo izdelka, kako naj poteka komunikaicja, kako se podatki delijo

Pogosti arhitekturni stili:
- sodelovanje med posamezni deli:
	- MVC - model-pogled-nadzornik
- struktura:
	- večslojna arhitektura
	- cevovodi
	- komponente
- podatki:
	- repozitorij
- odjemalec/strežnik, peer-to-peer
- objavi-naroči

MVC:
- pogled model-nadzornik
- imamo komunikacijo z uporabnikom
- tri vloge:
	- model - predstavlja vso poslovno logiko
	- pogled - način, kako se ta sistem predstavi zunanjemu uporabniku (lahko jih je več za več vlog)
	- nadzornik - sprejema oz. komunicira z uporabnikom:
		- na podlagi sprejemanja oz. komunikacije sodeluje s pogledom
- koristen pri spletnih aplikacijah
- prednosti:
	- dober opis uprabniškega vmesnika
	- preprosta zasnova, ki omogoča razširljivost
	- loči naš sistem z logiko od uporabniškega pogleda
	- predstava na način, kot se uporablja v spletnih aplikacijah
- slabosti:
	- če imamo neke specifične zahteve, se jih mogoče ne da s tem stilom opisati

- MVVM - pridemo do podatkov in jih pokažemo na različne načine

Večslojni sistem:
- komponente sistema so razdeljene v sloje, med katerimi komunikacija poteka vertikalno
- vsaka komponenta komunicira s spodnjo in zgornjo komponento na predpisane dele - jih je možno ločeno razvijati/zamenjevati med seboj
- naše komponente sistema so neodvisne med seboj
- sem spada trinivojska arhitektura spletne aplikacije:
	- predstavitveni, poslovni, podatkovni nivo
	- komunikacija samo med sosednjimi sloji