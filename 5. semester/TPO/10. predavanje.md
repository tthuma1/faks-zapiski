Dober načrt:
- koristijo nam izkušnje, obstoječi storkovnjaki

Načrtovanje arhitekture:
- lahko naredimo neko rešitev, ki je čisto enaka že obstoječi - minimalna kreativnost in minimalno tveganje
- lahko imamo max kreativnost, ampak potem je tudi max tveganje - to rabimo, ko moramo nekaj na novo odkriti
- rabimo se odločiti o porazdeljenosti sistema, uporabljenem arhitekturnem stilu ...
- rezultat je načrt arhitekture

Uporaba obstoječih rešitev:
- kloniranje:
	- zelo malo spremenimo obstoječo rešitev
	- npr. SAP - kloniraš in spremeniš nekatere nastavitve
- referenčni model:
	- kako se neko stvar v konkretni domeni naredi na pravilni način (npr. prevajalnik)
	- kako se razgradi sistem na glavne komponente
- arhitekturni stil (vzorec):
	- niso vezani na specifično domeno, se jih poslužimo zato, da dosežemo rešitev, ki ima določene značilnosti
	- splošne rešitve, ki jih lahko uporabimo v različnih domenah ali pa kombiniramo med seboj
	- npr. pristo odjemalec/strežnik, peer-to-peer, uporaba git repozitorija
	- npr. trinivojska arhitektura spletne strani - imamo kombinacijo odjemalec/strežnik arhitekture in arhitekture ločevanja baze, poslovne logike in odjemalca

Proces načrtovanja:
- iterativno izboljšujemo
- na začetku se odločimo, kako bomo odgovorili na vse zahteve, potem kakšen arhitekturni stil bomo uporabljali in izboljšamo
- pri zahtevah smo imeli: zajem, analiza in modeliranje, dokumentiranje zahtev, pregled
- tu imamo: modeliranje, analiziranje, dokumentacija, pregled
- modeliranje:
	- zasnujemo model
	- eksperimentiramo z možnimi načini, kako bomo zasnovali arhitekturo
	- dekompozicija - model razdelimo na več koščkov, ki predstavljajo posamezno koščke oz. modele
- analiza:
	- pogledamo, če model zajema vse, kar smo želeli in če ne, ga popravimo
- dokumentacija:
	- zapišemo odločitev
- preverjanje:
	- 1. ali smo vse naredili korektno
	- 2. ali je vse to res to kar uporabnik rabi (ali se ujema z uporabnikovimi zahtevami)
- končni rezultat je načrt arhitekture PO

### Modeliranje arhitekture

- skušamo težko razumljivo stvar zapisati na preprost način z modelom, ki poudari pomembne značilnosti in skrije ostale, da imamo lažjo razpravo
- več modelov = več pogledov na en sistem
- podobno kot pri UML, kjer smo imeli različne diagrame za različne poglede na sistem:
	- velik del UML je uporaben za modeliranje načrta, ne samo za modeliranje zahtev
- lahko uporabimo ER diagram za modeliranje podatkov

Zbirka modelov:
- pomaga odgovoriti na vprašanje, ali predlagana arhitektura ustreza specifikaciji zahtev

Uporaba arhitekturnih modelov:
- z modelom bolje razumemo naš sistem, bolj vemo katere komponente bodo kaj počele, stvari postanejo jasnejše, ker jih moramo opisati
- ko razmišljamo o uporabi drugih sistemov, lahko zasnujemo stvari tako, da znova uporabimo kar že imamo narejeno = varčevanje
- vidimo če bomo v novem sistemu razvili del, ki je uporabljen še nekje drugje
- vidimo, katere dele (komponente) sploh imamo in si lahko organiziramo delo
- lahko sklepamo npr. kakšni bodo stroški, kakšne bodo performanse, kako dolgo bo trajal razvoj
- lahko bomo izbrali najboljše tehnike za razvoj posameznih komponent
- podpora uprabljavskim odločitvem:
	- imamo upravo (npr. podjetje), za katero razvijamo PO - uprava za vodenje podjetja rabi neko analizo nekih podatkov
	- z našim delom podpremo v najboljši meri poslovanje podjetja za katerega delamo rešitev z nekimi funkcionalnosti, ki koristi upravi - uprava si z našim sistemom lahko pomaga, da so bolj učinkoviti
- razumevanje tveganj:
	- npr. učenje novih tehnologij

### Dekompozicija sistema

- skušamo uporabiti najboljše rešitve za sestavljanje arhitekture
- na neki točki ne obstaja neka dobra rešitev - jo moramo sami razviti
- dekompozicija = razbijemo sistem na več komponent
- problem večkrat razbijemo - vedno na manjše kose, dokler ne pridemo do enot
- enota = komponenta, ki je ni smiselno razbijati naprej in je tipično razvit na en način (z eno tehnologijo)
- postopoma razstavljamo sistem na vedno manjše komponente
- od zgoraj navzdol pristop:
	- iz ene splošne stvari razbijem zadevo na manjše bolj podrobne stvari in potem še na manjše in manjše
- od spodaj navzgor pristop:
	- imamo ločene sisteme, za katere vemo, da jih moramo uporabiti in jih sestavimo skupaj v cel sistem
	- to ni tipično za dekompozicijo
- dobimo nivoje dekompozicije
- kaj pomenijo povezave med škatlami:
	- 1. povezanost - med dvema deloma je neka interakcija
	- 2. vsebovanost - škatla, ki vsebuje druge škatle
	- 3. izvedba - ko prideš do konca, se lahko pokaže, da določen del sistema razviješ skupaj (v isti tehnologiji oz. v istem modulu, čeprav sta logično ločena)
- na koncu narišemo škatlice, ki se povezujejo

Metode načrtovanja:
- funkcionalna dekompozicjia:
	- razvijamo sistem, ki ima različne funkcionalnosti - vsako funkcionalnost je svoja škatla
	- npr. studis ima dele s katerimi delamo vpis, razpis izpitov, vnos ocen, vnos diplom, analize - vsak izmed teh delov bo svoja škatla
- v značilnosti usmerjeno načrtovanje (feature-oriented design):
	- značilnost = funkcionalnost, ampak z vidika uporabnika
	- ko razvijalci razbijejo sistem, določijo funkcionalnosti
	- uporabniki zadeve vidijo drugače; drugačne stvari povežejo skupaj
	- npr. ko se študent prijavi na izpit, mora še preveriti ali mora plačati za izpit:
		- z vidika funkcionalnosti je izdaja računa ločena
		- z vidika uporabnika gre to skupaj z vpisom
	- so bližje uporabniškemu pogledu na sistem
- podatkovno usmerjena dekompozicija:
	- podatki so lahko grupirani na nek način
	- npr. vse podatke o vpisih imaš v enem delu, vse podatke o plačilih v drugem delu
	- lahko je zelo podobno značilnostim in funkcionalnostim ali pa zelo drugačno
	- če hranimo en del podatkov nekje in drug del drugje, rabimo to opisati:
		- npr. podatke o profesorjih imamo v eni evidenci in o študentih v drugi evidenci
- procesno usmerjena dekompozicija:
	- imamo nek postopek oz. proces, ki ima neke aktivnosti/faze/korake, ki predstavlja vsak eno škatlo
- dogodkovno usmerjena dekompozicija:
	- stvari se razstavijo na komponente okoli dogodkov, ki se zgodijo v času razvoja PO
- objektno usmerjeno načrtovanje:
	- celoten sistem razumemo kot svet z entitetami (razredi), ki imajo tipe in delajo objekte
	- posamezne škatle so razredi
- katero metodo bomo izbrali je odvisno od:
	- našega znanja, kaj razvijamo
	- vsaka škatla mora biti neka logična enota/modul, za katero se točno ve, kaj sodi tja - pomembno vodilo za razvoj, npr. eno škatlo dela en razvijalec, drugo drug
	- rabimo nekoga z izkušnjami, ki dobro razume posledice neke razdelitve

Kakovost načrta arhitekture:
- validacija:
	- ali imamo tisto, kar je naročnik od nas zahteval
	- ali so vse zahteve ustrezno dosežene
- verifikacija:
	- ali je naš načrt bil narejen na pravilni način; da nismo nič spregledali/preskočili
	- ali smo na pravilni način zgradili sistem

### Modeli in pogledi na arhitekturo sistema

- vsak arhitekturni model prikazuje en pogled na sistem
- vse skupaj sestaviš v eno sliko, ki te opozori, če kaj manjka
- za celoten pogled arhitekture rabiš 4+1 modelov (1 povezuje vse skupaj)
- 4 pogledi:
	- logični, pocesni, fizični, razvojni
	- ![600](../../Images4/Pasted%20image%2020251204123041.png)
	- konceptualni - če je vse OK,  lahko naredimo vse primere uporabe - smo primerno opisali arhitekturo

### Arkitekturni stili

- pri zgradbah nam arkitekturni slog predstavlja neka uporabljena načela, ki naredijo nek značilen rezultat
- pri PO arhitekturni stil vpliva na nefunkcionalne kvalitete izdelka tako, da jih bolj ali manj naslovijo:
	- npr. doseganje performans, zagotavljanje varnosti
- arhitektura določa osnovno strukturo, arhitekturni stil jo dopolni
- se uveljavijo skozi čas

- imajo:
	- določena pravila, elemente, tehnike
- skušajo opredeliti našo strukturo izdelka, kako naj poteka komunikaicja, kako se podatki delijo

Pogosti arhitekturni stili:
- sodelovanje med posamezni deli:
	- MVC - model-pogled-nadzornik
- struktura:
	- večslojna arhitektura
	- cevovodi
	- komponente
- podatki:
	- repozitorij
- odjemalec/strežnik, peer-to-peer
- objavi-naroči

MVC:
- pogled model-nadzornik
- imamo komunikacijo z uporabnikom
- tri vloge:
	- model - predstavlja vso poslovno logiko
	- pogled - način, kako se ta sistem predstavi zunanjemu uporabniku (lahko jih je več za več vlog)
	- nadzornik - sprejema oz. komunicira z uporabnikom:
		- na podlagi sprejemanja oz. komunikacije sodeluje s pogledom
- koristen pri spletnih aplikacijah
- prednosti:
	- dober opis uprabniškega vmesnika
	- preprosta zasnova, ki omogoča razširljivost
	- loči naš sistem z logiko od uporabniškega pogleda
	- predstava na način, kot se uporablja v spletnih aplikacijah
- slabosti:
	- če imamo neke specifične zahteve, se jih mogoče ne da s tem stilom opisati

- MVVM - pridemo do podatkov in jih pokažemo na različne načine

Večslojni sistem:
- komponente sistema so razdeljene v sloje, med katerimi komunikacija poteka vertikalno
- vsaka komponenta komunicira s spodnjo in zgornjo komponento na predpisane dele - jih je možno ločeno razvijati/zamenjevati med seboj
- naše komponente sistema so neodvisne med seboj
- komunikacija ne more potekati med komponentami, ki niso ena zraven druge
- sem spada trinivojska arhitektura spletne aplikacije:
	- predstavitveni, poslovni, podatkovni nivo
	- komunikacija samo med sosednjimi sloji
	- podatkovni in predstavitveni sloj ne moreta direktno komunicirati
- slabosti:
	- mora biti naš sistem primeren za večslojno arhitekturo
- npr. pri banki:
	- uporabniki ne delamo neposredno s podatki banke, ampak imamo nekega posrednika (blagajnik ali bančna aplikacija)
- npr. posrednik za prodajo:
	- posrednik npr. obvešča in išče stranke
	- če posrednika ne rabimo, potem ta arhitekturni stil ni primeren in bi bil bolj ugoden nakup direktno
- npr. ISO/OSI model
- z večnivojsko arhitekturo zagotavljamo strukturo, ki bo poskrbela za neke vidike, ki jih želimo (npr. preverba podatkov, pretvorba podatkov, avtorizacija ...; želimo presejati neke stvari preden grejo naprej)

Cevovodi in filtri:
- gre skozi filtre dokler ne pride do končne oblike
- vsak filter ima neko funkcijo
- izhodi so prilagojeni, da se lahko naprej uporabljajo
- imamo zaporedje funkcionalnih enot, ki izvajajo posamezne dele
- imamo zgodbo, ki nekaj naredi nad vhodom in dobimo izhod
- lahko en kvadrat zamenjamo z dvema drugima ali pa z vzporednimi kvadratki
- prednosti:
	- lepo razbito v smislu obdelave postopka - najprej naredimo prvi del, potem drugi, tretji ...
	- ločimo na manjše enote, ki lahko procesirajo
	- uporabno za npr. prevajalnik
- slabosti:
	- togost - lahko je s filtri preveč komplicirano predstaviti ali pa dobimo filtre, ki nič ne naredijo
	- ni primerno za sistem, ki ima veliko interakcij z uporabnikom, ampak za stvari, ki jih poženeš in se zgodijo
- primer:
	- npr. ponoči delaš backupe - čez dan jih daš v cevovod in se potem kasneje izvedejo

Komponentne arhitektura:
- ena komponenta lahko vsebuje drugo komponento
- jasno definiramo vmesnike, kako od zunaj vidimo neko komponento
- katere metode so javne in katere so skrite
- razdelitev sistema na več manjših
- prednosti:
	- prisili te, da bolje razmišliš o sistemu
	- jasna predstavitev, vidimo potrebo po zamenjavi komponent
- slabosti:
	- težje spreminjamo, ko imamo enkrat določeno strukturo komponent
	- statična predstavitev, ni predstavitev delovanja

(Centralni) repozitorij:
- centralna shramba podatkov, ki se nahajajo na enem mestu
- npr. če imamo v študentskem domu skupni WC na hodniku, namesto v vsaki sobi
- npr. vsaka podružnica nima svoje shrambe, ampak se vse hrani na enem centralnem strežniku
- ne rabimo podvajati podatkov; ko spremenimo en del, ne rabimo iti še ostalih posodabljati
- problem: kako preprečiti sočasne spremembe => zaklepanje
- performansa: če veliko strank želi hkrati dostopati, bo počasneje
- prednosti:
	- nimamo porazdeljenosti podatkov, ki bi jih morali sinhronizirati (skrb za referenčno integriteto)
	- en zapis podatkov - ne porabljamo prostora po nepotrebnem
	- izboljšanja servisa nad podatki
- slabosti:
	- počasnejši sočasen dostop do podatkov
	- če se pokvarijo podatki je treba revertati backup
	- če en strežnik crkne, nam nič ne bo delalo
	- če imamo kritične aplikacije, imamo podatke podvojene za redundanco; tudi lokacijsko ločene shrambe
	- lahko imamo namesto polnih backupov, inkrementalne (shraniš sprmembe od zadnjega polnega backupa)
- primer:
	- podatkovna baza

- kakšno imamo porazdeljenost procesiranja - na enem (client-server) ali več mestih (P2P)

Odjemalec-strežnik:
- na strežniku imamo logiko in podatke
- strežnik komunicira z množico manj zmogljivih odjemalcev - znajo pridobiti podatke in jih predstaviti uporabniku
- npr. spletna aplikacija
- prednosti:
	- ugodno za veliko število odjemalcev, ker lahko pojačamo strežnik, imamo centraliziran nadzor
- slabosti:
	- če strežnik ne deluje, ne deluje nič

Večnivojska arhitektura:
- prej smo imeli več slojev, tu ločimo točno na 3 nivoje
- 3-nivojska arhitektura (n-nivojska)
- celotno poslovanje ločeno na 3 nivoje
- za spletne aplikacije
- slabosti:
	- katerikoli del je kritičen če odpove

P2P:
- vsaka komponenta je tako strežnik kot tudi odjemalec (vlogi izmenjuje)
- vsi lahko komunicirajo med sabo
- slabosti:
	- strežniki niso zelo zmogljivi
- prednosti:
	- zelo razširljivo, veliko redundance
	- lahko porazdelimo delo med več peerov
- ko imaš zelo veliko peerov, je komunikacija in nadzor nad sistemom zahtevna - zelo hitro se poveča število možnih komunikacijskih poti

SOA:
- service-oriented architecture
- zbirka servisov, ki med seboj komunicirajo na določen način
- uporabno za občasno komunikacijo med servisi
- mora biti zelo natančno dogovorjena komunikacija (oblika, prenos podatkov)
- v primeru pojavljanja napak v komunikaciji:
	- rabimo nekega operaterja, ki ročno popravi stvari
- imamo ponudnik in porabnik servisa
- prednosti:
	- računalniki se sami dogovorijo
- slabosti:
	- ni interakcije/nadzora in v primeru težav jih je zoprno odkrivati, sploh če niso prilagojene človeku za branje

Objavi-naroči:
- imamo ponudnike informacij, ki želijo redno (npr. vsak dan) posredovati neke informacije velikemu številu naročnikov
- imamo nek centralni strežnik, ki objavlja sporočila na neko temo - obvesti vse uporabnike
- uporabniki se morajo prej naročiti na temo/storitev
- prednost:
	- dobro dela, če rabimo naročnino
	- avtomatizirano pošiljanje sporočil

- če delamo podobno rešitev, uporabimo primeren arhitekturni stil

Kombinacija stilov:
- ponavadi ne uporabljaš samo enega stila, ampak več stilov
- lahko imamo na različnih nivojih različne stile
- lahko kombiniramo stile skupaj, da dobimo določene značilnosti
- npr. imamo odjemalec/strežnik, strežnik ima znotraj sebe sloje
- preplet modelov moramo dobro dokumentirati

 - na koncu imamo module, kjer en modul služi enemu namenu in je narejen z eno tehnologijo
 
 - naslednjič načrtovanje modulov: imamo neke načine (protokole) za komunikacijo med škatlami in vmesnika, kako vidimo škatle