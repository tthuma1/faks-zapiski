- ko beremo iz zaprtega kanala, se prebere privzeta vrednost
- kanal ima lahko kapaciteto 0 ali pa ima nek buffer
- če zapremo kanal, ki ima v bufferju še neke vrednosti - pisati ne moremo več noter, beremo še vedno lahko vrednosti, ki so v bufferju kanala
- da nimamo problemov, da hočeta dve gorutini zapreti en kanal, ponavadi tista gorutina, ki kanal odpre, tudi kanal zapre

`velik-crke.go`:
- če ne bi imeli pisanja v kanal v svoji gorutini, bi se izvajanje ustavilo, ker je pisanje v kanal blokirajoče in v funkciji `getLettersFromMessage` nimamo še nobenega poslušalca na kanalu
- pisanje v kanal damo v gorutino z anonimno funkcijo:
	- anonimna funkcija je uporabna, da ne rabimo pošiljati reference na stream kot parameter
	- `getMessageFromLetters` bo bralo dokler je kanal odprt
	- `close` je lepše napisati z `defer`, ker če imamo več možnih izhodov iz funkcije prek vejitev (if), potem se ne rabimo ukvarjati s tem, kje povsod je treba dati `close`, ampak ga go vedno da pred `return`
	- `getLettersFromMessage` bo vrnilo kanal, potem bo `getMessageFromLetters` začel brati iz kanala in ko se bo druga gorutina izvedla (ko bo razvrščena na CPU), bomo normalno lahko pisali v kanal, ker imamo na drugi strani že bralca

Broadcast primer `razglas.go`:
- speaker bo pisal v konzolo in ko konča, bo poslušalcem rekel, da lahko nehajo poslušati
- v listener pišemo prazno strukturo `struct{}`:
	- s tem povemo, da se kanal ne uporablja za pošiljanje sporočil, ampak zgolj za sinhronizacijo
	- imamo 5 gorutin, lahko bi v vsako pisali za zaključek, ampak lepše je, če samo zapremo kanal - iz zaprtega kanala vedno lahko beremo in vse gorutine bodo ob zaprtju kanala prebrale prazno sturkturo (in status, da je kanal zaprt); zato se ob zaprtju kanala vse gorutine lahko naprej izvajajo in zaključijo

Funkcija, ki bere iz več kanalov naenkrat:
- če delamo vse v eni zanki, ne bo v redu, ker bo stalo na miru, če je en kanal prazen (tudi, če je en kanal prazen in drugi poln, ne bo bralo iz drugega)
- uporabimo `select` stavek:
	- podobno kot `switch`, ampak namesto, da gre po vrstni po `case`, zna ugotoviti v katerem kanalu se je nekaj zgodilo
	- glede na spremembo stanja kanala ugotovi, da se je nekaj zgodilo in gre brati kanal
	- če sta dva kanala naenkrat na voljo za branje, se bo go naključno odločil iz katerega bomo najprej brali