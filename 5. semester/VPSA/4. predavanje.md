- ko beremo iz zaprtega kanala, se prebere privzeta vrednost
- kanal ima lahko kapaciteto 0 ali pa ima nek buffer
- če zapremo kanal, ki ima v bufferju še neke vrednosti - pisati ne moremo več noter, beremo še vedno lahko vrednosti, ki so v bufferju kanala
- da nimamo problemov, da hočeta dve gorutini zapreti en kanal, ponavadi tista gorutina, ki kanal odpre, tudi kanal zapre

`velik-crke.go`:
- če ne bi imeli pisanja v kanal v svoji gorutini, bi se izvajanje ustavilo, ker je pisanje v kanal blokirajoče in v funkciji `getLettersFromMessage` nimamo še nobenega poslušalca na kanalu
- pisanje v kanal damo v gorutino z anonimno funkcijo:
	- anonimna funkcija je uporabna, da ne rabimo pošiljati reference na stream kot parameter
	- `getMessageFromLetters` bo bralo dokler je kanal odprt
	- `close` je lepše napisati z `defer`, ker če imamo več možnih izhodov iz funkcije prek vejitev (if), potem se ne rabimo ukvarjati s tem, kje povsod je treba dati `close`, ampak ga go vedno da pred `return`
	- `getLettersFromMessage` bo vrnilo kanal, potem bo `getMessageFromLetters` začel brati iz kanala in ko se bo druga gorutina izvedla (ko bo razvrščena na CPU), bomo normalno lahko pisali v kanal, ker imamo na drugi strani že bralca

Broadcast primer `razglas.go`:
- speaker bo pisal v konzolo in ko konča, bo poslušalcem rekel, da lahko nehajo poslušati
- v listener pišemo prazno strukturo `struct{}`:
	- s tem povemo, da se kanal ne uporablja za pošiljanje sporočil, ampak zgolj za sinhronizacijo
	- imamo 5 gorutin, lahko bi v vsako pisali za zaključek, ampak lepše je, če samo zapremo kanal - iz zaprtega kanala vedno lahko beremo in vse gorutine bodo ob zaprtju kanala prebrale prazno sturkturo (in status, da je kanal zaprt); zato se ob zaprtju kanala vse gorutine lahko naprej izvajajo in zaključijo

Funkcija, ki bere iz več kanalov naenkrat:
- če delamo vse v eni zanki, ne bo v redu, ker bo stalo na miru, če je en kanal prazen (tudi, če je en kanal prazen in drugi poln, ne bo bralo iz drugega)
- uporabimo `select` stavek:
	- podobno kot `switch`, ampak namesto, da gre po vrstni po `case`, zna ugotoviti v katerem kanalu se je nekaj zgodilo
	- glede na spremembo stanja kanala ugotovi, da se je nekaj zgodilo in gre brati kanal
	- če sta dva kanala naenkrat na voljo za branje, se bo go naključno odločil iz katerega bomo najprej brali
	- kaj če nobeden od `case` nima pogoja za izvajanje - izvede se `default`; če ga ni bo `select` blokiral izvajanje
	- ko damo default, se kanal iz `time.After` ne bo nikoli bral, ker nikoli ne bomo eno sekundo v tem `case` čakali
	- če noben kanal ni na voljo za branje, `select` blokira izvajanje
	- okoli `select` rabimo neskončno zanko, da bo veš čas gledal, če je kateri izmed kanalov na voljo - za zaključek lahko dodamo še en kanal, ki nam pove, da naj končamo zanko (`streamDone`)
	- v našem primeru na koncu samo readerja pridružimo nazaj glavni gorutini - če bi hoteli še writerje, bi morali še njih dodati v WaitGroup in še onadva poslušata sinhronizacijski kanal za konec (`streamDone`)

Računanje pi:
- ko delamo v več gorutinah imamo problem, ker je `pi` globalna spremenljivka:
	- dve gorutini lahko hkrati prebereta isto vrednost `pi.shots`, ji dodata 1 in shranita isto vrednost - v tem primeru smo izgubili eno povečanje `pi.shots`
	- tvegano stanje oz. race condition/data race
	- najprej prva gorutina prebere shots=x, potem druga prebere shots=x, potem prva prišeteje shots=x+1 in shrani, potem druga prišteje shots=x+1 in shrani => dvakrat smo shranili isto vrednost shots in s tem smo izgubili pravo vrednost
- `go run --race pi.go` - go sam proba odkriti race conditione
- kritični odsek - zaklenemo del kode `pi.shots++`, da se bo v tem odseku lahko izvajala le ena gorutina naenkrat
- če naredimo globalen `lock`:
	- če je samo binarna vrednost, nismo nič dosegli
	- lahko damo vsaki gorutini id in ko lock pride na vrednost za to gorutino, se bo izvajala - to je slabo, ker vmes gorutine, ki ne smejo v kritično območje tečejo v prazno na CPU
- mutex:
	- `pi.shots = pi.shots + 1` mora biti atomarna operacija - tisti, ki želi narediti to operacijo, jo mora narediti, brez da bi kdo drug dostopal do `pi.shots`
	- to je atomarno za sočasnost, ampak ne za vzporednost - rabimo atomarnost na nivoju procesorja
	- CPU mora imeti podporo za atomarnost
	- TAS - test and set:
		- ko CPU dela TAS, mora zakleniti vodilo do glavnega pomnilnika za to pomnilniško besedo
		- MESI:
			- ko beremo neko vrednost iz pomnilnika, vsi ostali predpomnilniki sinhronizirajo vrednost te pomnilniške besede v cache
			- ko imaš ti pravo vrednost v cache, ji nastaviš zastavico exclusive (E)
		- dobro, ker zaklenemo samo eno pomnilniško besedo, namesto celega pomnilnika
	- LL-SC:
		- zapiše vrednost v pomnilnik samo, če je ob pisanju ista, kot je bila ob branju