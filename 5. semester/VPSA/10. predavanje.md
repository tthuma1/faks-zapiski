### Vektorska ura
```go
	msgSend := fmt.Sprintf("%v @ %v", message, timeNow)
	fmt.Println("Sent message:", msgSend)
	msgSendVC := Logger.PrepareSend("Sending Message", []byte(msgSend), opts)
```
- ko naredimo sporočilo, ga opremimo še z vektorsko uro
- vedno poleg sporočila pošljemo še vektorsko uro
- kaj če gre kaj narobe?
	- algoritmi ratajo bolj zapleteni

### Modeli porazdeljenih sistemov

- ob predpostavki x, se reši na način y
- tipi predpostavk, kaj lahko pričakujemo, da se bo zgodilo
- 1. zanesljivost povezav:
	- peer-to-peer in broadcast - je sestavljen iz več peer-to-peer povezav (kar se teoretičnih modelov tiče, se gledajo povezave med dvema procesoma)
	- s sprejemljivimi izgubami - kdaj se nek paket izgubi ali pa lahko pride podvojen paket (UDP)
	- zanesljive povezave - v primeru, če se sporočilo izgubi, bo še enkrat poslano; če dobimo duplikat sporočila, bo eno ignorirano (TCP)
	- overovljene zanesljive povezave (TLS) - s certifikati potrdimo, da je pošiljatelj/prejemnik pravi
- 2. zanesljivost procesov:
	- bizantinski proces oz. proces z napakami - proces lahko laže; lahko dela, ampak drugače kot bi moral; pošilja neka zlonamerna sporočila (hrošči, napake, zlonamerna koda) 
	- obnovljivi procesi (crash recovery) - zaradi napake v programu nam je proces dol padel, ampak se lahko restarta in spet začne delati
	- neobnovljivi procesi (crash stop) - ko pade dol, se ne pobere več
	- v letalstvo se zato uporablja 3 procese in se zaupa večini (2 od 3)
- 3. časovna komponenta:
	- sinhroni model - pričakujemo, da bomo vedno dobili odgovor v nekem časovnem oknu; najlažje modelirati in programirati
	- asinhroni model - predpostavljamo, da ko enkrat pošljemo sporočilo, bomo enkrat (ne vemo kdaj) dobili odgovor nazaj; če ne vemo, kdaj bomo dobili odgovor, je težje sprogramirati, da program ne crasha ali čaka v neskončnost
	- delno sinhroni model - predpostavljamo, da se večino časa obnaša kot sinhroni model (dobivamo odgovore), kdaj se pa tudi zalomi in traja malo več časa za odgovor
- hočemo povezave s sprejemljivimi izgubami, obnovljive procese in delno sinhroni čas

- zakaj ne dobimo odgovora:
	- 1. request se je zgubil
	- 2. server je crashal
	- 3. reply se je izgubil
- detekcija napak:
	- preko pošiljanja sporočil
		- procesi komunicirajo s pošiljanjem sporočil - vedno rabimo nastaviti neko smiselno časovno okno, znotraj katerega pričakujemo odgovor - če odgovora ni, ponovno pošljemo sporočilo in če še vedno ne moremo nadaljevati, javimo napako
	- če nam je pomembno, da je komunikacija ves čas živa - periodično preverjanje:
		- ping - odjemalec pošlje ping in strežnik pošlje pong:
			- ne smemo imeti prekratkega timeouta, ker drugače lažno mislimo, da je server dol
			- če imamo predolg timeout, bomo predolgo čakali, čepravi je strežnik padel dol
		- srčni utrip - odjemalec ves čas pošilja svoj srčni utrip in strežnik ves čas pošilja svoj srčni utrip

### Replikacija
