### Vektorska ura
```go
	msgSend := fmt.Sprintf("%v @ %v", message, timeNow)
	fmt.Println("Sent message:", msgSend)
	msgSendVC := Logger.PrepareSend("Sending Message", []byte(msgSend), opts)
```
- ko naredimo sporočilo, ga opremimo še z vektorsko uro
- vedno poleg sporočila pošljemo še vektorsko uro
- kaj če gre kaj narobe?
	- algoritmi ratajo bolj zapleteni

### Modeli porazdeljenih sistemov

- ob predpostavki x, se reši na način y
- tipi predpostavk, kaj lahko pričakujemo, da se bo zgodilo
- 1. zanesljivost povezav:
	- peer-to-peer in broadcast - je sestavljen iz več peer-to-peer povezav (kar se teoretičnih modelov tiče, se gledajo povezave med dvema procesoma)
	- s sprejemljivimi izgubami - kdaj se nek paket izgubi ali pa lahko pride podvojen paket (UDP)
	- zanesljive povezave - v primeru, če se sporočilo izgubi, bo še enkrat poslano; če dobimo duplikat sporočila, bo eno ignorirano (TCP)
	- overovljene zanesljive povezave (TLS) - s certifikati potrdimo, da je pošiljatelj/prejemnik pravi
- 2. zanesljivost procesov:
	- bizantinski proces oz. proces z napakami - proces lahko laže; lahko dela, ampak drugače kot bi moral; pošilja neka zlonamerna sporočila (hrošči, napake, zlonamerna koda) 
	- obnovljivi procesi (crash recovery) - zaradi napake v programu nam je proces dol padel, ampak se lahko restarta in spet začne delati
	- neobnovljivi procesi (crash stop) - ko pade dol, se ne pobere več
	- v letalstvo se zato uporablja 3 procese in se zaupa večini (2 od 3)
- 3. časovna komponenta:
	- sinhroni model - pričakujemo, da bomo vedno dobili odgovor v nekem časovnem oknu; najlažje modelirati in programirati
	- asinhroni model - predpostavljamo, da ko enkrat pošljemo sporočilo, bomo enkrat (ne vemo kdaj) dobili odgovor nazaj; če ne vemo, kdaj bomo dobili odgovor, je težje sprogramirati, da program ne crasha ali čaka v neskončnost
	- delno sinhroni model - predpostavljamo, da se večino časa obnaša kot sinhroni model (dobivamo odgovore), kdaj se pa tudi zalomi in traja malo več časa za odgovor
