### Vektorska ura
```go
	msgSend := fmt.Sprintf("%v @ %v", message, timeNow)
	fmt.Println("Sent message:", msgSend)
	msgSendVC := Logger.PrepareSend("Sending Message", []byte(msgSend), opts)
```
- ko naredimo sporočilo, ga opremimo še z vektorsko uro
- vedno poleg sporočila pošljemo še vektorsko uro
- kaj če gre kaj narobe?
	- algoritmi ratajo bolj zapleteni

### Modeli porazdeljenih sistemov

- ob predpostavki x, se reši na način y
- tipi predpostavk, kaj lahko pričakujemo, da se bo zgodilo
- 1. zanesljivost povezav:
	- peer-to-peer in broadcast - je sestavljen iz več peer-to-peer povezav (kar se teoretičnih modelov tiče, se gledajo povezave med dvema procesoma)
	- s sprejemljivimi izgubami - kdaj se nek paket izgubi ali pa lahko pride podvojen paket (UDP)
	- zanesljive povezave - v primeru, če se sporočilo izgubi, bo še enkrat poslano; če dobimo duplikat sporočila, bo eno ignorirano (TCP)
	- overovljene zanesljive povezave (TLS) - s certifikati potrdimo, da je pošiljatelj/prejemnik pravi
- 2. zanesljivost procesov:
	- bizantinski proces oz. proces z napakami - proces lahko laže; lahko dela, ampak drugače kot bi moral; pošilja neka zlonamerna sporočila (hrošči, napake, zlonamerna koda) 
	- obnovljivi procesi (crash recovery) - zaradi napake v programu nam je proces dol padel, ampak se lahko restarta in spet začne delati
	- neobnovljivi procesi (crash stop) - ko pade dol, se ne pobere več
	- v letalstvo se zato uporablja 3 procese in se zaupa večini (2 od 3)
- 3. časovna komponenta:
	- sinhroni model - pričakujemo, da bomo vedno dobili odgovor v nekem časovnem oknu; najlažje modelirati in programirati
	- asinhroni model - predpostavljamo, da ko enkrat pošljemo sporočilo, bomo enkrat (ne vemo kdaj) dobili odgovor nazaj; če ne vemo, kdaj bomo dobili odgovor, je težje sprogramirati, da program ne crasha ali čaka v neskončnost
	- delno sinhroni model - predpostavljamo, da se večino časa obnaša kot sinhroni model (dobivamo odgovore), kdaj se pa tudi zalomi in traja malo več časa za odgovor
- hočemo povezave s sprejemljivimi izgubami, obnovljive procese in delno sinhroni čas

- zakaj ne dobimo odgovora:
	- 1. request se je zgubil
	- 2. server je crashal
	- 3. reply se je izgubil
- detekcija napak:
	- preko pošiljanja sporočil
		- procesi komunicirajo s pošiljanjem sporočil - vedno rabimo nastaviti neko smiselno časovno okno, znotraj katerega pričakujemo odgovor - če odgovora ni, ponovno pošljemo sporočilo in če še vedno ne moremo nadaljevati, javimo napako
	- če nam je pomembno, da je komunikacija ves čas živa - periodično preverjanje:
		- ping - odjemalec pošlje ping in strežnik pošlje pong:
			- ne smemo imeti prekratkega timeouta, ker drugače lažno mislimo, da je server dol
			- če imamo predolg timeout, bomo predolgo čakali, čepravi je strežnik padel dol
		- srčni utrip - odjemalec ves čas pošilja svoj srčni utrip in strežnik ves čas pošilja svoj srčni utrip

### Replikacija

- za večjo zanesljivost - če en proces pade dol, lahko drug prevzame
- če imamo več procesov, ki nudijo isto storitev, lahko delo (requeste) porazdelimo med procese in bo sistem bolj odziven, hitrejši
- vsi procesi se morajo strinjati o stanju shrambe - konsenz
- za odjemalca mora biti vseeno, ali je kontaktiral en proces ali neko verigo procesov - porazdeljen sistem mora delovati kot eno
- kako zanesljivo doseči, da bodo imeli vsi procesi enako stanje:
	- deterministrični končni avtomati:
		- avtomat lahko prehaja med nekimi stanji
		- končno število stanj, vhodnih črk in izhodov
		- petorček: stanja, vhodne črke, izhodne črke, funkcija, ki zna na podlagi trenutnega stanja in vhodne črke prehajati v drugo stanje, funkcija, ki glede na trenutne stanje prižiga določene izhode
		- deterministično: je jasno, kaj se bo zgodilo glede na trenutno stanje in v vhod se vedno odločimo za isto naslednje stanje; na podlagi stanja bomo vedno imeli iste izhode
		- vedno se začne v istem začetnem stanju => če vsi dobivajo vhode v enakem zaporedju, bodo vsi prehajali v enaka stanja (lahko en malo zamuja)

### Verižna replikacija

- šele, ko je vpis potrjen v zadnjem členu verige, ga strežnik ne sme zares uporabiti
- karkoli nam odpove od vmesnih procesov, bomo še vedno lahko servirali tako pisatelju kot bralcu

- kako vemo, da je vozlišče padlo dol:
	- nekdo mora preverjati, če so procesi živi
	- lahko npr. glava pošilja healtcheck vmesnim procesom - to bi bilo smotano, ker bi potem moralo vsako vozlišče poznati celo verigo, da ve, kateri proces sledi, če en pade dol
	- boljša rešitev: nadzorna ravnina

Nadzorna ravnina:
- za enkrat bomo imeli enega nadzornika
- nadzornik ves čas preverja, če ima vse procese v verigi
- nadzorni proces ve, kdaj nek proces pade dol in v tem primeru preveže verigo

- če pade glava dol:
	- naslednji proces v verigi postane glava
	- odjemalec ne bo dobil ACK na svoj request, če vmes pade glava dol in bo po timeoutu še enkrat poslal request
- če pade rep dol:
	- predzadni proces postane novi rep
	- spet dobimo timeout
- če pade vmesni proces:
	- nadzorna ravnina mora zvezati predhodnika in naslednika
	- naslednik nadzorni ravnini sporoči zadnji ID sporočila, ki ga je dobil; predhodnik pošlje nadzorniku zadnji ID potrditve - predhodnik nasledniku potem pošlje vsa sporočila, ki jih naslednik nima in naslednik mu pošlje vse ACK
- če imamo na začetku $p$ procesov, nam jih lahko $p-1$ odpove in nam bo zadeva še vedno delala

- kako bo odjemalec (bralec in pisatelj) vedel, kje je glava in kje rep:
	- odjemalec ko vzpostavlja povezavo, najprej vpraša nadzornika, kje je glava in kje je rep
	- če povezava pade, bo odjemalec to ugotovil in bo še enkrat vzpostavljal povezavo

Dodajanje novih procesov:
- najlažje jih je dodajati na koncu, ker ima rep najhitreje aktualno bazo
- moramo računati na to, da je baza lahko zelo velika in kopiranje nekaj časa traja - dve fazi:
	- 1. sinhronizacija:
	- 2. ko rep dobi nek nov zapis, ga takoj pošlje naprej in ga tako sproti aktualizira
- ko se cela baza prekopira na novi rep, se naredi prevezava, da postane pravi rep

- to so v bistvu neobnovljivi procesi, ker naredimo novega na drugem mestu

- zakaj pošiljati po verigi, namesto, da delamo broadcast - da ne preobremenimo glave; glava naj pošilja samo eno sporočilo naprej in potem vsako proces pošlje samo eno sporočilo naprej
- super rešitev, ko imamo malo pisanja in veliko branja

- pišemo lahko samo v glavo, beremo lahko na katermkoli vozlišču, ker imajo vsa približno isto bazo
- če probamo brati nek zapis v vmesnem procesu, ki še ni potrjen, potem gremo vprašati rep, kakšna je resnica in pošljemo odgovor odjemalcu
- označujemo si umazane (nepotrjene) zapise z zastavico

- glava naj obdeluje zahteve cevovodno:
	- cevovod nam zadevo pohitri za toliko, kot imamo stopenj
	- ko glava prejme zapis od odjemalca, ga pošlje naprej in gre sprejemati naslednji zapis odjemalca - zahtevi bosta po verigi potovali ena za drugo
- kaj če odjemalca vpisujeta isti ključ:
	- imamo verzioniranje za vsak ključ

Projektna naloga:
- nimamo komplikacije z pollanjem bralca, ker imamo data stream
- kako ugotovimo, katere kategorije so na voljo - beremo samo iz repa
- pisanja grejo preko glave - lahko cevovodno ali ne:
	- če nimaš cevovoda ne rabiš verzioniranja, tudi dirty bitov ne rabiš
	- za vote je vseeno ali pokažeš enega več ali manj
	- oznako sporočila še vedno rabiš
- odjemalci bodo pisatelji in bralci:
	- nadzornik pove odjemalcu, na katerega izmed vmesnih procesov se bo priključil s streamom
- ko vmesen proces pade, se izgubijo vsi njegovi streami:
	- odjemalec gre spet na nadzornika vprašati kdo je glava, rep, kam naj se poveže