### Vektorska ura
```go
	msgSend := fmt.Sprintf("%v @ %v", message, timeNow)
	fmt.Println("Sent message:", msgSend)
	msgSendVC := Logger.PrepareSend("Sending Message", []byte(msgSend), opts)
```
- ko naredimo sporočilo, ga opremimo še z vektorsko uro
- vedno poleg sporočila pošljemo še vektorsko uro
- kaj če gre kaj narobe?
	- algoritmi ratajo bolj zapleteni

### Modeli porazdeljenih sistemov

- ob predpostavki x, se reši na način y
- tipi predpostavk, kaj lahko pričakujemo, da se bo zgodilo
- 1. zanesljivost povezav:
	- peer-to-peer in broadcast - je sestavljen iz več peer-to-peer povezav (kar se teoretičnih modelov tiče, se gledajo povezave med dvema procesoma)
	- s sprejemljivimi izgubami - kdaj se nek paket izgubi ali pa lahko pride podvojen paket (UDP)
	- zanesljive povezave - v primeru, če se sporočilo izgubi, bo še enkrat poslano; če dobimo duplikat sporočila, bo eno ignorirano (TCP)
	- overovljene zanesljive povezave (TLS) - s certifikati potrdimo, da je pošiljatelj/prejemnik pravi
- 2. zanesljivost procesov:
	- bizantinski proces oz. proces z napakami - proces lahko laže; lahko dela, ampak drugače kot bi moral; pošilja neka zlonamerna sporočila (hrošči, napake, zlonamerna koda) 
	- obnovljivi procesi (crash recovery) - zaradi napake v programu nam je proces dol padel, ampak se lahko restarta in spet začne delati
	- neobnovljivi procesi (crash stop) - ko pade dol, se ne pobere več
	- v letalstvo se zato uporablja 3 procese in se zaupa večini (2 od 3)
- 3. časovna komponenta:
	- sinhroni model - pričakujemo, da bomo vedno dobili odgovor v nekem časovnem oknu; najlažje modelirati in programirati
	- asinhroni model - predpostavljamo, da ko enkrat pošljemo sporočilo, bomo enkrat (ne vemo kdaj) dobili odgovor nazaj; če ne vemo, kdaj bomo dobili odgovor, je težje sprogramirati, da program ne crasha ali čaka v neskončnost
	- delno sinhroni model - predpostavljamo, da se večino časa obnaša kot sinhroni model (dobivamo odgovore), kdaj se pa tudi zalomi in traja malo več časa za odgovor
- hočemo povezave s sprejemljivimi izgubami, obnovljive procese in delno sinhroni čas

- zakaj ne dobimo odgovora:
	- 1. request se je zgubil
	- 2. server je crashal
	- 3. reply se je izgubil
- detekcija napak:
	- preko pošiljanja sporočil
		- procesi komunicirajo s pošiljanjem sporočil - vedno rabimo nastaviti neko smiselno časovno okno, znotraj katerega pričakujemo odgovor - če odgovora ni, ponovno pošljemo sporočilo in če še vedno ne moremo nadaljevati, javimo napako
	- če nam je pomembno, da je komunikacija ves čas živa - periodično preverjanje:
		- ping - odjemalec pošlje ping in strežnik pošlje pong:
			- ne smemo imeti prekratkega timeouta, ker drugače lažno mislimo, da je server dol
			- če imamo predolg timeout, bomo predolgo čakali, čepravi je strežnik padel dol
		- srčni utrip - odjemalec ves čas pošilja svoj srčni utrip in strežnik ves čas pošilja svoj srčni utrip

### Replikacija

- za večjo zanesljivost - če en proces pade dol, lahko drug prevzame
- če imamo več procesov, ki nudijo isto storitev, lahko delo (requeste) porazdelimo med procese in bo sistem bolj odziven, hitrejši
- vsi procesi se morajo strinjati o stanju shrambe - konsenz
- za odjemalca mora biti vseeno, ali je kontaktiral en proces ali neko verigo procesov - porazdeljen sistem mora delovati kot eno
- kako zanesljivo doseči, da bodo imeli vsi procesi enako stanje:
	- deterministrični končni avtomati:
		- avtomat lahko prehaja med nekimi stanji
		- končno število stanj, vhodnih črk in izhodov
		- petorček: stanja, vhodne črke, izhodne črke, funkcija, ki zna na podlagi trenutnega stanja in vhodne črke prehajati v drugo stanje, funkcija, ki glede na trenutne stanje prižiga določene izhode
		- deterministično: je jasno, kaj se bo zgodilo glede na trenutno stanje in v vhod se vedno odločimo za isto naslednje stanje; na podlagi stanja bomo vedno imeli iste izhode
		- vedno se začne v istem začetnem stanju => če vsi dobivajo vhode v enakem zaporedju, bodo vsi prehajali v enaka stanja (lahko en malo zamuja)

### Verižna replikacija

- šele, ko je vpis potrjen v zadnjem členu verige, ga strežnik ne sme zares uporabiti
- karkoli nam odpove od vmesnih procesov, bomo še vedno lahko servirali tako pisatelju kot bralcu
