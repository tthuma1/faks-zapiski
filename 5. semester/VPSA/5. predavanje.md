- atomarne operacije:
	- zaporedje ukazov za branje, spreminjanje, pisanje se izvaja kot nedeljiva operacija
	- podpora mora biti dodana v sam procesor
	- test and set (TAS)
- ključavnice (mutex):
	- tip za ključavnico: `sync.Mutex`
- programski jeziki imajo lahko poseben tip za spremenljivke, ki jih je treba spreminjati atomarno

- ko uporabimo `lock.Lock()`, mora imeti gorutina za tisti kos pommnilnika ekskluziven dostop, zato postanemo počasnejši, kot brez zaklepanja, ampak dobimo pravilen rezultat:
	- želimo si čim manj kritičnih odsekov

- če ima CPU že vgrajeno atomarno operacijo za npr. seštevanje, je to bolje uporabiti - v enem koraku se zgodi zahtevanje, zaklepanje, prištevanje
- `atomic.Int64` so vgrajeni tipi za atomarne operacije

```go
		pi.shots.Add(1)
		if x*x+y*y < 1 {
			pi.hits.Add(1)
		}
```
- ^ to je počasneje od navadnega lock, ker tu dvakrat zaklepamo in odklepamo

- `pi-7.go`:
	- da manjkrat zaklenemo, lahko vsaka gorutina dela prištevanje na lokalni spremenljivki in samo enkrat zaklene kritično sekcijo na koncu, ko dodamo iz lokalne spremenljivke v globalno
- `pi-8.go`:
	- uporabimo tabelo, namesto lokalnih spremenljivk
	- je počasnejši od prejšnjega primera, ker imamo problem pri predpomnilniku
	- lažni skupni podatki (false sharing)
	- recimo, da imamo dve gorutini na dveh jedrih:
		- ko hoče prvo jedro prebrati številko, pride do zgrešitve in jo prebere iz glavnega pomnilnika in obdela, označi ta blok kot umazan
		- ko drugo jedro bere svojo vrednost, vidi, da je blok umazan in mora cel blok na novo prenesti v svoj predpomnilnik (čeprav ne bo uporabljala tiste vrednosti, ki jo je prvo jedro spremenilo)
		- jedri morata vedno prenašati podatke med predpomnilniki, ustvarimo veliko prometa na predpomnilniškem vodilu
	- rešitve:
		- slabo - naredimo daljšo tabelo, da bo pi od vsake gorutine v svojem predpomnilniškem bloku
		- uporaba lokalne spremenljivke - se shrani na sklad, zaradi česar Go te gorutine dovolj narazen alocira, da si ne mešajo predpomnilnika
- `pi-9.go`:
	- samo enkrat lahko pride do false sharing (samo na koncu, ko prirejamo na `*result`)

Dijkstrini filozofi:
- vilice so omejena dobrina, kot kritični odsek; vilice so ključavnica - ko vzame filozof ene ključavnice, jih zaklene in ko neha jesti, jih odklene
- `filozofi-2.go`:
	- vsi filozofijo zagrabijo eno svojo vilico in čakajo, da bo druga vilica prosta, ampak noben ne bo spustil svoje vilice - dobimo deadlock
	- deadlock se lahko zgodi vedno, ko imamo omejeno količino virov
	- vse gorutine čakajo druga na drugo; čakajo, da bo druga gorutina sprostila nek vir, ampak ta ne bo sprostila virov, dokler prva ne sprosti svojih in obratno
- do smrtnega objema pride, če veljajo Coffmanovi pogoji:
	- viri imajo omejeno število lastnikov
	- lastnik dobi en vir in čaka ostale vire
	- vire sprošča samo lastnik
	- krožna odvisnost med lastniki
- želimo, da filozof zgrabi obe vilici naenkrat, namesto, da čaka medtem ko pobere prvo in drugo:
	- `filozofi-3.go`:
		- dodamo še eno ključavnico, da samo en filozof naenkrat lahko pobira vilice
		- samo en filozof naenkrat lahko jemlje vilice
			- ni nam všeč, da dokler en filozof pobira vilice, ne more noben drug filozof pobirati vilic
- `filozofi-4.go`:
	- `lock.TryLock()`
	- vzamemo prvo vilico in probamo vzeti še drugo - če druge ne moremo vzeti, bomo prvo odložili, da jo bo lahko uporabila neka druga gorutina; sicer vzamemo drugo vilico in normalno delamo naprej
	- prvo vilico bomo ves čas prijemali in odlagali
	- grda rešitev
- ključavnice razvrstimo in od gorutin zahtevamo, da jih vedno pobirajo v istem vrstnem redu:
	- prej smo vedno najprej vzeli levo vilico in potem smo probali desno vilico
	- sedaj filozof 4 najprej vzame z desno roko, ostali pa najprej z levo roko - nimamo več krožne odvisnosti med lastniki, ker filozof 4 uniči krog; smo pretrgali krožno odvisnost
	- filozof 4 dovoli, da 3 vzame obe vilici
	- če imaš opravka z več ključavnicami jih vedno poskusiš oštevilčiti in poskrbiš, da jih vse jemljejo v istem vrstnem redu - če to res ne gre, uporabiš `TryLock`
- rešitev s kanali:
	- imamo kanal kapacitete 1 za vsako vilico
	- ko en filozof pošlje nekaj v kanal, zaklene vilico (noben drug ne more pisati v kanal, ker je pisanje blokirajoče in kanal poln brez poslušalca) in jo odklene, ko bere iz kanala
	- še vedno rabijo vsi folozofi jemati vilice v istem vrstnem redu, da nimamo krožne odvisnosti

- živi objem:
	- smrtni objem je Go znal detektirati, ker so se vse gorutine ustavile
	- imamo dva filozofa in eno gorutino, ki ves čas v en kanal piše, da pove filozofoma, kdaj naj zagrabita vilice
	- koda ves čas nekaj dela (obe gorutini nekaj počneta), ampak se ne moreta končati
	- oba hkrati zgrabita vilico in takoj odložita
- stradanje:
	- imamo greedy delavca, ki najprej vse zaklene, naredi vso delo in potem vse odklene
	- imamo prijaznega delavca, ki najprej zaklene en majhen del, potem drugi majhen del ...
	- greedy delavec manjkrat zaklepa in bo stradal prijaznega delavca
	- bomo prišli do konca, ampak nasilna gorutina bo večkrat prišla na vrsto
	- rešitev: pri vseh workerjih razdelimo locke na manjše dele; vedno imamo majhne kritične odseke

Pisatelji + bralci:
- imamo več pisateljev, ki pišejo poglavja in veliko bralcev, ki hočejo takoj brati novo poglavje
- ko pisatelji piše, bralci ne berejo; ko noben ne piše, bere več bralcev hkrati
- imamo ključavnico za knjigo
- gorutina od bralcev se bo zaključila skupaj z glavno, brez lepe pridružitve
- knjiga je omejena dobrina:
	- hkrati lahko piše samo en pisatelj
	- hkrati lahko bere več bralcev
	- ko začne en brati, lahko dodamo nove bralce
	- ko ni nobenega bralca, lahko pisatelj naprej piše
- rabimo števec, koliko bralcev imamo:
	- ko prištevamo bralce, mora biti prištevanje atomarno
	- zato poleg ključavnice za knjigo dodamo ključavnico za število bralcev
- `pisatelji-bralci-3.go`:
```go
		lockReaders.Lock()
		activeReaders++
		if activeReaders == 1 {
			lockBook.Lock()
		}
		lockReaders.Unlock()
```
- ^ pomembno je, da je `lockReaders.Unlock()` na koncu, ker bi se sicer lahko večkrat `activeReaders` povečal, preden bi ga primerjali z 1
- kršimo pravilo: če ključavnico zaklene ena nit, odklene pa druga, pridemo v nedefinirano stanje; tisti, ki zaklene ključavnico jo mora tudi odkleniti