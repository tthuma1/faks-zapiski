- atomarne operacije:
	- zaporedje ukazov za branje, spreminjanje, pisanje se izvaja kot nedeljiva operacija
	- podpora mora biti dodana v sam procesor
	- test and set (TAS)
- ključavnice (mutex):
	- tip za ključavnico: `sync.Mutex`
- programski jeziki imajo lahko poseben tip za spremenljivke, ki jih je treba spreminjati atomarno

- ko uporabimo `lock.Lock()`, mora imeti gorutina za tisti kos pommnilnika ekskluziven dostop, zato postanemo počasnejši, kot brez zaklepanja, ampak dobimo pravilen rezultat:
	- želimo si čim manj kritičnih odsekov

- če ima CPU že vgrajeno atomarno operacijo za npr. seštevanje, je to bolje uporabiti - v enem koraku se zgodi zahtevanje, zaklepanje, prištevanje
- `atomic.Int64` so vgrajeni tipi za atomarne operacije

```go
		pi.shots.Add(1)
		if x*x+y*y < 1 {
			pi.hits.Add(1)
		}
```
- ^ to je počasneje od navadnega lock, ker tu dvakrat zaklepamo in odklepamo

- `pi-7.go`:
	- da manjkrat zaklenemo, lahko vsaka gorutina dela prištevanje na lokalni spremenljivki in samo enkrat zaklene kritično sekcijo na koncu, ko dodamo iz lokalne spremenljivke v globalno
- `pi-8.go`:
	- uporabimo tabelo, namesto lokalnih spremenljivk
	- je počasnejši od prejšnjega primera, ker imamo problem pri predpomnilniku
	- lažni skupni podatki (false sharing)
	- recimo, da imamo dve gorutini na dveh jedrih:
		- ko hoče prvo jedro prebrati številko, pride do zgrešitve in jo prebere iz glavnega pomnilnika in obdela, označi ta blok kot umazan
		- ko drugo jedro bere svojo vrednost, vidi, da je blok umazan in mora cel blok na novo prenesti v svoj predpomnilnik (čeprav ne bo uporabljala tiste vrednosti, ki jo je prvo jedro spremenilo)
		- jedri morata vedno prenašati podatke med predpomnilniki, ustvarimo veliko prometa na predpomnilniškem vodilu
	- rešitve:
		- slabo - naredimo daljšo tabelo, da bo pi od vsake gorutine v svojem predpomnilniškem bloku
		- uporaba lokalne spremenljivke - se shrani na sklad, zaradi česar Go te gorutine dovolj narazen alocira, da si ne mešajo predpomnilnika
- `pi-9.go`:
	- samo enkrat lahko pride do false sharing (samo na koncu, ko prirejamo na `*result`)

Dijkstrini filozofi:
- vilice so omejena dobrina, kot kritični odsek; vilice so ključavnica - ko vzame filozof ene ključavnice, jih zaklene in ko neha jesti, jih odklene
- `filozofi-2.go`:
	- vsi filozofijo zagrabijo eno svojo vilico in čakajo, da bo druga vilica prosta, ampak noben ne bo spustil svoje vilice - dobimo deadlock
	- deadlock se lahko zgodi vedno, ko imamo omejeno količino virov
	- vse gorutine čakajo druga na drugo; čakajo, da bo druga gorutina sprostila nek vir, ampak ta ne bo sprostila virov, dokler prva ne sprosti svojih in obratno
- do smrtnega objema pride, če veljajo Coffmanovi pogoji:
	- viri imajo omejeno število lastnikov
	- lastnik dobi en vir in čaka ostale vire
	- vire sprošča samo lastnik
	- krožna odvisnost med lastniki