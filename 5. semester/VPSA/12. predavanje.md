- sporočila morajo prispeti v pravem vrstnem redu
- raft - skupina procesov, ki s soglašanjem pridejo do skupnega enakega stanja:
	- lahko dosežejo soglasje, če je več kot pol procesov še živih
	- en proces predlaga sebe za voditelja in ostali se strinjajo z njim
	- soglasje dosežejo kljub napakam
	- ni zunanjega procesa, ki bi jih dirigiral, ampak se vse zmenijo sami
	- delamo spremembe v shrambo in soglašamo na končno stanje
- drugi algoritmi: veriženje blokov, apache zookeeper

Apache Zookeper:
- ko pišemo nek algoritem, lahko apache uporabimo, da ne rabimo sami pisati algoritma za replikacijo
- imamo en glavni proces (zookeeper), ki ostalim procesom daje ključe v najem za določen čas
- takoj, ko nekdo dobi ključ, postane voditelj

- verižna replikacija: pišemo v glavo, beremo iz repa, ker ima rep prvi posodobljeno shrambo
- voditelj: vedno beremo in pišemo v voditelja:
	- pri pisanju: ko voditelj dobi več kot pol potrditev, potrdi zapis v shrambi
	- pri branju: proces mora najprej preveriti, če je on voditelj (oz. kdo je voditelj) - če sem jaz voditelj, potem iz shrambe vzame vrednost in jo posreduje odjemalcu; sicer reče odjemalcu kateri proces je voditelj
	- pisanje in branje nista trenutna dogodka

- včasih pri branju lahko rečemo, da bomo lahko brali tudi iz sledilcev - zato bomo veliko hitrejši, ampak mogoče ne dobimo čisto točnega odgovora

Vrste skladnosti:
- stroga skladnost:
	- vedno pri branju dobimo enak odgovor - vedno sprašujemo voditelja
	- voditelj je najbolj obremenjen
	- branje iz repa pri verižni replikaciji:
		- če ne beremo iz repa (beremo iz vmesnega vozlišča), potem rabi to vmesno vozlišče za nepotrjene zapise vprašati rep, kakšna je prava vrednost
	- počasna
- zaporedna skladnost:
	- replike se ne sinhronizirajo vedno v istem trenutku
	- oba odjemalca gresta čez isti vrstni red sprememb stanj, čeprav malo z zamikom
- končna skladnost:
	- ko se vsi vpisi enkrat nehajo, bodo vsi bralci prebrali isto vrednost
	- vmes ne vemo, kaj se nam dogaja
	- rabimo paziti pri pisanju odjemalcev
	- hitra

- teorem CAP (consistency, availability, partition tolerance):
	- lahko dosežemo dve od teh treh
	- če imamo vse raft procese v enem datacentru, potem je mreža zelo zanesljiva - tu velja teorem PACeLC (else latency, consistency)
	- če rabimo hitrost, znižamo zahtevo za skladnost
	- če nam je skladnost najbolj pomembna, bomo imeli počasnejšo bazo

- lahko pohitrimo tudi vpisovanje - ne gre samo preko enega procesa (voditelja ali glave), ampak gre lahko vpisovanje v shrambo tudi preko drugih procesov
- lahko pride do sporov (različna končna stanja)
- rabimo replikacijo brez sporov (CRDT - conflict free data type)
- namesto absolutnih `set` ukazov delamo relativne spremembe (povečaj x za y)
- monotoni registri
- večvrednostni registri
- ne moremo delati CRUD:
	- imamo samo vpisovanje, nimamo brisanja

### Broadcast

- kako zagotoviti pravi rstni red sporočil
- eden pošilja večim - multicast/broadcast

- dostava po najboljših močeh (best effort):
	- kot pri IP mutlicast
- zanesljiva dostava:
	- pošiljatelj ne dela multicast, ampak vsakemu posebej pošilja sporočilo
	- tudi ostali procesi morajo sodelovati pri pošiljanju sporočil
	- vsakič, ko nekdo prejme sporočilo, ga pošlje še vsem ostalim
	- nestrpno pošiljanje (eager) - n procesov => $O(n^2)$ paketov za vsako poizvedbo
- razširanje z govoricami:
	- tipično pošiljaš trem drugim
	- manj prometa - n procesov => $O(n)$ sporočil (3n)

### Vrstni red dostave

- v raft imamo dva končna avtomata:
	- proces in shramba sta končna avtomata
	- proces ima stanja sledilec, kandidat, voditelj
	- shramba ima stanja
- če želimo, da imajo vsi enako shrambo, morajo zahteve dobiti v enakem vrstnem redu
- dodamo upravljalnik sporočil, ki pakete razvrsti v pravi vrstni red