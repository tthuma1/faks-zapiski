Pisatelji in bralci:
- lepo je, če naredimo tako, da tista gorutina, ki zaklene ključavnico, jo tudi odklene
- v C je stanje nedefinirano, če ena nit zaklene ključavnico, druga pa odklene
- Go nam to sicer pusti, ampak ima potem probleme pri iskanju race conditionov
- uporabimo semaforje:
	- semaforji so definirani na nivoju OS
	- z njimi lahko kritične odseke varujemo v procesu in med procesi
	- ker deluje na nivoju OS, so počasnejši
	- podobno kot ključavnice, ampak so števni (nimamo samo 0 in 1, ampak lahko večje cifre)

```
če je sem > 0:
	sem--
če je sem == 0:
	čakaj
```
- izstop => `sem++`
- v Go nimamo semaforjev
- kako bi to rešili s kanali:
	- v kanale lahko piše in iz njih bere kdorkoli

- želimo si, da bralci ne stradajo pisateljev:
	- ko se pisatelj odloči, da bo pisal, mora imeti prednost pred bralci
	- če imamo bralce v vrsti, se mora pisatelj vriniti v vrsto
	- uporabimo `RWLock` - bralno-pisalno ključavnica:
		- `Lock` je močno - samo eden lahko vstopa
		- `RLock` - lahko jih vstopa več, ampak samo tisti, ki so na bralni način zaklenili ključavnico
	- uporabno za pisanje/branje v baze/loge; pri objektnem programiranju pri get/set

### Pregrada (barrier)

- glavna gorutina čaka, da se ostalee gorutine pridružijo, preden se zaključi:
	- uporabimo `WaitGroup`, v glavni gorutini `wg.Wait()`

Primer igra o življenju:
- vsaka gorutina obdela en trak polja
- preden gre katerakoli gorutina v stanje t+2, rabijo biti vse v stanju t+1
- uporabimo števec:
	- če je števec manjši kot je vseh gorutin, bomo čakali
	- ko je števec enak številu gorutin, nadaljujemo z izvajanjem - pred tem mora ena gorutina (glavna gorutina) števec ponastaviti (npr. gorutina z id 0)
	- imamo problem, če gre ena gorutina ven iz čakanja, na začetek `for` in poveča števec, potem pa glavna gorutina resetira števec - smo izgubili eno povečevanje števca in bomo za vedno čakali, da bo števec enak številu gorutin
- razdelimo pregrado na dve fazi (dvoje vrata):
	- hkrati so odprta samo ena vrata
	- gorutine najprej čakajo pred vrati 0, potem pred vrati 1 in spet pred vrati 0 ...
	- faza0 = vrata0 odklenjena - da se vrata 1 odklenejo, rabimo počakati, da vse gorutine pridejo do njih => potem bomo šli v fazo1
	- faza1 = vrata1 odklenjena - da se vrata 0 odklenejo, rabimo počakati, da vse gorutine pridejo do njih
	- 
	- Go bo želel, da ko imamo neko spremenljivko (števec), ki jo zaklenemo za povečevanje/zmanjševanje, potem rabimo tudi branje zakleniti - sicer nam prevajalnik lahko zamenja vrstni red operacij in ni več nujno, da bo branje na pravem mestu - zato rabimo lock pred `if g > 0` in pred `if g < gorutines`
	- če damo `--race`, bo Go opazil, da včasih v spremenljivko `phase` pišemo znotraj kritičnega območja in beremo izven njega:
		- dodamo še eno ključavnico okoli branja `phase` tako, da ga pred `for phase == 1 {}` preberemo v lokalno spremenljivko
		- lahko bi tudi uporabili `RWMutex`
- kako to rešiti s kanali:
	- imamo dva kanala za dve vrati
	- kapaciteta kanalov je 1 zato, da nekdo, ki sebe zaklene, lahko tudi sebe odklene
	- gorutine povečajo (ali zmanjšajo) števec in čakajo pred vrati (čakajo, da se v kanal nekaj zapiše)
	- zadnja gorutina za vse gorutine zapiše vrednost v kanal, da bodo šle vse gorutine lahko čez vrata do naslednjih vrat oz. na naslednjo iteracijo

### Pogojne spremenljivke (conditional variables)

- vedno so vezane na ključavnico

- najprej zaklene ključavnico
- Wait: odklenemo ključavnico in z Wait čakamo pogoj za nadaljevanje (signal ali broadcast)
- ko dobimo pogoj za nadaljevanje: zaklene ključavnico in nadaljuje
- odklene ključavnico
- ... to ponavljaj

- v bistvu smo to naredili pri dvofazni pregradi z lock

- signal:
	- spusti samo 1 gorutino
- broadcast:
	- spusti vse gorutine

- `var cond = sync.NewCond(&lock)`
- gorutine se postavljajo v vrsto in nadaljujejo v takem vrstnem redu:
	- ob `cond.Wait` se nam gorutine dajajo v vrsto
	- ob `cond.Broadcast` pogleda, koliko gorutin je v vrsti in samo tem dovoli naprej
	- če pride ena gorutina hitro na naslednjo iteracijo, bo morala čakati naslednji broadcast
	- samo enkrat damo signal za nadaljevanje, ob signalu gre prva gorutina oz. vse gorutine iz vrste naprej
- `cond.Wait` naredi unlock
- ta rešitev je boljša, ker gorutine ne berejo pogoja v while zanki in ne kradejo CPU časa - gorutina gre spat in ko dobi signal/broadcast, jo Gojev razvrščevalnik zbudi in gre naprej
- v nekaterih jezikih (C++) imamo direktno classe za barrier in samo daš `barrier.wait()`, ker je to pogost vzorec v znanstvenih simulacijah
- med čakajočimi gorutinami nadaljuje tista, ki najdlje čaka

### Proizvajalci in porabniki

- proizvajalci ne morejo dati stvari v skladišče, če je polno
- porabniki ne morajo izdelkov jemati iz skladišča, če je prazno
- lahko imamo krožno vrsto za skladišče:
	- imamo indeks, ki kaže na prvo prazno mesto v vrsti in indeks na izdelek, ki bo šel naslednji ven
	- hranimo število izdelkov, ki so trenutno v skladišču

- uporabimo pogojne spremenljivke - tu bomo namesto broadcast rabili signal
- ko proizvajalec proizvede nekaj, hoče dati v skladišče:
	- če je skladišče polno, mora počakati (`cond.Wait()`)
	- dajanje v skladišče je atomarna operacija - rabimo lock okrog
	- ko damo nekaj v skladišče, pošljemo signal porabniku, da lahko nekaj vzame
- za porabnika naredimo ravno obratno

- s tem smo v bistvu naredili kanal