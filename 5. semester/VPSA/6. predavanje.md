Pisatelji in bralci:
- lepo je, če naredimo tako, da tista gorutina, ki zaklene ključavnico, jo tudi odklene
- v C je stanje nedefinirano, če ena nit zaklene ključavnico, druga pa odklene
- Go nam to sicer pusti, ampak ima potem probleme pri iskanju race conditionov
- uporabimo semaforje:
	- semaforji so definirani na nivoju OS
	- z njimi lahko kritične odseke varujemo v procesu in med procesi
	- ker deluje na nivoju OS, so počasnejši
	- podobno kot ključavnice, ampak so števni (nimamo samo 0 in 1, ampak lahko večje cifre)

```
če je sem > 0:
	sem--
če je sem == 0:
	čakaj
```
- izstop => `sem++`
- v Go nimamo semaforjev
- kako bi to rešili s kanali:
	- v kanale lahko piše in iz njih bere kdorkoli

- želimo si, da bralci ne stradajo pisateljev:
	- ko se pisatelj odloči, da bo pisal, mora imeti prednost pred bralci
	- če imamo bralce v vrsti, se mora pisatelj vriniti v vrsto
	- uporabimo `RWLock` - bralno-pisalno ključavnica:
		- `Lock` je močno - samo eden lahko vstopa
		- `RLock` - lahko jih vstopa več, ampak samo tisti, ki so na bralni način zaklenili ključavnico
	- uporabno za pisanje/branje v baze/loge; pri objektnem programiranju pri get/set

### Pregrada (barrier)

- glavna gorutina čaka, da se ostalee gorutine pridružijo, preden se zaključi:
	- uporabimo `WaitGroup`, v glavni gorutini `wg.Wait()`

Primer igra o življenju:
- vsaka gorutina obdela en trak polja
- preden gre katerakoli gorutina v stanje t+2, rabijo biti vse v stanju t+1
- uporabimo števec:
	- če je števec manjši kot je vseh gorutin, bomo čakali
	- ko je števec enak številu gorutin, nadaljujemo z izvajanjem - pred tem mora ena gorutina (glavna gorutina) števec ponastaviti (npr. gorutina z id 0)
	- imamo problem, če gre ena gorutina ven iz čakanja, na začetek `for` in poveča števec, potem pa glavna gorutina resetira števec - smo izgubili eno povečevanje števca in bomo za vedno čakali, da bo števec enak številu gorutin