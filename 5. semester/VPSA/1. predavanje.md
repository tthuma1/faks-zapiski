- porazdeljeni sistem: program teče na več računalniških sistemih
- vzporedni: več niti, ki se izvajajo hkrati; en program teče na več nitih, ker so vsi moderni CPE večnitni

- do okoli 2004 se hitro razvija nižanje clock speeda, večanje gostote tranzistorjev, manjšanje napajalne napetosti - potem boljša rešitev za pohitritev programov postane softwareska s paralelizacijo
- Dennardovo pravilo: zmanjšanje velikosti tranzistorja na pol, poveča njihovo število za štirikrat na isti površini, povezave med tranzistorji ratajo manjše
- Moorov zakon: vsako leto in pol se število tranzistorjev podvoji
- okoli 130W se da ohlajati, potem delovanje CPE postane nezanesljivo
- ![500](../../Images4/Pasted%20image%2020251002084658.png)
- nekateri prevajalniki sami lahko pogruntajo, da se dajo neki deli paralelizirati, ampak to ne dela tako dobro:
	- lahko damo prevajalniku namige, da lahko nek del paralelizira in jih potem razdeli med več niti
	- knjižnice za npr. Python
	- Go ima mehanizme za paralelizacijo vključene v osnovo jezika

- pri dveh jedrih porabimo 0,43 moči kot pri enem jedru:
	- lahko privarčujemo z energijo, kar hočemo pri npr. telefonih
	- če želimo imeti porabo energije konstantno, bomo lahko več zračunali z isto količino energije - zmogljivejši stroj
	- ko imamo paralelni sitem je to težje programirati, nikoli ne dobimo idealne razporeditve nalog, zato pridobitev v realnosti ni tako velika

- uporaba superračunalnikov:
	- simulacija fizike, medicine, trki osnovnih delcev
	- simulacija vetrovnika za karoserijo avtomobila
	- simulacija turbin v hidroelektrarni
	- učenje modelov umetne inteligence
	- za veliko od teh stvari je v superračunalnikih dobro imeti veliko grafičnih kartic (poleg večjedrnih procesorjev), ker jih dosti operacij zna izkoriščati

- porazdeljeni sistemi:
	- torrent
	- content delivery network
	- RAID diski
	- neka storitev je porazdeljena med več celinami, da je hitreje dostopna - baze med strežniki morajo biti čim bolj sinhronizirane; nek strežnik nam pove, na kateri strežnik naj se sploh usmerimo
	- podatkovne baze znajo delati na več strežnikih, za to rabimo algoritme, ki to znajo zanesljivo sinhronizirati

- kontrolna enota:
	- prižiga krmilne signale za ostale enote
- registri:
	- za nas bosta pomambna PC in stack pointer
- izvedba ukaza:
	- fetch iz pomnilnika, decode, dobivanje operandov iz pomnilnika in registrov, execute v ALE (vzame operande iz registrov), write back v pomnilnik
- problem: pomnilniško ozko grlo, ker je CPE veliko hitrejši od pomnilnika:
	- rešitev: pomnilniška hierarhija (predpomnilnik)
	- predpomnilniki so fizično direktno na CPE, zavzemajo približno pol plošče od procesorja

- cache je podprt v HW, navidezni pomnilnik je softwareski (OS)
- navidezni pomnilnik:
	- stanje nekaterih aplikacij začasno shranjujemo na disk

- procesor gre za operande pogledati v predpomnilnik:
	- najprej gre pogledati L1, potem L2 ...
	- če je tam, dobimo cache hit in gre operand v register
	- če ga ni tam, imamo cache miss in gremo v glavni pomnilnik - ko najdemo podatek, v predpomnilnik prenesemo cel blok podatkov (pomnilniški blok), ker je zelo verjetno, da bomo kmalu rabili sosednje podatke

- ko je predpomnilnik poln, moramo enega izmed blokov iz predpomnilnika zamenjati:
	- reakcija je odvisna od tipa predpomnilnika
	- tipi predpomnilnikov:
		- asociativni - menjaj karkoli
		- direktni - od položaja bloka v glavnem pomnilniku dobimo položaj v predpomnilniku
		- set asociativni - glede na naslov v glavnem pomnilniku dobiš set možnih naslovov v predpomnilniku

- če pišemo v predpomnilnik, moramo potem to zapisati v glavni pomnilnik:
	- write through - takoj zapišemo v glavni pomnilnik
	- write back - zapišemo v glavni pomnilnik preden vržemo blok ven iz predpomnilnika (to si označimo z dirty bitom)

- cache miss nas drago stane, ampak jih je dosti malo (ker računamo na pomnilniško lokalnost), da se nam vseeno splača uporabiti predpomnilnik

- ostale izboljšave (brez da programer spreminja program):
	- cevovod:
		- en ukaz razbije na več enostavnejših korakov, ki se lahko hkrati izvajajo
		- npr. računanje v plavajoči vejici
		- vsak korak mora biti približno enako težek
		- če ima cevovod N stopenj, nam N-krat pohitri izvajanje
	- vektorske enote:
		- če imamo nek vektor (seznam) z neodvisnimi elementi, lahko operacije nad posameznimi elementi delamo vzporedno
	- funkcijske enote:
		- imamo npr. dva množilnika
	- špekulativno izvajanje:
		- pri pogojnih skokih predvidimo rezultat pogoja
		- paralelno računamo pogoj in rezultat, če se zmotimo pri predikciji pogoja, moramo narediti rollback, sicer smo že izračunali kar rabimo
		- za to skrbi prevajalnik
	- superskalarnost:
		- procesor analizira N ukazov in če ugotovi, da dva zaporedna ukaza uporabljata različni funkcijski enoti, jiju lahko izvaja hkrati na obeh enotah
		- za to skrbi CPE, dinamično analizira ukaze
	- strojne niti:
		- imamo dva ukazna toka, ki sta med sabo neodvisna (CPE ne rabi preverjati, ali so ukazi med nitni zares neodvisni)
		- ne pride prav, če obe niti delata enako stvar, ker bi potem obe niti zasedli iste funkcijske enote
		- če obe niti delata različne stvari, profitiramo

- najprej so bili vektorski superračunalniki, danes so gruče:
	- gruča - imamo več računalnikov, ki jih povežemo v mrežo; sicer dobimo malo manjšo računsko moč, ampak je veliko bolj enostavno in poceni