### Virtualizacija
- zakaj?:
	- če imamo hkrati več uporabnikov oz. aplikacij, ki delajo različne stvari, jih rabimo ločiti med sabo
	- imamo en močen server, na katerem teče več ločenih aplikacij
- z navideznimi stroji (VM) delimo strojno opremo med različne navidezne stroje
- hypervisorji (nadzornik VM):
	- ESXi, proxmox, HyperV
	- na nadzornika dodajamo VM-je
- VM-ji imajo lahko različni OS
- VM-ji nudijo zelo močno izolacijo:
	- VM-ji se med sabo ne vidijo
	- na njih rabimo namestiti OS, gonilnike ipd.; vsak ima svoje, ne morejo si jih deliti
	- ne delijo si npr. datotečnega sistema
	- če se eden sesuje, bodo ostali delali naprej
- vsakemu VM-ju lahko natančno določimo, koliko virov lahko porabi
- slabosti:
	- rabimo veliko režije, težje je premikati, backupirati stvari; datoteke VM-jev so zelo velike
	- dosti časa traja, da se prižge, ker se prižiga enako kot normalen računalnik - isto z ustavljanjem
	- težje je skalirati - če imamo aplikacijo v VM in dobimo ogromno uporabnikov, bomo enkrat prišli do tega, da ne moremo povečati enega VM-ja, ampak rabimo več VM-jev (horizontalno skaliramo), ki se počasi postavljajo (traja dolgo časa, ko poženemo nov VM, da bo naša aplikacija dejansko začela teči na njem)
	- zato za serviranje oblačnih rešitev to ni najbolje
- če rabimo neko grafično aplikacijo, je nujno, da imamo VM
- Windows na ARM:
	- rabimo ARM verzijo ali pa uporabimo translation layer (počasneje)
- ker se VM-ji počasi zaganjajo in ugašajo, niso primerni za cloud storitve

- uporabimo kontejnerje (vsebnike), kot način lažje virtualizacije

Vsebniki:
- koristno za mikrostoritve
- lahko bi npr. pri verižni replikaciji ne delali direktno s procesi, ampak z vsebniki
- damo stran OS iz virtualizacije - vsi kontejnerji si delijo jedro matičnega OS
- vseniki ne vključujejo celotnega OS, ampak samo knjižnice in aplikacije
- v glavnem imamo Linux za matični OS
- v OS imamo kernel space in user space
- v matičnem OS imamo že gonilnike, ki jih vsebniki lahko uporabijo
- izolacija med vsebniki ni tako dobra kot med VM - če se nek vsebnik čudno obnaša, nam lahko podre tudi ostale vsebnike; čeprav je to bolj redko
- ne moremo delati GUI v vsebnikih
- lahko vsebnik zasnujemo na drugi distribuciji Linuxa, ker je kernel enak
- hitreje se prižge in ugasne kot VM
- virov ne razdelimo vnaprej (ne moremo omejiti npr. količino RAM v enem vsebniku)
- lažje prenosljiv kot VM
- zakaj sploh:
	- izolacija knjižnic in aplikacij - noter lahko damo katerokoli knjižnico želimo
	- na gruči nam mora administrator naložiti Go, da ga lahko kjerkoli uporabljamo, ker mi ne moremo inštalirati stvari na matičen OS - v vsebnike lahko inštaliramo karkoli hočemo
	- če neko aplikacijo zapakiramo v vsebnik, bomo zraven povedali vse knjižnice, ki jih rabi in bo uporabnik to lahko takoj zagnal pri sebi
	- če damo uporabniku damo navodila za aplikacijo, ki ni v vsebniku in rabi sam naložiti neke knjižnice, bo to težje ali pa če tvoj app rabi eno verzijo knjižnice, nek drug app pa drugo verzijo, potem si tega sploh ne bo mogel namestiti, ker ne more imeti dveh različnih verzij knjižnice hkrati - v vsebnikih ima lahko vsak vsebnik svojo verzijo knjižnice

Razvoj:
- chroot v Linux, jail v FreeBSD
- lxc - linux containerji
- docker
- rabimo orkestracijo za zaganjanje - kubernetes
- apptainer - podobno kot docker
- pri Docker nadzornik vsebnikov reče kot servis (ima root pravice); pri Apptainer pa kot aplikacija
- pri Docker je primarna izolacija (vsebniki so maksimalno izolirani); pri Apptainer je bolj pomembna integracija - pred povezavo na gručo nam nekdo dovoli dostop in nam potem bolj zaupa s tistim, kar lahko delamo
- za gruče Docker ni primeren, ker se servis Docker bori za vire s servisom SLURM; Apptainer je bolje za gručo

Kako narediti vsebnik:
- vzamemo kakšnega iz dockerhub
- da povemo, katere knjižnice naj uporablja, napišemo recept
- apptainer zna prebrati recept iz dockerhub in narediti svoj vsebnik
- ne moremo pa vzeti docker vsebnika in ga zagnati z apptainer, ker je image format drugačen - samo recepti so (skoraj) enaki in iz njih zgradimo ustrezen image file
- ko imamo enkrat apptainer vsebnik zgrajen (ko imamo image file) ga lahko zaženemo na različnih računalnikih z apptainerjem, brez da bi ga od začetka gradili