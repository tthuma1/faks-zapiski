- RPC od Go, vsi deli morajo biti napisani v Go (strežnik in odejmalec)
- gRPC je bolj splošen za vse programske jezike:
	- dela prek programskega vmesnika protocolBuffers
	- vmesnik skrije vso logiko glede pošiljanja in prejemanja sporočil, zato na odjemalcu klic funkcije zgleda skoraj enako kot če bi lokalno funkcijo klicali
	- preko HTTP
	- kličejo "stub" metode - na naši strani je metoda samo klic na strežnik, ampak se obnaša, kot da zares zna delati
	- `context` opisuje povezavo - npr. kdaj naj naredi timeout klicev

Protocol buffers:
- da je bolj kompakten, se polja v structih zakodirajo kot številke (kot enum)

### Algoritmi v porazdeljenih sistemih

Čas:
- pri remote klicih rabimo določiti timeout
- priprava loggov
- realni čas (wallclock time):
	- zanima nas, ko delamo logge
- procesorski čas (CPU time):
	- koliko časa se je naš proces dejansko izvajal na CPU
	- običajno krajši od realnega časa
	- če večkrat poženemo program, bo CPU time večinoma isti, realni čas pa različen

Fizične ure:
- noter je quartz kristal, ki niha s konstantno frekvenco:
	- frekvenca variira od temperature, proizvodnega procesa
	- natančnost delovanja ure se meri z zdrsom ure (drift) - $\frac{\mu s}{s}$, PPM (parts per million)
	- zamik ure (napaka)
- quartz je poceni, bolj natančna je atomska ura:
	- gledamo nihanja atoma cezij-133
	- drift $\pm$ 1s/3 leta
	- TAI (time atomic international) - dela povprečje 300 ur
	- to se npr. uporablja v satelitih za GPS, da natančno merijo čas preleta
- astronomska ura:
	- težko povedati, koliko točno časa traja eno leto
	- prestopna leta
	- prestopne sekunde, da sinhroniziramo astronomsko uro in atomsko uro - 30.6. ali 31.12. $\pm$ 1s - se uvede skozi cel dan, ne takoj (par milisekund naenkrat se dodaja)
- Unix ura:
	- v sekundah od 1.1.1970
	- v Windows v sekundah od 1.1.1601
	- ne upoštevata prestopnih sekund

- kvartz vmes popravljamo, da je bolj točen, kar nam lahko pokvari zaporedje loggov, če se ura popravi nazaj
- monotona ura:
	- nikoli je ne popravljamo nazaj, ampak jo samo opočasnimo
	- lahko jo uporabljamo samo znotraj enega procesa - če bi gledali med več procesi, se lahko drugače hitro popravlja in ne bo OK

Primer:
- `timeElapsed` = štoparica, ki vedno šteje monotono
- ko v Go izpišemo čas, nam izpiše realni čas in monotoni čas - na začetku procesa je monotoni čas enak 0
- če izračunamo čas iz nanosekund, bo malo drugače, ker monotoni čas drugače hitro teče

Sinhronizacija časa med računalniki:
- NTP prek UDP, vrata 123
- pri računanju
- če je $|\Theta| < 125 ms$, potem uro popravi takoj
- če je $125ms <= |\Theta| < 1000s$, potem uro popravi postopoma proti ciljnemu času (npr. naslednjih 5 minut bo moja ura malo hitrejša, da pridem do cilja)
- če je $1000s <= |\Theta|$, potem ne popravi ure (moramo najprej ročno uro na približno nastaviti)
- NTP struktura:
	- settings - leap second, version, mode
	- stratum - manjši stratum je pomembnejši (natančnejši)
	- vsak NTP strežnik ima svoj ID, ker če želimo natančen čas, bomo najbrž komunicirali z več strežniki naenkrat
	- referenčni čas - kdaj je strežnik zadnjič popravil svojo uro
	- t1 = original, t2 = Rx, t3 = Tx
	- odjemalec si svoj t1 zapiše v Tx, potem ga strežnik prestavi v original
	- odjemalec svoj t1 in prejeti t1 lahko primerja, da se ujema (da ni strežnik nekaj čudnega spremenil)
	- fractional del - da lahko merimo npr. pol sekunde
- `nanos := (int64(frac) * 1e9) >> 32` => $\frac{\text{frac} \cdot 10^9}{2^{32}}$
- t1 na odjemalcu ima monotoni čas, t1, ki ga dobimo nazaj, pa ne, ker nam nič več ne pomeni
- v realnosti si lahko sinhroniziramo uro na nekaj milisekund:
	- pri loggih se nam lahko zgodi, da to ni dovolj natančno

- natančnost na milisekunde ni dovolj dobra za sisteme, ki zahtevajo natančnost (npr. logging ne bo dovolj točen)
- pri izmenjavi sporočil hočemo čim bolj točne ure

Logične ure:
- delajo glede na dogodke
- imamo relacijo prej-potem glede na dogodke - X se je zgodil pred Y
- Lamportova ura:
	- imamo števce, ki merijo dogodke
	- vsakič, ko se dogodek zgodi, se ura poveča
	- dogodek, ki se je zgodil pred prejemom sporočila, ima gotovo nižjo uro
	- znamo napisati log; časom lahko dodamo še oznako procesa
	- primer: ne moremo primerjati procesov A in C, ker si nista izmenjali nič sporočil (ne vemo, ali je C1 pred ali za A1)
	- zaporedje znamo povedati vedno, ko pride do izmenjave sporočil
	- če sta dva dogodka vzročno povezana, bo imel kasnejši dogodek višjo uro
	- problem: ne znamo dobro primerjati dogodkov z istim števcem
- vektorska ura:
	- elementov v vektorju je toliko, kot je procesov v komunikaciji
	- procesi lahko povečujejo samo svoj števec, ne pa števcev od drugih procesov
	- vse račune delamo po vseh elementih vektorja
	- bolj zahtevne za pomnilnik in pasovno širino
	- lahko ugotovimo, ali je en dogodek pred drugim in ali da sta dva dogodka sočasna
	- če so vsi števci enaki, razen eden je manjši, potem se je dogodek zgodil pred drugim - če to ne drži, potem sta dogodka sočasna
	- sočasnost je zelo približno - dokler dva dogodka ne začneta komunicirati med sabo, sta sočasna
- imamo pravilen logičen redosled dogodkov
- lahko zraven dodamo še čas, da lahko logično sočasne dogodke malo bolj točno sortiramo, čeprav ta sort mogoče ne bo popoln:
	- logična (vektorska) ura ima prioriteto, potem gledamo še realni čas