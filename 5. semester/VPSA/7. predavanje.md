### Varna sočasnost (concurrency-safe, thread safe)

Primer slovar:
- pridemo v tvegano stanje, če se hkrati piše in bere v slovar - tudi, če na različnih ključih
- če imamo sočasne bralce in pisalce, načeloma stvar dela, ampak se ne moremo zanesti na prevajalnik, da nam ne bo tako premešal operacij, da ne bo več v redu
- načeloma je pisanje na indeks 0 neodvisno od pisanja na indeks 1, ampak mi tega ne moremo zares vedeti, zato moramo zakleniti vsa dela (vsa pisanja in branja) s slovarjem
- uporabimo read-write lock, ker imamo na eni strani pisanje, na drugi pa branje
- namesto navadnega slovarja, bo bolje če uporabimo `sync.Map`:
	- precej bolj splošna struktura - ključ in vrednost sta lahko karkoli
	- bolj kompleksna in zato tudi počasnejša struktura

Naključna števila:
- so v bistvu pseudo-naključna
- podamo seme in če bomo imeli isto seme, bomo dobili ista števila
```
r = seed
rand() {
	r = f(seed)
}
```
- `math/rand` v Go je varno za sočasnost
- pri Go rand ne moremo podati semena (vzame trenutni čas v ns)
- seme hočemo, da lahko ponovimo rezultat - `rnd = rand.New(rand.NewSource(*sPtr))`
- sedaj moramo zakleniti vsak `rnd.Float64()`:
	- sedaj se nam pri Pi lahko zgodi, da je vrstni red generiranja med gorutinami lahko drugačen - če imamo dve gorutini, lahko prva naredi x,y in druga x,y ALI prva naredi x, druga x, prva y, druga y - lahko dobimo drugačen vrstni red generiranja, zaradi česar bo rezultat drugačen
	- tudi če x in y damo pod en lock, še ne bo čisto v redu
	- rešitev: naredimo lokalen rnd v `piCalc`, kjer ima vsak svoje seme
- nočemo semena iz trenutnega časa, ker se lahko zgodi, da se dve gorutini zaženeta v isti nanosekundi in bosta imeli enako seme, fino je dodati neko razlikovanje po gorutinah

- vedno poskusi poiskati rešitev brez zaklepanja, ker bo hitreje

### Porazdeljeni sistemi

- pri porazdeljenih sistemih pridejo vsi problemi vzporednega izvajanja bolj do izraza
- sistemi s porazdeljenim pomnilnikom
- komunicirajo prek omrežja
- eno vozlišče nima neposrednega dostopa do pomnilnika drugega vozlišča
- vozlišča si morajo pošiljati sporočila
- vozlišče je lahko fizični računalnik, ali pa proces:
	- proces znotraj OS je izoliran, ima svoj pomnilnik, do katerega drugi procesi ne morejo dostopati
	- procesi si izmenjujejo sporočila

- oddajnik in sprejemnik se morata zavedati sporočila
- mreža nam doda kompleksnost - lahko se kaj izgubi
- če se en računalnik (eno vozlišče) pokvari, smo v težavah - želimo, da je naša aplikacija še vedno uporabna
- porazdeljene aplikacije:
	- podatkovne baze se lahko porazdelijo na več računalnikov
	- internet

Zakaj sploh?
- zanesljivost - imamo kopijo, če npr. pri bazi en disk odpove, jih imamo še nekje shranjene:
	- pri npr. kontrola leta - potrojeni sistemi, če da en drugačno rešitev od drugih dveh, se vzame rešitev večine (2 out of 3)
- obvladovanje velikih poslov:
	- nekatere znanstvene simulacije so tako kompleksne, da je preveč za en stroj
	- npr. v CERN-u trki naredijo toliko podatkov, da jih moramo porazdeliti med več računalnikov
- velika zmogljivost:
	- npr. google search dobi toliko vnosov, da ne more en računalnik vsega obdelati
	- npr. streaming filmov - porazdelitev baz s filmi po celinah, da hitreje pridejo do končnih uporabnikov

Izzivi:
- obvladovanje napak:
	- več kot dodamo vozlišč, večja je verjetnost, da bo kakšna komponenta odpovedala
	- rabimo sistem za detekcijo in reševanje napak
	- če se eno vozlišče pokvari, želimo, da ostala to zaznajo in znajo nadaljevati
- komunikacija med vozlišči:
	- kako zaznati in reševati napake pri prenosu sporočil
	- varnost v omrežju
- uskaljevanje oz. koordinacija med vozlišči:
	- npr. en proces čaka na podatke drugega procesa, ker brez njih ne mora nadaljevati
	- če eno vozlišče odpove, se morajo ostala uskladiti, npr. vodilno vlogo prevzame drugo vozlišče in ko se pokvarjeno vozlišče vrne, spet postane glavno; ko se vrne, mu morajo ostali povedati, kako mora posodobiti svoje podatke
- raztegljivost/skalabilnost:
	- kako se naš sistem spopada z povečevanjem obremenitve CPE, pomnilnika, pasovne širine
	- uporabnika zanima, kako je sistem odziven - koliko uporabnikov (zahtev) lahko sistem postreže v neki časovni enoti
	- prepustnost, odzivni časi
	- kdaj bo sistem tako obremenjen, da ne bo moral več strči zahtevam - ko pridemo do te točke, moramo dodati strežnike
	- moramo znati tudi skrčiti sistem, ko število uporabnikov pade, da ne plačujemo preveč za elektriko
- odpornost:
	- kljub temu, da prihaja do napak, ki jih znamo zaznati, mora biti sistem robusten in zna delati tudi v situacijah, ko nam kaj odpove
	- npr. sistem mora delati 99,99% časa
- vzdrževanje:
	- včasih je z vzdrževanjem več dela kot s postavitvijo
- mi bomo delali predvsem komunikacijo, usklajevanje in odpornost

Zgradba porazdeljenega sistema:
- imamo skupino naprav, ki komunicirajo prek omrežja
- skupina procesov, ki po uveljavljenih mehanizmih za medprocesorsko komunikacijo, komunicirajo (npr. po protokolih TCP/UDP, HTTP, REST, RPC)
- vsak proces je neka storitev; storitve so šibko sklopljene in komunicirajo med sabo prek aplikacijskih vmesnikov
- mi bomo rekli, da imamo strežnik in odjemalec:
	- posamezen proces je lahko strežnik za nekoga in odjemalec za nekoga drugega (npr. en del hkrati odjemalec za podatkovno bazo in strežnik za končne uporabnike)

- uporabniški vmesnik je ločen proces, da ne prekinja naših gorutin
- sistem je ločen na več delov - lahko več ljudi dela na različnih delih

- obe strani morata pravilno upoštevati komunikacijski protokol
- ![500](../../Images4/Pasted%20image%2020251113102022.png)
- TCP zagotavlja zanesljivost
- pri pošiljatelju se enkapsulira sporočila, potem se pri prejemniku dekapsulira