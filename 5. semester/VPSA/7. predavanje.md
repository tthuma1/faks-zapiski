### Varna sočasnost (concurrency-safe, thread safe)

Primer slovar:
- pridemo v tvegano stanje, če se hkrati piše in bere v slovar - tudi, če na različnih ključih
- če imamo sočasne bralce in pisalce, načeloma stvar dela, ampak se ne moremo zanesti na prevajalnik, da nam ne bo tako premešal operacij, da ne bo več v redu
- načeloma je pisanje na indeks 0 neodvisno od pisanja na indeks 1, ampak mi tega ne moremo zares vedeti, zato moramo zakleniti vsa dela (vsa pisanja in branja) s slovarjem
- uporabimo read-write lock, ker imamo na eni strani pisanje, na drugi pa branje
- namesto navadnega slovarja, bo bolje če uporabimo `sync.Map`:
	- precej bolj splošna struktura - ključ in vrednost sta lahko karkoli
	- bolj kompleksna in zato tudi počasnejša struktura

Naključna števila:
- so v bistvu pseudo-naključna
- podamo seme in če bomo imeli isto seme, bomo dobili ista števila
```
r = seed
rand() {
	r = f(seed)
}
```
- `math/rand` v Go je varno za sočasnost
- pri Go rand ne moremo podati semena (vzame trenutni čas v ns)
- seme hočemo, da lahko ponovimo rezultat - `rnd = rand.New(rand.NewSource(*sPtr))`
- sedaj moramo zakleniti vsak `rnd.Float64()`:
	- sedaj se nam pri Pi lahko zgodi, da je vrstni red generiranja med gorutinami lahko drugačen - če imamo dve gorutini, lahko prva naredi x,y in druga x,y ALI prva naredi x, druga x, prva y, druga y - lahko dobimo drugačen vrstni red generiranja, zaradi česar bo rezultat drugačen
	- tudi če x in y damo pod en lock, še ne bo čisto v redu
	- rešitev: naredimo lokalen rnd v `piCalc`, kjer ima vsak svoje seme
- nočemo semena iz trenutnega časa, ker se lahko zgodi, da se dve gorutini zaženeta v isti nanosekundi in bosta imeli enako seme, fino je dodati neko razlikovanje po gorutinah

- vedno poskusi poiskati rešitev brez zaklepanja, ker bo hitreje

### Porazdeljeni sistemi

- pri porazdeljenih sistemih pridejo vsi problemi vzporednega izvajanja bolj do izraza
- sistemi s porazdeljenim pomnilnikom
- komunicirajo prek omrežja
- eno vozlišče nima neposrednega dostopa do pomnilnika drugega vozlišča
- vozlišča si morajo pošiljati sporočila
- vozlišče je lahko fizični računalnik, ali pa proces:
	- proces znotraj OS je izoliran, ima svoj pomnilnik, do katerega drugi procesi ne morejo dostopati
	- procesi si izmenjujejo sporočila

- oddajnik in sprejemnik se morata zavedati sporočila
- mreža nam doda kompleksnost - lahko se kaj izgubi
- če se en računalnik (eno vozlišče) pokvari, smo v težavah - želimo, da je naša aplikacija še vedno uporabna
- porazdeljene aplikacije:
	- podatkovne baze se lahko porazdelijo na več računalnikov
	- internet

Zakaj sploh?
- zanesljivost - imamo kopijo, če npr. pri bazi en disk odpove, jih imamo še nekje shranjene:
	- pri npr. kontrola leta - potrojeni sistemi, če da en drugačno rešitev od drugih dveh, se vzame rešitev večine (2 out of 3)
- obvladovanje velikih poslov:
	- nekatere znanstvene simulacije so tako kompleksne, da je preveč za en stroj
	- npr. v CERN-u trki naredijo toliko podatkov, da jih moramo porazdeliti med več računalnikov
- velika zmogljivost:
	- npr. google search dobi toliko vnosov, da ne more en računalnik vsega obdelati
	- npr. streaming filmov - porazdelitev baz s filmi po celinah, da hitreje pridejo do končnih uporabnikov

Izzivi:
- obvladovanje napak:
	- več kot dodamo vozlišč, večja je verjetnost, da bo kakšna komponenta odpovedala
	- rabimo sistem za detekcijo in reševanje napak
	- če se eno vozlišče pokvari, želimo, da ostala to zaznajo in znajo nadaljevati
- komunikacija med vozlišči:
	- kako zaznati in reševati napake pri prenosu sporočil
	- varnost v omrežju
- uskaljevanje oz. koordinacija med vozlišči:
	- npr. en proces čaka na podatke drugega procesa, ker brez njih ne mora nadaljevati
	- če eno vozlišče odpove, se morajo ostala uskladiti, npr. vodilno vlogo prevzame drugo vozlišče in ko se pokvarjeno vozlišče vrne, spet postane glavno; ko se vrne, mu morajo ostali povedati, kako mora posodobiti svoje podatke