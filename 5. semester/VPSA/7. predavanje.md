### Varna sočasnost (concurrency-safe, thread safe)

Primer slovar:
- pridemo v tvegano stanje, če se hkrati piše in bere v slovar - tudi, če na različnih ključih
- če imamo sočasne bralce in pisalce, načeloma stvar dela, ampak se ne moremo zanesti na prevajalnik, da nam ne bo tako premešal operacij, da ne bo več v redu
- načeloma je pisanje na indeks 0 neodvisno od pisanja na indeks 1, ampak mi tega ne moremo zares vedeti, zato moramo zakleniti vsa dela (vsa pisanja in branja) s slovarjem
- uporabimo read-write lock, ker imamo na eni strani pisanje, na drugi pa branje
- namesto navadnega slovarja, bo bolje če uporabimo `sync.Map`:
	- precej bolj splošna struktura - ključ in vrednost sta lahko karkoli
	- bolj kompleksna in zato tudi počasnejša struktura

Naključna števila:
- so v bistvu pseudo-naključna
- podamo seme in če bomo imeli isto seme, bomo dobili ista števila
```
r = seed
rand() {
	r = f(seed)
}
```
- `math/rand` v Go je varno za sočasnost
- pri Go rand ne moremo podati semena (vzame trenutni čas v ns)
- seme hočemo, da lahko ponovimo rezultat - `rnd = rand.New(rand.NewSource(*sPtr))`
- sedaj moramo zakleniti vsak `rnd.Float64()`:
	- sedaj se nam pri Pi lahko zgodi, da je vrstni red generiranja med gorutinami lahko drugačen - če imamo dve gorutini, lahko prva naredi x,y in druga x,y ALI prva naredi x, druga x, prva y, druga y - lahko dobimo drugačen vrstni red generiranja, zaradi česar bo rezultat drugačen
	- tudi če x in y damo pod en lock, še ne bo čisto v redu
	- rešitev: naredimo lokalen rnd v `piCalc`, kjer ima vsak svoje seme
- nočemo semena iz trenutnega časa, ker se lahko zgodi, da se dve gorutini zaženeta v isti nanosekundi in bosta imeli enako seme, fino je dodati neko razlikovanje po gorutinah

- vedno poskusi poiskati rešitev brez zaklepanja, ker bo hitreje