### Varna sočasnost (concurrency-safe, thread safe)

Primer slovar:
- pridemo v tvegano stanje, če se hkrati piše in bere v slovar - tudi, če na različnih ključih
- če imamo sočasne bralce in pisalce, načeloma stvar dela, ampak se ne moremo zanesti na prevajalnik, da nam ne bo tako premešal operacij, da ne bo več v redu
- načeloma je pisanje na indeks 0 neodvisno od pisanja na indeks 1, ampak mi tega ne moremo zares vedeti, zato moramo zakleniti vsa dela (vsa pisanja in branja) s slovarjem
- uporabimo read-write lock, ker imamo na eni strani pisanje, na drugi pa branje
- namesto navadnega slovarja, bo bolje če uporabimo `sync.Map`:
	- precej bolj splošna struktura - ključ in vrednost sta lahko karkoli
	- bolj kompleksna in zato tudi počasnejša struktura

Naključna števila:
- so v bistvu pseudo-naključna
- podamo seme in če bomo imeli isto seme, bomo dobili ista števila
```
r = seed
rand() {
	r = f(seed)
}
```
- `math/rand` v Go je varno za sočasnost
- pri Go rand ne moremo podati semena (vzame trenutni čas v ns)
- seme hočemo, da lahko ponovimo rezultat - `rnd = rand.New(rand.NewSource(*sPtr))`
- sedaj moramo zakleniti vsak `rnd.Float64()`:
	- sedaj se nam pri Pi lahko zgodi, da je vrstni red generiranja med gorutinami lahko drugačen - če imamo dve gorutini, lahko prva naredi x,y in druga x,y ALI prva naredi x, druga x, prva y, druga y - lahko dobimo drugačen vrstni red generiranja, zaradi česar bo rezultat drugačen
	- tudi če x in y damo pod en lock, še ne bo čisto v redu
	- rešitev: naredimo lokalen rnd v `piCalc`, kjer ima vsak svoje seme
- nočemo semena iz trenutnega časa, ker se lahko zgodi, da se dve gorutini zaženeta v isti nanosekundi in bosta imeli enako seme, fino je dodati neko razlikovanje po gorutinah

- vedno poskusi poiskati rešitev brez zaklepanja, ker bo hitreje

### Porazdeljeni sistemi

- pri porazdeljenih sistemih pridejo vsi problemi vzporednega izvajanja bolj do izraza
- sistemi s porazdeljenim pomnilnikom
- komunicirajo prek omrežja
- eno vozlišče nima neposrednega dostopa do pomnilnika drugega vozlišča
- vozlišča si morajo pošiljati sporočila
- vozlišče je lahko fizični računalnik, ali pa proces:
	- proces znotraj OS je izoliran, ima svoj pomnilnik, do katerega drugi procesi ne morejo dostopati
	- procesi si izmenjujejo sporočila

- oddajnik in sprejemnik se morata zavedati sporočila
- mreža nam doda kompleksnost - lahko se kaj izgubi
- če se en računalnik (eno vozlišče) pokvari, smo v težavah - želimo, da je naša aplikacija še vedno uporabna
- porazdeljene aplikacije:
	- podatkovne baze se lahko porazdelijo na več računalnikov
	- internet

Zakaj sploh?
- zanesljivost - imamo kopijo, če npr. pri bazi en disk odpove, jih imamo še nekje shranjene:
	- pri npr. kontrola leta - potrojeni sistemi, če da en drugačno rešitev od drugih dveh, se vzame rešitev večine (2 out of 3)
- obvladovanje velikih poslov:
	- nekatere znanstvene simulacije so tako kompleksne, da je preveč za en stroj
	- npr. v CERN-u trki naredijo toliko podatkov, da jih moramo porazdeliti med več računalnikov
- velika zmogljivost:
	- npr. google search dobi toliko vnosov, da ne more en računalnik vsega obdelati
	- npr. streaming filmov - porazdelitev baz s filmi po celinah, da hitreje pridejo do končnih uporabnikov

Izzivi:
- obvladovanje napak:
	- več kot dodamo vozlišč, večja je verjetnost, da bo kakšna komponenta odpovedala
	- rabimo sistem za detekcijo in reševanje napak
	- če se eno vozlišče pokvari, želimo, da ostala to zaznajo in znajo nadaljevati
- komunikacija med vozlišči:
	- kako zaznati in reševati napake pri prenosu sporočil
	- varnost v omrežju
- uskaljevanje oz. koordinacija med vozlišči:
	- npr. en proces čaka na podatke drugega procesa, ker brez njih ne mora nadaljevati
	- če eno vozlišče odpove, se morajo ostala uskladiti, npr. vodilno vlogo prevzame drugo vozlišče in ko se pokvarjeno vozlišče vrne, spet postane glavno; ko se vrne, mu morajo ostali povedati, kako mora posodobiti svoje podatke
- raztegljivost/skalabilnost:
	- kako se naš sistem spopada z povečevanjem obremenitve CPE, pomnilnika, pasovne širine
	- uporabnika zanima, kako je sistem odziven - koliko uporabnikov (zahtev) lahko sistem postreže v neki časovni enoti
	- prepustnost, odzivni časi
	- kdaj bo sistem tako obremenjen, da ne bo moral več strči zahtevam - ko pridemo do te točke, moramo dodati strežnike
	- moramo znati tudi skrčiti sistem, ko število uporabnikov pade, da ne plačujemo preveč za elektriko
- odpornost:
	- kljub temu, da prihaja do napak, ki jih znamo zaznati, mora biti sistem robusten in zna delati tudi v situacijah, ko nam kaj odpove
	- npr. sistem mora delati 99,99% časa
- vzdrževanje:
	- včasih je z vzdrževanjem več dela kot s postavitvijo
- mi bomo delali predvsem komunikacijo, usklajevanje in odpornost

Zgradba porazdeljenega sistema:
- imamo skupino naprav, ki komunicirajo prek omrežja
- skupina procesov, ki po uveljavljenih mehanizmih za medprocesorsko komunikacijo, komunicirajo (npr. po protokolih TCP/UDP, HTTP, REST, RPC)
- vsak proces je neka storitev; storitve so šibko sklopljene in komunicirajo med sabo prek aplikacijskih vmesnikov
- mi bomo rekli, da imamo strežnik in odjemalec:
	- posamezen proces je lahko strežnik za nekoga in odjemalec za nekoga drugega (npr. en del hkrati odjemalec za podatkovno bazo in strežnik za končne uporabnike)

- uporabniški vmesnik je ločen proces, da ne prekinja naših gorutin
- sistem je ločen na več delov - lahko več ljudi dela na različnih delih

- obe strani morata pravilno upoštevati komunikacijski protokol
- ![500](../../Images4/Pasted%20image%2020251113102022.png)
- TCP zagotavlja zanesljivost s potrditvami:
	- imamo timeout
	- če prejemnik dvakrat dobi isti paket, ga ignorira
- s CRC preverjamo za napake
- TLS dodamo nad TCP za šifriranje vsebine
- pri pošiljatelju se enkapsulira sporočila, potem se pri prejemniku dekapsulira
- med IP in TCP je medpomnilnik - če je medpomnilnik poln, odjemalec to pove strežniku, da počasneje pošilja:
	- pri vsakem prenosu sporočil, odjemalec pove, koliko ima še medpomnilnika

Vtičnice (socket):
- za pošiljanje podatkov med procesi
- vmesnik med transportno in aplikacijsko plastjo
- vključuje naslov vozlišča (IP), vrata in protokol
- odjemalec se priklopi na strežnik in ko je priklopljen, je vzpostavljena seja, znotraj katere lahko komunicirata:
	- pasivni partner = strežnik; pripravi vtičnico
	- aktivni partner = odjemalec; se poskusi povezati na vtičnico
	- ko je povezava vzpostavljena, sta strežnik in odjemalec enakovredna - vsak lahko vsakemu pošilja podatke; imamo obojesmeren promet
- postopek:
	- 1. odpiranje povezave
	- 2. povezava vzpostavljena:
		- nadzor pretoka - ko pošiljatelj nekaj pošlje, prejemnik pove, koliko ima še predpomnilnika; če prejemnik prejme paket in ga shrani v medpomnilnik, pošlja ACK
		- nasičenost omrežja: lahko pošljemo npr. 5 paketov naenkrat, tudi če nismo še dobili vseh ACK - congestion windows - imamo lahko več ali manj paketov naenkrat nepotrjenih (večje ali manjše okno)
	- 3. zapiranje povezave:
		- povezava se ne zapre takoj - lahko imamo več paketov še nepotrjenih, zato še malo počakamo
		- problem če hitro odpiramo in zapiramo povezave - lahko mislimo, da je povezava zaprta, čeprav ni in nam strežnik reče, da imamo preveliko število odprtih povezav
		- če veliko pošiljamo, potem v TCP povezavo držimo odprto, namesto da jo ves čas zapiramo in odpiramo

Primer:
- za vsakega odjemalce, ki se bo povezal na strežnik, se bo pognala svoja gorutina (`handleRequest`)
- za vsakega odjemalca imamo svojo povezavo
- `listener.Accept()` - strežnik čaka, dokler se nekdo ne poveže nanj
- `conn.Read(bMsgRecv)` - strežnik čaka, dokler ne dobi sporočila od odjemalca
- `connection.Write` - pošiljanje sporočila