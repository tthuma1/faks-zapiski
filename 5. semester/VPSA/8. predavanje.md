- prej smo uporabljali TCP - zagotavlja zanesljiv prenos podatkov, da se noben paket ne izgubi
- vsi paketi so oštevilčeni - če kakšen manjka, bo čakal in naprej posredoval v pravem vrstnem redu; če imata dva paketa isto številko, ve, da gre za duplikat
- vsa sporočila imajo crc kodo
- za varnost (šifriranje) TCP-ju dodamo TLS
- vzpostavljamo sejo (povezavo) med odjemalcem in strežnikom:
	- večfazno vzpostavljanje, preverjanje med prenosom in večfazno zapiranje

UDP:
- precej bolj enostaven od TCP
- nima povezav (sej)
- ne označuje paketov, nima nadzora nad vsebino, ali se je kateri paket izgubil - zato je bistveno hitrejši
- za npr. video streaming, online igre

primer `tcp-strukture.go`:
- povezave sprejmemo sekvenčno, ampak, ko imamo povezavo, jih obdelujemo vzporedno
- `gob` paket - naredi encoding (pri pošiljanju) ali decoding (pri prejemanju)
- s strukturami je bolj elegantno delati kot z nizi za izmenjavo sporočil, ki imajo več delov
- `err = gob.NewEncoder(conn).Encode(&msgSend)` - hkrati encodira in pošlje po povezavi

- TCP je za nas dokaj nizko nivojski
- radi bi, da gorutine, ki se izvajajo na oddaljenem računalniku obravnavamo enako, kot gorutine na lokalnem računalniku - želimo knjižnico, da se ne rabimo ukvarjati s TCP
- REST, RPC, gRPC
- CRUD

Primer REST:
- JSON format
- pri metodah lahko brez kazalcev delamo samo, če samo beremo strukturo - če jo želimo spremnijati, rabimo kazalec
- `TodoStorage` ima ključavnico - da onemogočimo hkratno spreminjanje strukture (npr. onemogočimo hkrati dva create; hkrati delete in update na bazi)
- prej smo ključavnice uporabljali znotraj enega procesa - sedaj je ključavnica v bazi, zato še vedno ostane znotraj enega procesa na strežniku in v redu dela

- želimo, da odjemalec sploh ne ve, da dela na oddaljeni shrambi
- REST, RESTful:
	- nabor standardnih metod GET, POST, PUT, DELETE
- bolj prilagojeni vmesniki, hitrejši, bolj robustni:
	- gRPC standarden, splošen
	- RPC - specifičen za Go
- komunikacija med odjemalcem in strežnikom je lahko neposredna, lahko pa imamo vmes message broker (posrednik):
	- strežnik se lahko odloča, katero sporočilo bo vzel iz message brokerja
	- če strežnik pade dol, se bodo sporočila še vedno zbirala na brokerju
- sinhrona in asinhrona komunikacija:
	- sinhrona:
		- pokličemo zahtevo in pričakujemo odgovor
		- medtem, ko čakamo, ne moremo nadaljevati
	- asinhrono:
		- odjemalec pokliče zahtevo na strežniku in ko strežnik zaključi, pokliče nazaj odjemalca
		- lahko vmes nadaljujemo v drugi gorutini in v eni gorutini bo odjemalec reagiral na povratni klic (callback)
- idempotentne zahteve:
	- lahko se zgodi, da od strežnika ne dobimo odgovora in mu potem pošljemo več istih zahtev - strežnik bo hkrati dobil več istih zahtev
	- nič se ne spremeni, ali odjemalec enkrat kliče zahtevo ali večkrat (CRUD):
		- problem edino za create - če pod istim ključem ne moremo imeti več zapisov, potem je to idempotentno; če bi imel pod enim ključem več verzij vrednosti, potem ne bi bilo idempotentno

- marshalling in unmarshalling:
	- serializacija strukture, ime metode, argumentov (prstni odtis funkcije moramo na ustrezen način zapisati z vsemi argumenti in potem to poslati)
	- funkcijski klic spremeni v obliko, da se lahko serializira in pošlje; na strežniku se deserializira in unmarshalla
	- marshalling samo pove, kaj bomo zakodirali - to se bo kasneje serializiralo, da se lahko pošlje po žici

- pri klicu lahko pride do napake, če mreža pade dol

- razvoj RPC:
	- SunRPC, CORBA, PROM
	- SOAP z XML
	- AJAX
	- REST z JSON
	- gRPC (binarni)

REST:
- vmesnik je RESTful, če implementira vse metode
- obdelave nimajo stanja - vedno rabimo poslati vse argumente, ne moremo jih poslati v dveh korakih
- je sinhrono - pošljemo zahtevo in po nekaj časa dobimo odgovor
- temelji na HTTP - zahteve pošiljamo zaporedno in čakamo eno za drugo
- url: `https://localhost:1234/vir/objekt?filtri`
- glava in telo:
	- v glavi metapodatki
	- v telesu so podatki
- POST, GET, PUT, DELETE = create, read, update, delete

Primer REST:
- v handlerju privzamemo, da je body v JSON in pravilno formatiran

RPC:
- Go-jev integriran paket
- če s držimo konvencij, ki jih Go zahteva za RPC, potem nam jih Go avtomatsko predstavi kot vmesnik (imena z veliko začetnico, metode z dvema argumentoma ...)
- prijavljanje metod: `rpc.Register(storage)`

gRPC:
- REST hoče zahteva-odgovor, je tekstoven
- pri gRPC želimo imeti podporo za tokove (streaming) in binarno kodiranje
- če želimo splošen protokol, rabimo nek način za serializacijo, ki bo podprt v vseh jezikih - ProtocolBuffers (nič ni povezano z bufferji):
	- v opisni datoteki opišemo:
		- strukture
		- metode
		- datoteke imajo končnico `*.proto`
	- po parsanju `*.proto` dobimo dve datoteki `*.go` (eno datoteko za vsako stran vmesnik)
	- sem dodamo našo kodo in vse skupaj spet z Go prevedemo, da dobimo executable
- `.proto`:
	- z `repeated` povemo, da imamo array
	- znotraj strukture se cifre ne smejo ponavljati
- `grpcClient.Create(contextCRUD, &lecturesCreate)` - ta metoda je stub - noter ni nič, razen klica na remote funkcijo in čakanje na rezultat