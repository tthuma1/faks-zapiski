- prej smo uporabljali TCP - zagotavlja zanesljiv prenos podatkov, da se noben paket ne izgubi
- vsi paketi so oštevilčeni - če kakšen manjka, bo čakal in naprej posredoval v pravem vrstnem redu; če imata dva paketa isto številko, ve, da gre za duplikat
- vsa sporočila imajo crc kodo
- za varnost (šifriranje) TCP-ju dodamo TLS
- vzpostavljamo sejo (povezavo) med odjemalcem in strežnikom:
	- večfazno vzpostavljanje, preverjanje med prenosom in večfazno zapiranje

UDP:
- precej bolj enostaven od TCP
- nima povezav (sej)
- ne označuje paketov, nima nadzora nad vsebino, ali se je kateri paket izgubil - zato je bistveno hitrejši
- za npr. video streaming, online igre

primer `tcp-strukture.go`:
- povezave sprejmemo sekvenčno, ampak, ko imamo povezavo, jih obdelujemo vzporedno
- `gob` paket - naredi encoding (pri pošiljanju) ali decoding (pri prejemanju)
- s strukturami je bolj elegantno delati kot z nizi za izmenjavo sporočil, ki imajo več delov
- `err = gob.NewEncoder(conn).Encode(&msgSend)` - hkrati encodira in pošlje po povezavi

- TCP je za nas dokaj nizko nivojski
- radi bi, da gorutine, ki se izvajajo na oddaljenem računalniku obravnavamo enako, kot gorutine na lokalnem računalniku - želimo knjižnico, da se ne rabimo ukvarjati s TCP
- REST, RPC, gRPC
- CRUD

Primer REST:
- JSON format
- pri metodah lahko brez kazalcev delamo samo, če samo beremo strukturo - če jo želimo spremnijati, rabimo kazalec
- `TodoStorage` ima ključavnico - da onemogočimo hkratno spreminjanje strukture (npr. onemogočimo hkrati dva create; hkrati delete in update na bazi)
- prej smo ključavnice uporabljali znotraj enega procesa - sedaj je ključavnica v bazi, zato še vedno ostane znotraj enega procesa na strežniku in v redu dela

- želimo, da odjemalec sploh ne ve, da dela na oddaljeni shrambi
- REST, RESTful:
	- nabor standardnih metod GET, POST, PUT, DELETE
- bolj prilagojeni vmesniki, hitrejši, bolj robustni:
	- gRPC standarden, splošen
	- RPC - specifičen za Go
- komunikacija med odjemalcem in strežnikom je lahko neposredna, lahko pa imamo vmes message broker (posrednik):
	- strežnik se lahko odloča, katero sporočilo bo vzel iz message brokerja
	- če strežnik pade dol, se bodo sporočila še vedno zbirala na brokerju
- sinhrona in asinhrona komunikacija:
	- sinhrona:
		- pokličemo zahtevo in pričakujemo odgovor
		- medtem, ko čakamo, ne moremo nadaljevati
	- asinhrono:
		- odjemalec pokliče zahtevo na strežniku in ko strežnik zaključi, pokliče nazaj odjemalca
		- lahko vmes nadaljujemo v drugi gorutini in v eni gorutini bo odjemalec reagiral na povratni klic (callback)
- idempotentne zahteve:
	- lahko se zgodi, da od strežnika ne dobimo odgovora in mu potem pošljemo več istih zahtev - strežnik bo hkrati dobil več istih zahtev
	- nič se ne spremeni, ali odjemalec enkrat kliče zahtevo ali večkrat (CRUD):
		- problem edino za create - če pod istim ključem ne moremo imeti več zapisov, potem je to idempotentno; če bi imel pod enim ključem več verzij vrednosti, potem ne bi bilo idempotentno

- marshalling in unmarshalling:
	- serializacija strukture, ime metode, argumentov (prstni odtis funkcije moramo na ustrezen način zapisati z vsemi argumenti in potem to poslati)
	- funkcijski klic spremeni v obliko, da se lahko serializira in pošlje; na strežniku se deserializira in unmarshalla

- pri klicu lahko pride do napake, če mreža pade dol

- razvoj RPC:
	- SunRPC, CORBA, PROM
	- SOAP z XML
	- AJAX
	- REST z JSON
	- gRPC (binarni)

REST:
- vmesnik je RESTful, če implementira vse metode
- obdelave nimajo stanja - vedno rabimo poslati vse argumente, ne moremo jih poslati v dveh korakih
- je sinhrono - pošljemo zahtevo in po nekaj časa dobimo odgovor
- temelji na HTTP - zahteve pošiljamo zaporedno in čakamo eno za drugo
- url: `https://localhost:1234/vir/objekt?filtri`
- glava in telo:
	- v glavi metapodatki
	- v telesu so podatki
- POST, GET, PUT, DELETE = create, read, update, delete

Primer REST:
- v handlerju privzamemo, da je body v JSON in pravilno formatiran