- kako se izognemo deadlocku
	- `tryLock` - prvo ključavnico lahko normalno zaklenemo, vse naslednje pa s `tryLock` - če faila, sprostiš vse ključavnice
	- ali pa če problem dopušča, ključavnice uredimo in jih vedno zaklepamo v istem vrstnem redu

- bralno-pisalne ključavnice:
	- hkrati ali več bralcev ali več pisateljev
	- nadomestimo lahko z navadnimi ključavnicami (ampak potem se zgodi, da ključavnico odklene druga nit, kot jo je zaklenila) ali pa s semaforji (v Go semaforje naredimo s kanali)

- dve gorutini povečujeta isti števec
```go
var counter int = 0
var sync chan struct{} = make(chan struct{})
var lock chan struct{} = make(chan struct{}, 1)

func worker() {
	for i := 0; i < 100000; i++ {
		lock <- struct{}{}
		counter++
		<-lock
	}
	sync <- struct{}{}
}

func main() {
	go worker()
	go worker()
	
	<-sync
	<-sync
	
	fmt.Println(counter)
}
```


- RPC:
	- imamo definicijo metode, ki jo poznata odjemalec in strežnik
	- iz definicije se zgenerira koda
	- metoda se izvaja na strežniku in vrne rezultat odjemalcu
	- na odjemalcu klic metode izgleda zelo podobno, kot če bi bila lokalna metoda, ampak ta klic samo pošlje zahtevo strežniku

- branje iz vseh vozlišč pri verižni replikaciji:
	- pri bralni zahtevi bo proces vrnil zapis, če ni označen kot umazan; če je označen kot umazan, bo prosil rep za zadnjo potrjeno verzijo
	- dirty bit ne bi bil v redu - uporabljamo verzije (različice) zapisa
	- problem rešimo tako, da bit umazan/čist nadomestimo z uvedbo različic zapisov (verzioniranje)

- modeli dostave:
	- FIFO: če je nek proces oddal več sporočil, jih bodo vsi ostali procesi dobili v istem vrstnem redu, kot jih je oddal
	- vzročno: če imamo sočasna sporočila, vrstni red prejema ni pomemben; 