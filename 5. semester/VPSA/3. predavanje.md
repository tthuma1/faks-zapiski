Golang:
- samo for zanke
- zasnovan za vzporednost - vse je naloga (goroutine)
- prevaja v zbirnik
- nima razredov; ni dedovanja, ampak lahko na podatkovne tipe vežemo metode
- strog prevajalnik
- vzporedno teče garbage collector

Model CSP:
- enota, ki zna sprejeti vhode; sekvenčni program; enota za izhod
- procesi med seboj komunicirajo s pošiljanjem sporočil
- če proces čaka na nekaj v vhodu, nič drugega ne more delati
- uporabno, ker ljudje pogosto tako razmišljamo, da si nalogo sestavimo na več manjših delov, ki si pošiljajo sporočila

Model opravilo-kanal oz. naloga-kanal:
- naloga = goroutine
- v Go teče programski razvrščevalnik, vedno imamo naloge, nikoli niti
- kanali so blokirajoči (signal blokira izvajanje goroutine):
	- s kanali lahko naredimo, da naloga čaka na nek vhod (asinhrono izvajanje)
	- tiste goroutine, ki se lahko izvajajo, se bodo, ostale pa bodo čakale, da bodo ustrezni podatki na voljo v kanalu

Moduli na gruči:
- vsa programska oprema v modulih
- `module load Go`

Go:
- inicializacija modula: `go mod init pozdrav`
- `go build pozdrav-1.go && .pozdrav-1`
- `go run pozdrav-1.go` => compile + run
- `go hello()` - naredi fork() za nalogo
- `waitGroup` = števec, ki ga ena gorutina naenkrat lahko zmanjša oz. poveča
- `wg.Wait()` = počakaj, da bo števec enak 0
- `wg.Done()` = odštej 1
- `wg.Add(1)` = prištej 1
- `defer wg.Done()` = Done izvedi na koncu te funkcije; ideja je, da tega ne pozabiš na koncu; če je več deferov, se bo prvi klical tisti, ki je bil zadnji napisan
- nimamo vpliva nad tem, kdaj se katera gorutina izvaja - to se bo odločil programski razvrščevalnik:
	- če dve gorutini pišeta na isti terminal, se morata čakati za vir terminala - dejanski izpis mogoče ni zares izraz tega, kako se gorutini izmenjujeta
- če želimo, da glavna gorutina nekaj dela, ne samo da čaka, da se ostali dve končata, lahko zaženemo `hello()` brez `go` in bo tudi glavna gorutina nekaj izpisovala

Kanali za komunikacijo med gorutinami:
- za prenašanje podatkov med gorutinami in sinhronizacijo gorutin
- tipi kanalov (podatkovni tip):
	- dvosmerni `var kanal chan string`
	- samo za branje `var kanal_r <-chan string`
	- samo za pisanje `var kanal_w chan<- string`
- rabimo povedati, kakšen tip podatkov bomo pošiljali v kanal
- inicializacija kanala:
	- `kanal = make(chan string)`
	- `kanal = make(chan string, val)` - z `val` povemo, koliko je prostora v kanalu
- načeloma uporabljamo dvosmerne kanale; če npr. neka funkcija vrne kanal, bomo raje vrnili kanal samo za branje: `kanal_r = kanal`
- pisanje v kanal:
	- `kanal <- "zapis"`
- branje iz kanala:
	- `niz <- kanal`

- go zna opaziti, če glavna gorutina čaka v nedogled, ker noben ne bo nič zapisal v kanal in nam da deadlock error; ugotovi, da vse gorutine čakajo (all goroutines are asleep), ampak nič ne bodo dočakale
```
	for i := 0; i < printouts; i++ {
		msg := <-stringStream
		fmt.Print(msg, " ")
	}
```
- ^ kanali so blokirajoči, zato bo `msg` čakal toliko časa, dokler se v kanalu nekaj ne pojavi
- če naredimo `i < printouts + 1`, bo Go vse iz kanala izpisal, potem pa bo ugotovil, da ne bo nič več prišlo noter v kanal in da bo glavna gorutina čakala v neskončnost - deadlock

- kanal po default nima nobenega medpomnilnika, kamor bi lahko stvari shranjeval - kapaciteta je 0 => v tem primeru se lahko stvari pošiljajo samo, če že imamo nekoga, ki posluša na kanalu (če je bralec že priprabljen):
	- enako kot bi rekli `var kanal = make(chan string, 0)`
	- če bralca ni, bo pisanje čakalo, dokler bralec ne prebere vrednosti

- `defer close(stringStream)` => zapri kanal na koncu fukcije
- vedno lahko beremo iz zaprtega kanala
- `msg, ok := <-stringStream` => `ok` nam bo povedal, ali je kanal odprt ali ne (true = odprt, false = zaprt)

```
	for msg := range stringStream {
		fmt.Print(msg, " ")
	}
```
- ^ beri iz kanala dokler je odprt, ko se zapre pojdi naprej

- ponavadi naredimo tako, da vsaka gorutina naredi svoj kanal in ga na koncu zapre