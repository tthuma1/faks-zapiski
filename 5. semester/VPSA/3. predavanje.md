Golang:
- samo for zanke
- zasnovan za vzporednost - vse je naloga (goroutine)
- prevaja v zbirnik
- nima razredov; ni dedovanja, ampak lahko na podatkovne tipe vežemo metode
- strog prevajalnik
- vzporedno teče garbage collector

Model CSP:
- enota, ki zna sprejeti vhode; sekvenčni program; enota za izhod
- procesi med seboj komunicirajo s pošiljanjem sporočil
- če proces čaka na nekaj v vhodu, nič drugega ne more delati
- uporabno, ker ljudje pogosto tako razmišljamo, da si nalogo sestavimo na več manjših delov, ki si pošiljajo sporočila

Model opravilo-kanal oz. naloga-kanal:
- naloga = goroutine
- v Go teče programski razvrščevalnik, vedno imamo naloge, nikoli niti
- kanali so blokirajoči (signal blokira izvajanje goroutine):
	- s kanali lahko naredimo, da naloga čaka na nek vhod (asinhrono izvajanje)
	- tiste goroutine, ki se lahko izvajajo, se bodo, ostale pa bodo čakale, da bodo ustrezni podatki na voljo v kanalu

Moduli na gruči:
- vsa programska oprema v modulih
- `module load Go`

Go:
- inicializacija modula: `go mod init pozdrav`
- `go build pozdrav-1.go && .pozdrav-1`
- `go run pozdrav-1.go` => compile + run
- `go hello()` - naredi fork() za nalogo
- `waitGroup` = števec, ki ga ena gorutina naenkrat lahko zmanjša oz. poveča
- `wg.Wait()` = počakaj, da bo števec enak 0
- `wg.Done()` = odštej 1
- `wg.Add(1)` = prištej 1
- `defer wg.Done()` = Done izvedi na koncu te funkcije; ideja je, da tega ne pozabiš na koncu; če je več deferov, se bo prvi klical tisti, ki je bil zadnji napisan
- nimamo vpliva nad tem, kdaj se katera gorutina izvaja - to se bo odločil programski razvrščevalnik:
	- če dve gorutini pišeta na isti terminal, se morata čakati za vir terminala - dejanski izpis mogoče ni zares izraz tega, kako se gorutini izmenjujeta
- če želimo, da glavna gorutina nekaj dela, ne samo da čaka, da se ostali dve končata, lahko zaženemo `hello()` brez `go` in bo tudi glavna gorutina nekaj izpisovala

Kanali za komunikacijo med gorutinami:
- za prenašanje podatkov med gorutinami in sinhronizacijo gorutin
- tipi kanalov (podatkovni tip):
	- dvosmerni `var kanal chan string`
	- samo za branje `var kanal_r <-chan string`
	- samo za pisanje `var kanal_w chan<- string`
- rabimo povedati, kakšen tip podatkov bomo pošiljali v kanal
- inicializacija kanala:
	- `kanal = make(chan string)`
	- `kanal = make(chan string, val)` - z `val` povemo, koliko je prostora v kanalu
- načeloma uporabljamo dvosmerne kanale; če npr. neka funkcija vrne kanal, bomo raje vrnili kanal samo za branje: `kanal_r = kanal`
- pisanje v kanal:
	- `kanal <- "zapis"`
- branje iz kanala:
	- `niz <- kanal`