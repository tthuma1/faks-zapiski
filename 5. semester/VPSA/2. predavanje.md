Sistemi s skupnim pomnilnikom:
- več jeder, kjer ima vsako jedro svoj predpomnilnik (vsaj L1; L2 je lahko deljen ali ne; L3 je že deljen)
- temu rečemo UMA - vsa procesorska jedra rabijo enako časa, da dostopajo do pomnilnika
- če dve jedri dostopata do istega naslova naenkrat, se bosta morali čakati
- rečemo tudi SMP (symmetric multiprocessor)
- težave:
	- ni raztegljiva, smo omejeni s številom jeder (pod 10)

Problem skladnosti predpomnilnikov:
- dve jedri nek podatek cachata in eno jedro ga spremeni v cachu, v drugem predpomnilniku pa je še vedno star podatek
- write through in write back za pisanje v glavni pomnilnik
- write through:
	- takoj ob spremembi zapišemo tudi v glavni pomnilnik
	- ob tem lahko ostali predpomnilniki vidijo, da se ta naslov spreminja, ker je vse na skupnem vodilu in razveljavi svoj podatek (lahko bi tudi takoj vzel nov podatek, ampak ponavadi samo razveljavi starega)
	- ustvari veliko prometa na vodilu - do okoli 4 jedra

NUMA (Non Uniform Memory Access):
- še vedno imamo enovit naslovni postor (isti kos pomnilnika vedno naslovimo z istim naslovom)
- vsi procesorji lahko dostopajo do kateregakoli kosa pomnilnika
- dostopni časi niso več vedno enaki:
	- če do svojega pomnilnika rabiš 1 enoto, boš rabil do ostalih 2 do 3 enote
- lahko tudi naredimo, da si več jeder deli en pomnilnik, in je potem razdeljen med skupinami jeder (več jeder isto hitro dostopa do enega kosa pomnilnika)
- uporabimo write back:
	- imamo D (direktorij) pomnilnik, ki nam pove, kaj se je zgodilo z nekim delom pomnilnika
	- MESI zastavice - modified, exclusive, shared, invalidated:
		- modified - ko spremeniš
		- exclusive - samo za en procesor
		- shared - ima ga več procesorjev (nek drug procesor ga je prebral v svoj cache)
		- invalidated - en procesor je spremenil pri svojem cachu, zato ga moraš razveljaviti pri sebi
	- vsakič, ko želi procesor brati podatek, mora najprej v direktoriju pogledati zastavice
- manj obremeni vodilo - lahko dodamo več jeder

Sistemi s porazdeljenim pomnilnikom:
- prvi superračunalniki so bili vektorski - lahko skupaj delajo nad več elementi vektorja (tabele), npr. hkrati sešteješ vse elemente dveh vektorjev na istoležnih indeksih:
	- so super za znanstvene simulacije, ampak razvoj je drag
	- ugotovijo, da osebni računalniki v bistvu niso tako slabi
- kupimo več osebnih računalnikov in jih povežemo skupaj v mrežo:
	- rabiš še software, ki zna naloge porazdeliti med sisteme
	- mreža je bistveno počasnejše vodilo, ampak je vseeno bolje od superskalarnih
- naslovni prostor NI enovit:
	- da procesorji komunicirajo si morajo pošiljati sporočila po mreži
	- da si drugi procesor posodobi pomnilnik s podatki iz prvega procesorja, se mora strinjati z njegovim sporočilom
	- rabimo omrežni protokoll za stežnik in odjemalec

Uporaba grafičnih kartic:
- "accelerator", grafični pospeševalniki
- glavni del se dogaja na procesorju, za operacije za katere predvidi, da se bodo hitreje izvajale na GPU, jih pošlje tja
- koraki za prenos podatkov:
	- procesor shrani podatek v glavni pomnilnik
	- podatke moramo poslati iz glavnega pomnilnika na grafično kartico
	- procesor sproži računanje na GPU
	- podatke dobimo nazaj iz grafične kartice v glavni pomnilnik
- uporabno, ko lahko enkrat pošljemo veliko podatkov, potem pa dolgo računamo z njimi
- zakaj so GPU hitrejše:
	- vedno delamo vzporedne operacije nad ogromno podatki
	- rabimo ustrezen problem - računanje barve za vsak piksel je neodvisno med sabo; učenje nevronskih mrež je podobno
	- kontrolna enota je zelo primitivna, večji del silicija zavzamejo ALE
- na začetku v GPU ni bilo predpomnilnika:
	- stavimo na to, da imamo tako veliko opravil, da med tem, ko eno opravilo fetcha podatke iz pomnilnika, se druga opravila računajo
- navaden CPU ima vedno sekvenčna opravila in potem išče vzorce, da ugotovi kaj se da paralelizirati

- danes imamo v superračunalnikih večjedrne procesorje z GPU, ki so povezani v mrežo