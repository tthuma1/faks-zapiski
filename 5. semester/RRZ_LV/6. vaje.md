- konvolucija v bistvu primerja, kako podoben je kernel vzorcu signala
- delamo skalarni produkt med jedrom in n-dimenzionalnim signalom
- konvolucija vs korelacija:
	- pri konvoluciji kernel flipnemo po osi, da v bistvu delamo skalarni produkt zadnjega elementa kernela s prvim itd.
	- konvolucija je boljša od korelacije, ker dobimo komutativnost in asociativnost
	- komutativnost - lahko zamenjamo vrstni red
	- asociativnost - lahko poljubno postavljamo oklepaje
	- te lastnosti so uporabne, če imamo veliko jeder, ki so manjša od slike, lahko najprej naredimo konvolucijo med jedri in potem še eno konvolucijo s sliko - imamo manj računanja, kot če bi vsako jedro posebej konvulirali s sliko

Seperabilnost jeder:
- nekatera 2D jedra lahko razdelimo na dve enaki 1D jedri (eno je transponirano) - naredimo konvolucijo najprej po eni osi in potem po drugi - s tem se nam zmanjša časovna kompleksnost
- tak je npr. Gaussovo jedro in odvod Gaussovega jedra
- lahko naredimo odvod po eni osi in glajenje po drugi
- da je matrika seperabilna, mora biti ranga 1:
	- lahko jo predstavimo kot $k_{2d} = k^T \cdot k$

- Gaussov filter uporabljamo za glajenje:
	- $\sigma$ nam pove, kako močno bo slika zglajena - večji $\sigma$ bo bolj zgladil sliko, ker vzamemo večjo okolico, da naredimo povprečje enega piksla
	- če je $\sigma = \infty$, dobimo vse piksle enake povprečnemo pikslu
	- če je $\sigma = 0$, dobimo Diracov filter - vsak piksle na sliki bo ostal enak; v filtru je samo na sredini 1, ostalo okrog je 0
	- večji $\sigma$ bo povzročil bolj raztegnjen filter (manjši vrh, daljši repi)
	- vrednosti, ki so več kot $3\sigma$ oddaljene od sredine Gaussa, so praktično 0 - zato se ne splača narediti jedra, ki je večji od $3\sigma$, ker so ostale vrednosti praktično 0

- `simple_convolution` bo imel $k$ manj elementov od `np.convolve`
- `np.flip2D`
- `cv2.filter2D` dela korelacijo - prej flippaj kernel

Robovi:
- iščemo piksle, na katerih so sosedni piksli zelo drugačne intenzitete
- tam, kjer so sosedni piksli skoraj enaki, bomo dobili majhen odziv
- uporabimo odvod (npr. odvod Gaussa)
- če uporabimo samo odvod, nam lahko poudari nek šum - zato to uporabljamo v kombinaciji z navadnim Gaussom:
	- Gauss zgladi, da se znebimmo šuma, očitni robovi pa še vedno ostanejo; nato poženemo še odvod
- če na Diracovo funkcijo apliciramo filter, dobimo samo reprezentacijo filtra nazaj
- dobimo parcialne odvode po eni in drugi dimenziji:
	- parcialen odvod - odvajaš samo po eni spremenljivki (dimenziji)
- da nimamo samo iskanja robov po x in po y-osi, lahko določimo tudi smer roba
- magnituda robova = Evklidska razdalja
- smer = tangens
- dobimo grobo detekcijo robov:
	- rabimo še nek threshold za magnitudo
	- potem želimo, da so robovi, ki smo jih zaznali, čim tanjši - Cannyjev algoritem:
		- non-maximum supression - zadušimo vse vrednosti, ki niso lokalni maksimum
		- sprehajamo se v smeri gradienta  od ene strani roba proti drugi - nismo omejeni po x in y-osi, ker je gradient 360º
- histereza - lahko izgubimo robove, ki so potencialno uporabni zaradi upragovanja:
	- imamo dva praga in piksli pod spodnjim zagotovo niso robovi
	- piksli, ki so med pragom, so robovi samo, če so sosedi piksla nad velikim pragom