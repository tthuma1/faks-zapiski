Morfološke operacije:
- imamo binarne slike
- v realnosti je dosti šuma na slikah (nekaj kar bi moralo biti foreground, se označi kot background)
- z morfološkimi operacijami polnimo luknje in odstranimo šum
- imamo jedro (strukturni element) - manjša matrika, ki jo zapeljemo čez celo sliko in na vsakem pikslu naredimo isto operacijo
- krčenje in rast - erosion in dilation

- krčenje = majhne regije izginejo, te regije morajo biti dovolj majhne oz. jedro mora biti dosti veliko, da bodo dejansko izbrisane
- erosion = vsi piksli, ki so 1 v kernelu, morajo biti tudi na sliki, če hočemo, da se piksel na sliki ohrani:
	- ostanejo tisti piksli, kjer najdemo vzorec kernela
- dilation = če je eden od pikslov v kernelu 1, bo ta piksel 1 v outputu:
	- tisti piksli od BG, kamor lahko damo svoj kernel, bodo ostali 0, ostali bodo 1

- robni piksli - na njih ne moreš normalno postaviti kernela, ker se odreže:
	- v sliko dodamo padding samih 0 (če je 3x3 kernel, rabimo dodati en piksel v rob, pri 5x5 rabimo dva ...)
	- `np.pad(im, (0))`

- rast = polnimo luknje
- krčenje = odstranimo šum v BG

- closing (zapiranje) = dilate + erode
- opening (odpiranje) = erode + dilate

Barvanje regij:
- flood fill - je preveč memory intensive; lahko depth ali breadth first
- zaporedno označevanje regij:
	- dva prehoda
	- hranimo tabelo konfliktov
	- če so vsi sosedi 0 ali neoznačeni, je to nova regija
	- če so vsi sosedi iste labele, bo ta piskel tudi ista labela
	- če sta dva soseda različne labele, izberemo manjšo labelo in si označimo konflikt
	- dobimo npr. `conflicts =[(2,4, (8,9))]` - v drugem prehodu bomo vse 4 spremenili v 2 in vse 9 v 8

- povezljivost:
	- pove nam, kdaj sta dva piksla sosedna - 4-sosednost in 8-sosednost (8-sosednost poveže še diagonale) - $N_4$ in $N_8$

Bounding box:
- centroid = povprečje x in y koordinat regije; za neke čudne oblike ne dobimo najbolj uporabnega rezultata

Opisi regij:
- Freemanova koda:
	- kontura = obris - s tem se mi ne bomo ukvarjali, samo uporabi opencv
	- dobimo seznam pikslov znotraj regije
	- gledamo v katero smer se obrnemo na poti do naslednje točke
	- če rotiramo predmet, se bo Freemanova koda spremenila - zato uporabimo normalizirano diferenčno Freemanovo kodo
	- diferenčna Freemanova koda:
		- namesto, da gledamo absolutne premike, gledamo relativni premik, glede na prejšnji piksel
		- `np.diff(koda) % 8` - izračuna razlike pikslov, da dobimo relativne obrate; vrne n-1 elementov, zato če imamo konturo (se poveže na koncu) rabimo sami pohendlati zadnji element
		- če dobimo negativne vrednosti, rabimo narediti modulo 8
		- dobimo kodo, ki je neodvisna od rotacije objekta
	- normalizirana diferenčna Freemanova koda:
		- shiftamo toliko časa, da dobimo najmanjšo možno število, če pretvorimo kodo v integer (lahko interpretiramo kot integer v osmiškem sistemu in trackamo, katero število do sedaj je bilo najmanjše)
		- dobimo kodo, ki je neodvisna od rotacije in začetne pozicije