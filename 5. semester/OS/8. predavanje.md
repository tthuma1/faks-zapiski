- zadnjič smo delali kNN collaborative filtering, danes bomo malo drugače collaborative filtering
- Pearsonov koeficient nam je lepo uravnotežil dejstvo, da eni ocenjujejo bolj strogo kot drugi
- zadnjič smo delali primerjavo med vrsticami - za mnenje vprašaš tiste, ki imajo podoben okus kot ti
- lahko delaš tudi primerjavo med stolpci - računamo podobnost med izdelki:
	- ne primerjamo lastnosti izdelkov, ampak ratinge izdelkov
	- filmi so si podobni, če imajo podobne ocene
	- izberemo k najbolj podobnih izdelkov, ki jih je naš uporabnik že ocenil
- v naši tabeli imamo veliko neocenjenih celic, ker je preveč izdelkov, da bi jih vsi ocenili
- želiš imeti tabelo, ki ima veliko vrstic in malo stolpcev (veliko uporabnikov in manj izdelkov), zato da imaš statistično moč za napovedmi:
	- ko smo računali podobnost med uporabniki, primerjamo vse stolpce uporabnikov - stolpcev je manj kot vrstic
	- če primerjamo izdelke, potem za vsak stolpec primerjamo cel vektor stolpca - teh ocen bo v splošnem več; ko primerjamo dva izdelka med sabo, bo več možnosti, da je nek uporabnik ocenil oba izdelka, ker iščeš med veliko uporabniki; imeli bomo več parov, kjer je en uporabnik ocenil film X in Y
	- ko dobimo novo oceno, bomo pri primerjanju vrstic najbrž bolj vplivali na napoved, ker smo napoved delali na podlagi manj parov; pri primerjanju stolpcev pa bomo dobili manjši vpliv, ker imamo že veliko parov

- item-to-item je bolj stabilno na prihod novih ocen
- hitrosti izračuna med user-to-user in item-to-item ni zelo velika, ker rabiš pri vseh pogledati celo tabelo
- če hočeš hitrejše izračune, uporabiš cache - offline izračunaš del napovedi:
	- pri item-to-item se rabijo podobnosti med delovanjem manj spreminjati, torej jih lahko tudi pustiš iste in potem ko je sistem najmanj obremenjen (offline) narediš en velik update vseh napovedi
	- v realnem času ne moreš delati dovolj hitro napovedi, zato delaš offline update napovedi