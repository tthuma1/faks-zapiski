### Testiranje

- CA, P, R, F1, regresijska natančnost (MAE, (R)MSE)
- moramo testirati različne dele priporočilnega sistema, da vidimo, kje gre narobe (testiramo predictor in recommender (šminko))
- MAE = abs(napoved - resnična vrednost)
- zakaj bi delal RMSE namesto MSE:
	- koren ne uniči vrstnega reda
	- koren nam koristi, ker nam da napake na približno isto skalo kot so naše ocene (npr. če imamo ocene od 1 do 5, imamo RMSE od 0 do 4)
	- MAE dejansko ostane na isti skali kot ocene, RMSE bolj kaznuje velike napake in ignorira majhne napake (0.1^2 = 0.01; 2^2 = 4)
	- ne bolijo nas vedno majhne napake

- lahko tudi mere na koncu testiramo, da vidimo, katera je najbolj smiselna
- NMAE = MAE, ki ga normaliziramo z razponom ocen v bazi:
	- koristen za primerjanje algoritmov preko več kot ene baze

- precision = koliko od prikazanih sem jih zadel
- posebnost priporočilnih sistemov - vedno prikazujemo samo pozitivne primere oz. smo tiho, če takih ni
- recall = koliko od dejansko pozitivnih sem ti jaz napovedal:
	- če imamo omejeno, koliko izdelkov lahko priporočimo (npr. vedno priporočamo 9 filmov), bo naš recall umetno slabši - v tem primeru nas precision bolj zanima (naj bodo vsi izmed omejenega števila priporočenih dobri)

- F1 = harmonična sredina
- F1 bo visok, ko bosta oba P in R velika

- nimamo razreda, ampak ratinge - razred umetno ustvarimo:
	- vsaka ocena je lahko razred
	- matriko ratingov moramo razdeliti tako, da je v testnih podatkih odrezan en del userjev in en del itemov
	- userji so lahko na začetku sortirani po ID-ju, kdaj so prišli v bazo - zato jih želimo shufflati, da dobimo reprezentativen vzorec

- ko imamo temporalne podatke (imamo časovno komponento), ne smemo delati randomizacije zato, da bomo testirali na podatkih, ki so dovolj v prihodonsti od učnih podatkov

- ko userju priporočaš eno stvar, za katero veš, da mu bo všeč, povečas psihološko zaupanje v ostala priporočila:
	- nočemo vseh priporočil napolniti s tem, kar hočemo povečati long tail (želimo pokazati stvari, za katere uporabnik ne ve, da mu bojo všeč; želimo mu dati nove informacije)

- dober precision za letake v trgovini je že 20%, ker je važno, da userja spraviš v trgovino in boš služil z ostalimi stvarmi, ki jih bo kupil

- hibrid search engine + recommender:
	- tu te bolj zanima recall, ker nočeš zgrešiti tiste stvari, ki jo uporabnik išče
	- nočeš tudi overloadati preveč izdelkov, ki jih uporabnik ne bo kupil - zares te zanima F1

- kdaj želiš velik recall:
	- pri npr. covid testih ali screening za raka nočeš spustiti nobenega, ki je real positive
	- model za screening za raka lahko uporabiš na več načinov: lahko je safety net in pogleda za radiologom, lahko mu vnaprej izloči tiste, kjer očitno ni raka ali pa naredi priority list za radiologa

- recommender rabimo posodabljati s časom, ker se skozi čas zgodi data drift - distribucija podatkov se spremeni od takrat, ko smo učili model

- katera ocena nas najbolj zanima je zelo odvisna od domene problema

Testiranje celega sistema skupaj:
- A/B testing
- poglej kako dober je nov sistem v primerjavi s starim
- $\alpha$ (moč vzorca, 5%) in $\beta$ (80%) napake pri statističnem testu (FP in FN)
- velikost vzorca N
- statistični test (t-test)
- velikost razlike, ki jo pričakujemo (koliko pičakujemo, da se bo neka mera izboljšala)
- ko imaš dovolj velike skupine v A in B množici, randomiziraš userje med skupinami - moramo paziti, da nam random ne pokvari distribucije - narediš pseudo random razdelitev