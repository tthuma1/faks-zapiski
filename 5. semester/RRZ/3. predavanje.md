### Regije
- delamo z binarnimi slikami
- naj želimo se znebiti majhnih šumov
	- krčenje in rast: če so regije premajhne, jih bomo izgubili in ne bodo več narasle
- binarne slike lahko predstavimo tako, da samo povemo, na katerih koordinatah so enke:
	- imamo množico točk
	- enostavno delamo npr. translacijo - samo eni koordinati dodamo +zamik

- imamo morfološko jedro, ki nam definira na kakšen način širimo regije na sliki:
	- morfološko jedro ima hotspot (žarišče)
	- s tem jedrom (filtrom) filtriramo sliko tako, da gremo čez celo sliko
	- jedro je ponavadi majhno - 3x3
	- ![500](../../Images4/Pasted%20image%2020251017084959.png)
	- v zgornjem primeru za vsak piksel v $I$, ki je 1 in mu dodamo še desni piksel (jedro nam pove, kaj naredimo s 3x3 okolico prižganih pikslov)
	- želimo izotropičen morfološki operator (v vse smeri je enako razširjen)
	- ko apliciramo jedro, moramo paziti, da v vsakem koraku uporabimo originalno sliko, ne že spremenjeno

Erozija (erosion, dilacija):
- ravno obratno
- še vedno imamo jedro, ampak jedro nam pove, katere piksle okoli hotspota bomo ugasnili - če damo jedro na nek piksel in so vsi okrog užgani isto kot v jedru, potem piksel v hotspotu pustimo prižganega, sicer ga zbrišemo
- vedno brišemo piksle v hotspotu
- ![500](../../Images4/Pasted%20image%2020251017090242.png)
- ^ to bo zbrisalo vse piksle na desni strani

Lastnosti:
- ![500](../../Images4/Pasted%20image%2020251017090611.png)
- komutativnost širitve:
	- če najprej širimo z enim jedrom in potem z drugim je isto, kot če bi zamenjali vrstni red
- asociativnost širitve:
	- če imamo več jeder, se nam bolj splača, da najprej jedra med sabo razširimo in potem damo to na sliko (najprej želimo dobiti cel filter, da rabimo potem narediti samo en prehod po sliki, kar bo hitreje, kot če gremo dvakrat čez sliko z dvema jedroma)
- nevtralni element:
	- prižgan je samo hotspot

Dualnost:
- širitev ospredja je enaka eroziji ozadja in obratno
- erozijo pretvorimo v širitev:
	- invertiramo sliko in zralimo morfološki element, naredimo širitev in naredimo invert rezultata
- enako lahko pretvorimo širitev v erozijo


- ![400](../../Images4/Pasted%20image%2020251017091253.png)
- ^ desni je bolj izotropičen kot sredinski, ker ima pri sredinskem na diagonali $\sqrt{2}$ razdaljo od jedra

- morfološko jedro = morfološki filter = morfološki element
- če hotspot pri širitvi ni črn, ga zbrišemo

Obris:
- želimo zvedeti, kateri piksli so na obrisu regije, notranji piksli nas ne zanimajo
- da lahko npr. izračunamo dolžino predmeta
- naredimo erozijo in tisti piksli, ki smo jih izbrisali, so obris
- XOR med originalno in erodirano sliko
- če imamo 4-sosedni strukturni element, dobimo 8-sosedni obris (in obratno), ker bomo pri 4-sosedni eroziji izbrisali več pikslov (dobimo bolj povezane robove)

Kompozitni operatorji:
- če npr. s kamero želiš slikati A4 list in ti telefon predlaga, kam ga moraš položiti (kje približno naj bodo robovi), bomo to položili na približno - da dobimo kje je zares rob, naredimo erozijo in širitev in dobimo rob na pravem mestu
- odpiranje:
	- najprej erozija in nato širitev z istim morfolođkim jedrom
	- za odstranjanje majhnih elmentov (npr. če želiš obris stopala, bodo na sliki stopala mucke na robu od nogavice in s tem jih lahko izbrišeš)
	- ohranimo obliko, samo rešimo se majhnih šumov
- zapiranje:
	- če imaš na nogavici narisano nekaj, kar je enake barve kot ozadje, moraš zapolniti luknjo - najprej narediš širitev, nato erozijo
	- ohranimo obliko, samo zapremo majhne luknje
- spet imamo dualnost (enak premislek kot pri eroziji in širitvi)
- idempotentnost:
	- ko prvič izvedeš neko operacijo, se nekaj spremeni, če jo večkrat ponoviš se potem ne bo nič več spremenilo
	- npr. pri odpiranju če imamo nek šum, ga v prvem koraku odstranimo, potem če še delamo odpiranje, se ne bo nič več spremenilo
- od velikosti jedra je odvisno, koliko šuma se bo zbrisalo (kako velika mora biti packa, da se bo zbrisala) oz. kako velike luknje se bodo zapolnile

- ![500](../../Images4/Pasted%20image%2020251017094100.png)
- ^ lahko naredimo back to back odpiranje in zapiranje

Iskanje regij na sliki:
- flood fill (depth first ali breadth first):
	- breadth first (v širino) nam dela po slojih (vrsta)
	- depth first gre najprej do konca in potem backtracka (sklad)
	- rekurzivno ali iterativno
- kaj je regija:
	- dogovorimo se, ali so regije 8-sosedne ali 4-sosedne
- zaporedno označevanje regij:
	- dva prehoda čez celo sliko (od zgoraj levo do spodaj desno)
	- ko pridemo do foreground piksla, gledamo sosede levo gor od njega
	- če je med levo zgornjimi sosedi samo ozadje, je to nov predmet
	- če je med levo zgornjimi sosedi že kakšen predmet, potem je ta piksel del istega predmeta
	- če je med levo zgornjimi sosedi več različnih predmetov, si izberemo enega  (lahko npr. določimo, da se vedno vzame najmanjša labela) in zapišemo, da sta ta dva predmeta v bistvu isti predmet - v drugem prehodu po sliki bomo to popravili, da bo to res isti predmet

Obrisi regij:
- želimo urejeno zaporedje, kateremu robnemu elementu sledi kateri nasledni robni element
- zunanji obris - iz BG v FG
- notranji obris - iz FG na BG
- spet skeniramo od zgoraj levo do spodaj desno
- BG ne barvamo
- trije primeri:
	- prehod iz BG na FG: gremo okrog in pobarvamo sosede BG
	- prehod iz FG na BG (notranji rob): spet gremo okrog
	- iz FG na neoznačen FG: samo označiš
- hkrati dobimo regijo in rob

Predstavitev slikovnih regij:
- matrika, zakodirana matrika, dva algoritma na robovih
- matrika:
	- za vsak piksel povemo, ali je 1 ali 0
- RLE (run length encoding):
	- govorimo samo o FG, povemo koliko zaporednih FG elementov je
	- row, column za začetek + length (koliko FG sledi po začetku)
- kodiranje obrisa z verižno kodo (absolute chain code, Freemanova koda):
	- nekje začnemo in namesto koordinat si pišemo smeri, kamor se premikamo
	- vsaka smer ima svojo cifto od 0 do 7
	- vseeno je, kje se začne nek predmet - če sledimo smerem, bomo vedno dobili isti predmet - invariantna na premik:
		- predstavitev predmeta bo enaka, tudi če predmet premaknemo
		- odvisna od začetne točke in orientacije (v kateri smeri označimo smeri)
	- lahko naredimo 4-sosedno ali 8-sosedno => za isti predmet lahko dobimo različni kodi
	- dolžina kode nam pove dolžino obsega predmeta
	- če želimo, da rotacija predmeta ne vpliva na kodo, uporabimo diferenčno verižno kodo
- diferenčna verižna koda (diferenčna Freemanova koda):
	- drugi korak izrazim glede na prvi
	- ni v absolutnem smislu važno v katero smer gremo, ampak relativno (diferenčno) na prejšnji korak
	- vedno gremo v isto smer glede na prejšnji korak
	- nardimo po modulu 8
	- če rotiramo za 90 stopinj, bomo dobili enako diferenčno verižno kodo
	- še vedno smo odvisni od začetne točke:
		- če spremenimo začetno točko, bo koda shiftana
		- če tega ne želimo, lahko vsako zaporedje shiftamo tako, da dobimo najmanjšo številko - shape numbers
- shape numbers (številke oblike):
	- zaporedje si prestavljamo kot število in shiftamo tako, da dobimo najmanjšo možno število iz tega zaporedja - dobimo normalizirano diferenčno Freemanovo kodo
	- invariantna na:
		- rotacijo za 90 stopinj, premik in začetno točko
		- ni invariantna na ostale rotacije in skaliranje

Levenshtainova razdalja:
- koliko znakov moramo spremeniti/dodati/odstraniti, da pridemo iz enega zaporedja v drugega
- s tem lahko primerjamo dve verižni kodi med sabo; koliko sta si različni

Lastnosti binarnih regij:
- značilke:
	- neke lastnosti posameznih predmetov: obseg, površina ...

Obseg:
- lahko uporabimo dolžino verižne kode: diagonale so $\sqrt{2}$, ostalo $1$

Površina:
- prešteješ število belih pikslov

- obseh in površina sta:
	- neodvisna od translacije in rotacije
	- odvisna od skale

Kompaktnost oz. okroglost:
- površina deljeno s kvadratom obsega
- neodvisno (invariantno) na translacijo, rotacijo in skalo
- več kot 1 ne more biti (krog)
- lahko npr. ugotovimo kako okrogel je nek predmet - pove nam okroglost