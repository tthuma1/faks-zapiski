Ujemanje binarnih slik:
- pri navadnem ujemanju slik imaš majhen delček slike, ki ga premikaš po drugi sliki in gledaš, kje se najbolj ujema - delamo korelacijo piksel na piksel
- problem pri binarnih slikah:
	- lahko se nam zgodi, da je naš patch zelo blizu, ampak ker imamo samo dve vrednosti, mogoče ne bo noben piksel pravilen
	- dobimo zelo negladek heatmap
	- moramo imeti srečo, da zadanemo pravi piksel, kjer se naš iskane predmet nahaja
	- rešitev: odebelimo - tam, kjer je zdaj 1, naj se razširi; na patchu odebelimo enke
	- da odebelimo enke, zgladimo sliko z Gaussovim filtrom in iščemo predmet na zglajeni sliki (uporaba širitve ni v redu, ker želimo gladke prehode na robovih enk na patchu)
	- še bolje: vsak slikovni element ozadja preslika v razdaljo do najbližjega slikovnega elementa ospredja:
		- na vogalih lahko uporabiš Evklidsko ali Manhattansko razdaljo do najbljižjega piksla FG

Transformacija razdalje (distance transform/funkcija razdalje):
- neučinkovito: lahko bi šli v vsak FG piksel in se rekurzivno širili ven, da bi označili vse razdalje na BG in na teh vzeli minimum od vseh širjenj iz FG
- Chamferjev algoritem:
	- imamo dve maski
	- ![500](../../Images4/Pasted%20image%2020251114085607.png)
	- $M^L$ = če je levo mene ospredje, vem da rabim en korak do njega, če je levo od mene 2, bom jaz 3
	- za koliko povečam pot od tistega piksla do mene
	- $M^L$ = razdalja do najbljižjega predmeta zgoraj levo; vedno gledamo levo in gor; kadar več delov maske vžge, vzamemo najmanjšega
- je bolje kot direct comparison, ker dobimo bolj gladke prehode med vrednostjo ujemanja od piksla do piksla

### Detekcija premic in krivulj

- včasih želimo zaznati neke geometrijske like - premice, elipse, krogi, pravokotniki

Detekcija premic:
- najprej poiščemo robove, ker bo premica vedno na robu
- kako vemo, kateri robovi so premice
- premice so ravni robovi
- lahko se zgodi, da je premica malo prekinjena zaradi šuma
- lahko gledamo lokalno (bottom up):
	- zasidramo neko seme in se širimo okrog - če so vsi piksli, na katere naletimo v neki linearni kombinaciji, potem je to premica
	- gre za sledenje sosednjim robnim pikslov
- mi želimo top down pristop
- redko imamo popolnoma ravne črte - rabimo tudi detekcijo krožnic oz. elips

Detekcija premic:
- Houghova (hafova) transformacija
- je globalna metoda
- od zgoraj navzdol gledamo, kje so premice
- za vsak piksel preverimo, na katerih vseh premicah leži in potem pogledamo, na katerih premicah leži največ pikslov - tisto je najbolj očitna premica
- za vsak piksel poglej, na katerih premicah leži
- delamo v prostoru slik in prostoru značilk
- v poštev pridejo samo tist kombinacije $k$ in $d$, ki zadovoljijo enačbo $y_1 = k x_1 + d$
- $d = -x_1k + y1$ => če variiram k, dobim točno tisti $d$, da dobim tiste pare $k,d$, da dobim samo premice, ki ležijo na tej točki => dobimo premico v parametričnem ($k,d$) prostoru => to ponovi še za drugo točko in tam, kjer se premici v parametričnem prostoru sekata, smo dobili tisti $k,d$ premice, na kateri ležita obe točki
- računamo $d$ v odvisnosti od $k$
- če imamo več premic, imamo več presečišč - iščemo, kje se nam seka največ premic
- 
- za vsako robno točko na sliki, izračunaš vse pare $k,d$, na katerih ta točka leži
- nato poiščeš presečišča teh premic - želimo najti presečišča, kjer se seka največ $k,d$ parametričnih premic
- 
- ker smo v diskretnem prostoru, moramo $k,d$ diskretizirati - na začetku je v parametričnem prostoru vse 0, potem pa za vsako točko, ki leži na tem $k,d$ dodamo en "glas" gor:
	- ![300](../../Images4/Pasted%20image%2020251114100212.png)
- en piksel v parametričnem prostoru nam predstavlja eno premico na sliki
- kje je tista premica, na kateri leži največ točk - tisti piksel, ki ima največ "glasov"
- 
- s $k,d$ ne moremo opisati navpičnih premic - uporabimo Hessovo normalno obliko:
	- $x \cdot cos(\Theta) + y \cdot sin(\Theta) = r$
	- imamo parametra  $\Theta$ in $r$
	- variiramo $\Theta$ in izračunamo $r$
	- prostor značilk ne bo imel več premic, ampak sinusoide
	- vsaka krivulja v prostoru značilk nam predstavlja množico premic, ki grejo skozi neko točko na sliki (vsak piksel krivulje predstavlja eno premico)
	- ena točka na sliki se preslika v eno sinusoido v parametrični sliki
	- tam kjer se sinusoide sekajo, imamo premico na sliki
	- lahko linearno vzorčimo $\Theta$ od 0 do $\pi$ in pokrijemo vse možnosti; radij gre od $-r_{max}$ do $r_{max}$
	- ![500](../../Images4/Pasted%20image%2020251114101807.png)
	- M, N = širina in višina slike

- kako natančno diskretizacijo thete rabimo
- kako veliko je akumulatorsko polje:
	- večje kot je, bolj natančno bomo dobili
	- bolj kot bomo natančni, bolj bodo razpršena presečišča, zato bomo morali to v drugem koraku upoštevati
	- če preveč na grobo parametriziramo, dobimo več maksimumov in ne bomo morali natančno določiti, katera premica je prava
- če hočemo, da nam neko točka v akumulatorskem polju šteje za premico, rabi vsaj X glasov
- naredimo upragovljanje na akumulatorskem polju in dušitev ne-maksimumov, da dobimo točno točko, ki določa premico
- tudi če imamo precej šuma, bomo dobili dobre rezultate

- dobimo snope premic - katera je najboljša?:
	- ![500](../../Images4/Pasted%20image%2020251114103442.png)
	- rabimo še postprocesirati

Razširitve Houghove transformacije:
- akumulatorska funkcija je diskretizirana - namesto, da delamo stroge prehode 1 in 0, ima vsak piksel nek glas (npr. 0.8), če gre funkcija skozi mejo pikslov - oblažimo zapackanost zaradi diskretizacije

Problem kratkih premic:
- z glasovanje smo favorizirali premice, ki so na sredini slike in penalizirali premice na vogalih
- vse uteži delimo z maksimalno možnostjo glasov (maksimalno število pikslov, ki lahko ležijo na premici - to je obratno sorazmerno z oddaljenostjo od centra):
	- če je premica zelo oddaljena, moramo povečati njen glas (kot da bi na volitvah manjšim volilnim enotam povečali glas, da se izenačijo z velikimi)

Iskanje daljic:
- ko polnimo akumulatorsko polje, si shranimo max in min $x$ in $y$, ki leži na tej premici - ko dobimo neko premico, imamo že zabeleženo, kje se premica začne in konča
- akumulatorsko polje postane 5 dimenzionalno:
	- ![400](../../Images4/Pasted%20image%2020251114104216.png)
	- count nam pove, ali je tam res premica, ostale dimenzije nam povejo, kje se daljica začne in konča

Problem diskretizacije theta:
- če diskretiziramo po 1 stopinjo, imamo 180 premic za izračunati
- iz Cannyja oz. gradienta roba vemo, v katero smer približno je orientiran rob - potem izračunamo samo thete za premice, ki so blizu temu kotu (zmanjšamo npr. iz 180 premic na 30)
- bolj močan (večja magnituda) rob kot imamo, bolj verjetno bo tam premica - gledamo samo tiste točke robov, ki imajo dovolj visoko magnitudo

- kaj če dobimo več maksimumom v akumulatorskem polju zaradi nenatančnosti:
	- težko je pričakovati, da bomo točno eno točko dobili - bomo dobili nek približek oz. 2 ali 3 približke
	- iščemo premico, ki se najbolj prilega točkam (kot to dela linearna regresija) - minimiziramo kvadrate razdalj od točk do premice
	- dobimo rešitev s pseudoinverzom
	- če poznamo množico točk in želimo dobiti premico, ki se jim najbolj prilega, uporabimo pseudoinverz

- najprej izračunamo Hougha, da dobimo množico premic
- potem pogledamo katere točke ležijo zelo blizu teh premic - na njih potem fittamo pravo premico (izračunamo pseudoinverz), da dobimo optimalno premico za te točke
- najprej izračunamo Hougha in ga izboljšamo s pseudoinverzom