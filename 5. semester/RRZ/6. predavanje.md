Ujemanje binarnih slik:
- pri navadnem ujemanju slik imaš majhen delček slike, ki ga premikaš po drugi sliki in gledaš, kje se najbolj ujema - delamo korelacijo piksel na piksel
- problem pri binarnih slikah:
	- lahko se nam zgodi, da je naš patch zelo blizu, ampak ker imamo samo dve vrednosti, mogoče ne bo noben piksel pravilen
	- dobimo zelo negladek heatmap
	- moramo imeti srečo, da zadanemo pravi piksel, kjer se naš iskane predmet nahaja
	- rešitev: odebelimo - tam, kjer je zdaj 1, naj se razširi; na patchu odebelimo enke
	- da odebelimo enke, zgladimo sliko z Gaussovim filtrom in iščemo predmet na zglajeni sliki (uporaba širitve ni v redu, ker želimo gladke prehode na robovih enk na patchu)
	- še bolje: vsak slikovni element ozadja preslika v razdaljo do najbližjega slikovnega elementa ospredja:
		- na vogalih lahko uporabiš Evklidsko ali Manhattansko razdaljo do najbljižjega piksla FG

Transformacija razdalje (distance transform/funkcija razdalje):
- neučinkovito: lahko bi šli v vsak FG piksel in se rekurzivno širili ven, da bi označili vse razdalje na BG in na teh vzeli minimum od vseh širjenj iz FG
- Chamferjev algoritem:
	- imamo dve maski
	- ![500](../../Images4/Pasted%20image%2020251114085607.png)
	- $M^L$ = če je levo mene ospredje, vem da rabim en korak do njega, če je levo od mene 2, bom jaz 3
	- za koliko povečam pot od tistega piksla do mene
	- $M^L$ = razdalja do najbljižjega predmeta zgoraj levo; vedno gledamo levo in gor; kadar več delov maske vžge, vzamemo najmanjšega
- je bolje kot direct comparison, ker dobimo bolj gladke prehode med vrednostjo ujemanja od piksla do piksla

### Detekcija premic in krivulj

- včasih želimo zaznati neke geometrijske like - premice, elipse, krogi, pravokotniki

Detekcija premic:
- najprej poiščemo robove, ker bo premica vedno na robu
- kako vemo, kateri robovi so premice
- lahko se zgodi, da je premica malo prekinjena zaradi šuma
- lahko gledamo lokalno (bottom up):
	- zasidramo neko seme in se širimo okrog - če so vsi piksli, na katere naletimo v neki linearni kombinaciji, potem je to premica
	- gre za sledenje sosednjim robnim pikslov
- mi želimo top down pristop
- redko imamo popolnoma ravne črte - rabimo tudi detekcijo krožnic oz. elips

Detekcija premic:
- Houghova (hafova) transformacija
- je globalna metoda
- od zgoraj navzdol gledamo, kje so premice
- za vsak piksel preverimo, na katerih vseh premicah leži in potem pogledamo, na katerih premicah leži največ pikslov - tisto je najbolj očitna premica
- za vsak piksel poglej, na katerih premicah leži
- delamo v prostoru slik in prostoru značilk
- v poštev pridejo samo tist kombinacije $k$ in $d$, ki zadovoljijo enačbo $y_1 = k x_1 + d$
- $d = -x_1k + y1$ => če variiram k, dobim točno tisti $d$, da dobim tiste pare $k,d$, da dobim samo premice, ki ležijo na tej točki => dobimo premico v parametričnem ($k,d$) prostoru => to ponovi še za drugo točko in tam, kjer se premici v parametričnem prostoru sekata, smo dobili tisti $k,d$ premice, na kateri ležita obe točki