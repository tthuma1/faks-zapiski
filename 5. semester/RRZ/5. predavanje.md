- kolokvij 28.11. 8.30, snov do konca tega predavanja
- prej smo imeli upragovljanje, filtriranje binarnih slik, filtriranje intenzitetnih (sivinskih) slik
- detekcija robov in vogalov so linearni filtri, isto kot zadnjič, ki jih uporabimo za drug noben

### Detekcija robov in vogalov

- robovi so zelo  informativni, lahko prepoznamo kaj je na sliki, samo iz robovov, ker nosijo glavno semantično informacijo o tem, kar želimo predstaviti
- na robu je bistvena razlika med intenziteti - lokalna intenziteta se bistveno spremeni v določeni smeri
- pri vogalih hočemo dobiti točko, pri robovih dobimo 1D objekt
- eno je, da imamo rob nečesa kar je narisano, drugo je, da imamo rob predmeta
- ni nujno, da je sprememba intenzitete res rob, ampak je lahko tudi senca

- matematično so to odvodi:
	- odvodi nam povejo, kje je sprememba intenziteta (kje funkcija pada/narašča)
	- odvod po absolutni vrednosti mora biti velik, da imamo rob
	- odvod nam pove koliko se spremeni $f(x)$, če malo spremenimo $x$
- najprej delamo horizontalne prehode, potem vertikalne prehode - bolje je, če uporabimo filter, da naredimo samo en prehod

- ko združimo odvoda v obe smeri, dobimo gradient, ki nam za vsako smer pove, koliko je rob v tisti smeri - pove nam, v katero smer kaže rob
- če želimo ugotoviti, kako močan je rob v točki, izračunamo magnitudo gradienta (dolžino vektorja, ki ga predstavlja gradient):
	- magnituda gradienta ni odvisna od kota

- ![300](../../Images4/Pasted%20image%2020251107090852.png)
- ^b) je iskanje robov po x-smeri, c) je iskanje robov po y-smeri, d) je združena amplituda b) in c), da dobimo robove okole celega kroga

- pri glajenju dobimo v vsaki točki vrednost, ki je bolj verjetno tam
- uporabimo filozofijo glajenja za iskanje robov:
	- ko računamo vrednost v pikslu, gledamo še okolico, da hkrati v bistvu še zgladimo sliko
	- ![200](../../Images4/Pasted%20image%2020251107091649.png)
	- ^primerjamo tri točke na levi s tremi točkami na desni
	- pri gaussovem filtru so se rabili koeficienti sešteti v 1 (smo morali normalizirati), da se intenziteta slike ne spremeni (ne globalno svetlimo/temnimo) - pri robovih nam ni važna absolutna vrednost, ker nas zanimajo samo relativne vrednsti - zato filtra za robove ne rabimo normalizirati

- separabilnost:
	- pri Gaussu smo zmanjšali število množenj tako, da namesto 5x5 matrike uporabiš 5x1 in 1x5
	- podobno je tukaj
	- ![200](../../Images4/Pasted%20image%2020251107092051.png)

- pri filtriranju je Gaussov filter boljši od povprečnega - s tem utežimo sredinski piksel, ker je tam najbolj verjento prava vrednost
- podobno naredimo tukaj - dobimo Sobelov filter:
	- ![200](../../Images4/Pasted%20image%2020251107092232.png)

- operator Kompas:
	- imaš osem filtrov, kjer vsak išče robove v eni smeri (horizontalno, vertikalno, diagonale)
	- za amplitudo roba vzamemo najmočnejši rezultat
	- za orientacijo ne rabimo računati tangensa, ampak samo pogledamo, pri katerm filtru je odziv največji
	- lahko bi uporabili tudi samo prve štiri izmed njih

- v praksi najprej uporabi Sobelov filter, potem pa Cannyjev filter za postprocessing

Cannyjev operator:
- tri cilji:
	- minimizirati število napačno detektiranih robnih točk
	- dobra lokalizacija robov
	- tanki robovi
	- želimo tanke robove, ki so čim bolj točno na robu
- ![500](../../Images4/Pasted%20image%2020251107095400.png)
- glajenje:
	- ko imamo šum, ga ne bomo več prepoznali kot rob
	- ostali bodo samo tisti robovi, ki so bolj očitni
	- ![400](../../Images4/Pasted%20image%2020251107100138.png)
	- ^npr. pri tem primeru po glajenju ne bi več zaznali robov na šumu na kamnih, manj robov bi bilo tudi na travi
	- ![400](../../Images4/Pasted%20image%2020251107100955.png)
	- večja sigma, bo naredilo bolj sploščenega Gaussa in bomo dobili bolj zamegljeno pri Sobelu
	- če imamo preveliko sigmo, bomo preveč robov izgubili (damo manjši poudarek na sredinski element) - izgubili bomo tiste robove, ki niso dovolj očitni/izraziti (premajhna razlika v intenziteti); želimo ravno prav veliko sigmo
	- sigma se v bistvu pozna v Sobelovem filtru (koliko bomo utežili sredinski element in koliko stranske)
- magnitudo robova upragovimo
- za vsak piksel določimo orientacijo, diskretizirano v štiri smeri:
	- pobarvamo robove glede na orientacijo
- tanšanje robov:
	- premikam se v smeri roba, če je moja vrednost višja, kot vrednost soseda, jo ohranim, sicer jo izbrišem - ohranimo samo tisti piksel v robu, ki ima največjo intenziteto (običajno bo to na sredini robova)
	- dobimo robove debeline 1px
	- dušenje lokalnih ne-maximumov
- sledenje robov na osnovi histerez:
	- ko prideš do piksla, ki ima magnitudo T1, mu slediš, dokler magnituda ne pade pod T2
	- dobiš robove, ki so bolj povezane med sabo

- včaših želimo z drugim odvodom izračunati rob, da dobimo ekstreme robov (kje je največji rob)
- iščemo maksimum prvega odvoda oz. ničlo drugega odvoda
- to uporablja Laplaceov filter:
	- v praksi se to manj uporablja, ker imamo aproksimacijo (diskretne vrednosti), zaradi česar nikoli ne bo vse čisto točno (delamo napako na napako, ko računamo drugi odvod)
	- ![100](../../Images4/Pasted%20image%2020251107101720.png)
	- v praksi uporabljamo Sobel + Canny

Ostrenje robov:
- ostri rob = hiter prehod iz svetle v temno
- vse robove bomo naredili, da se razlika v intenziteti zgodi na manjši razdalji
- na eni strani damo signal bolj dol, na drugi pa bolj gor, zaradi česar je razdalja od majhne do velike vrednost manjša