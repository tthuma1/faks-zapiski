- kolokvij 28.11. 8.30, snov do konca tega predavanja
- prej smo imeli upragovljanje, filtriranje binarnih slik, filtriranje intenzitetnih (sivinskih) slik
- detekcija robov in vogalov so linearni filtri, isto kot zadnjič, ki jih uporabimo za drug noben

### Detekcija robov in vogalov

- robovi so zelo  informativni, lahko prepoznamo kaj je na sliki, samo iz robovov, ker nosijo glavno semantično informacijo o tem, kar želimo predstaviti
- na robu je bistvena razlika med intenziteti - lokalna intenziteta se bistveno spremeni v določeni smeri
- pri vogalih hočemo dobiti točko, pri robovih dobimo 1D objekt
- eno je, da imamo rob nečesa kar je narisano, drugo je, da imamo rob predmeta
- ni nujno, da je sprememba intenzitete res rob, ampak je lahko tudi senca

- matematično so to odvodi:
	- odvodi nam povejo, kje je sprememba intenziteta (kje funkcija pada/narašča)
	- odvod po absolutni vrednosti mora biti velik, da imamo rob
	- odvod nam pove koliko se spremeni $f(x)$, če malo spremenimo $x$
- najprej delamo horizontalne prehode, potem vertikalne prehode - bolje je, če uporabimo filter, da naredimo samo en prehod

- ko združimo odvoda v obe smeri, dobimo gradient, ki nam za vsako smer pove, koliko je rob v tisti smeri - pove nam, v katero smer kaže rob
- če želimo ugotoviti, kako močan je rob v točki, izračunamo magnitudo gradienta (dolžino vektorja, ki ga predstavlja gradient):
	- magnituda gradienta ni odvisna od kota

- ![300](../../Images4/Pasted%20image%2020251107090852.png)
- ^b) je iskanje robov po x-smeri, c) je iskanje robov po y-smeri, d) je združena amplituda b) in c), da dobimo robove okole celega kroga

- pri glajenju dobimo v vsaki točki vrednost, ki je bolj verjetno tam
- uporabimo filozofijo glajenja za iskanje robov:
	- ko računamo vrednost v pikslu, gledamo še okolico, da hkrati v bistvu še zgladimo sliko
	- ![200](../../Images4/Pasted%20image%2020251107091649.png)
	- ^primerjamo tri točke na levi s tremi točkami na desni
	- pri gaussovem filtru so se rabili koeficienti sešteti v 1 (smo morali normalizirati), da se intenziteta slike ne spremeni (ne globalno svetlimo/temnimo) - pri robovih nam ni važna absolutna vrednost, ker nas zanimajo samo relativne vrednsti - zato filtra za robove ne rabimo normalizirati

- separabilnost:
	- pri Gaussu smo zmanjšali število množenj tako, da namesto 5x5 matrike uporabiš 5x1 in 1x5
	- podobno je tukaj
	- ![200](../../Images4/Pasted%20image%2020251107092051.png)

- pri filtriranju je Gaussov filter boljši od povprečnega - s tem utežimo sredinski piksel, ker je tam najbolj verjento prava vrednost
- podobno naredimo tukaj - dobimo Sobelov filter:
	- ![200](../../Images4/Pasted%20image%2020251107092232.png)

- operator Kompas:
	- imaš osem filtrov, kjer vsak išče robove v eni smeri (horizontalno, vertikalno, diagonale)
	- za amplitudo roba vzamemo najmočnejši rezultat
	- za orientacijo ne rabimo računati tangensa, ampak samo pogledamo, pri katerm filtru je odziv največji
	- lahko bi uporabili tudi samo prve štiri izmed njih

- v praksi najprej uporabi Sobelov filter, potem pa Cannyjev filter za postprocessing

Cannyjev operator:
- tri cilji:
	- minimizirati število napačno detektiranih robnih točk
	- dobra lokalizacija robov
	- tanki robovi
	- želimo tanke robove, ki so čim bolj točno na robu
- ![500](../../Images4/Pasted%20image%2020251107095400.png)
- glajenje:
	- ko imamo šum, ga ne bomo več prepoznali kot rob
	- ostali bodo samo tisti robovi, ki so bolj očitni
	- ![400](../../Images4/Pasted%20image%2020251107100138.png)
	- ^npr. pri tem primeru po glajenju ne bi več zaznali robov na šumu na kamnih, manj robov bi bilo tudi na travi
	- ![400](../../Images4/Pasted%20image%2020251107100955.png)
	- večja sigma, bo naredilo bolj sploščenega Gaussa in bomo dobili bolj zamegljeno pri Sobelu
	- če imamo preveliko sigmo, bomo preveč robov izgubili (damo manjši poudarek na sredinski element) - izgubili bomo tiste robove, ki niso dovolj očitni/izraziti (premajhna razlika v intenziteti); želimo ravno prav veliko sigmo
	- sigma se v bistvu pozna v Sobelovem filtru (koliko bomo utežili sredinski element in koliko stranske)
- magnitudo robova upragovimo
- za vsak piksel določimo orientacijo, diskretizirano v štiri smeri:
	- pobarvamo robove glede na orientacijo
- tanšanje robov:
	- premikam se v smeri roba, če je moja vrednost višja, kot vrednost soseda, jo ohranim, sicer jo izbrišem - ohranimo samo tisti piksel v robu, ki ima največjo intenziteto (običajno bo to na sredini robova)
	- dobimo robove debeline 1px
	- dušenje lokalnih ne-maximumov
- sledenje robov na osnovi histerez:
	- ko prideš do piksla, ki ima magnitudo T1, mu slediš, dokler magnituda ne pade pod T2
	- dobiš robove, ki so bolj povezane med sabo

- včaših želimo z drugim odvodom izračunati rob, da dobimo ekstreme robov (kje je največji rob)
- iščemo maksimum prvega odvoda oz. ničlo drugega odvoda
- to uporablja Laplaceov filter:
	- v praksi se to manj uporablja, ker imamo aproksimacijo (diskretne vrednosti), zaradi česar nikoli ne bo vse čisto točno (delamo napako na napako, ko računamo drugi odvod)
	- ![100](../../Images4/Pasted%20image%2020251107101720.png)
	- v praksi uporabljamo Sobel + Canny

Ostrenje robov:
- ostri rob = hiter prehod iz svetle v temno
- vse robove bomo naredili, da se razlika v intenziteti zgodi na manjši razdalji
- na eni strani damo signal bolj dol, na drugi pa bolj gor, zaradi česar je razdalja od majhne do velike vrednost manjša

Vogali (koti, corner):
- so koristni, če slikamo nek objekt iz več kamer, da vemo, kako slike iz različnih kamer korelirajo med sabo - lahko npr. izračunamo globimo (oddaljenost predmeta od kamere)
- vogali so zelo statični - iz različnih pogledov izgledajo zelo podobno
- predstavljajo ključne točke objekta
- vogal je povsod, kjer se intenziteta spremeni v dveh smereh hkrati (oz. v več smereh hkrati)
- uporabimo Harrisov detektor vogalov:
	- če sta obe lastni vrednosti matriki dovolj podobni, je verjetnost za kot velika (ker to pomeni, da je v dveh smereh sprememba intenzitete)
	- dobimo seznam kandidatov, jih sortiramo po močeh (po jakosti kota) in ohranimo le najbolj izrazite
	- v vsakem radiju (v vsaki okolici) nam ohrani samo najmočnejši vogal; radij želimo tako velik, da izpadejo točke, ki nam v bistvu kažejo na isti vogal (dobimo najpomembnejše vogale)
- tudi pri iskanju vogalov lahko blurramo sliko:
	- uporabimo Gaussovo piramido slik
	- če imamo veliko sliko in jo zameglimo, bomo opazili samo bolj očitne vogale
- Harris se ne uporablja v kritičnih primerih (kjer rabimo biti 100% prepričani, da sta dva vogala na različnih slikah ista):
	- uporabimo nevronske mreže, SIFT, SURF ...
	- ti operatorji gledajo več okolice in bolj skušajo ugotoviti, da je okolica res enaka

### Ujemanje slik (image matching)

- uporabno za npr. stereo kamere - najprej dobimo vogale in potem probamo ugotoviti, kateri vogal iz ene slike je isti kot na drugi sliki
- majhen delček ene slike primerjam z majhnim delčkom druge

- to ni razpoznavanje predmetov oz. interpretacija slik - to se danes dela z deep learningom
- hočemo čim bolje primerjati dva delčka (patch) dveh slik na čim bolj preprost način

- uporabno za npr. sledenje predmetov, iskanje vzorcev

Mere podobnosti:
- imamo dva patcha (zaplati)
- lahko računamo razliko med zaplatami v vsaki točki in dobimo vsoto avsolutnih razlik ali max razliko
- Evklidska razdalja:
	- gledamo istoležne piksle, jih odštejemo in kvadriramo in korenimo (se znebimo minusov)
	- lahko se znebimo korena, ker ko primerjamo vrednosti med sabo je vseeno ali primerjamo korenjene vrednosti ali ne - dobimo kvadrat Evklidke razdalje
- kvadrat Evklidke razdalje:
	- dobimo tri člene - prvi je odvisen samo od referenčne slike, drugi samo od nove slike, tretji pa od obeh - torej nas zares zanima samo tretji člen
	- ![600](../../Images4/Pasted%20image%2020251107105216.png)
	- to je v bistvu korelacija (enako kot smo imeli korelacijo pri filtriranju) - množimo istoležne elemente in seštejemo vse skupaj - večja kot bo ta vrednsot, bolj podobni si bosta sliki
	- kjer bo Evklidska razdalja majhna, bo korelacija velika
	- korelacija = podobnost
- korelacijo normalizirano s korenom svetlosti lokalne in referenčne regije (normaliziramo z vrednostjo lokalne intenzitete slike) - da tudi svetlost regije nima vpliva
- dobimo normalizirano prečno korelacijo
- to naredimo, da nas ne moti, če je en del nove slike bolj osvetljen - če je nova slika bolj osvetlena, bo celotna slika bolj osvetlena - zato uporabimo korelacijski koeficient
- dobimo centralni korelacijski koeficient:
	- od vrednosti piksla odštejemo povprečno intenziteto slike
	- globalna osvetljenost ne vpliva več na razdaljo
	- je invariantno na spremembo intenzitete celotne slike