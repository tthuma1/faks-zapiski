- komunikacija vgrajenega sistema z analognim svetom - do zdaj smo vedno pošiljali digitalne signale prek GPIO in UART
- analogne naprave nekaj povedo z zveznim tokom ali napetostjo:
	- tipamo senzorje, ki nam svojo informacijo povejo kot zvezni tok ali napetost
	- merimo napetost na pinu, da dobimo temperaturo
- DAC - digitaln-to-analogni converter
- ADC - ravno obratno

DAC:
- ideja: imamo štiri bite, na razponu 0b0000 do 0b1111
- če je digitalni sistem napajan npr. s 3.3V, potem bo tudi analogna (zvezna) vrednost na razponu od 0 do 3.3V (če ne dodajamo napetosti od zunaj)
- kako pretvorimo `[0000, 1111] -> [0, 3.3V]`
- 3.3V bo $V_{REF}$ - DAC bo glede na binarno vrednost sklairal to referenčno napetost

ADC:
- zajamemo napetost in jo skušemo uganiti
- če znamo tvoriti napetost od 0 do 3.3V, potem mora biti tudi vhodna napetost do 3.3V
- npr. ugibam, da je npr. 1000 in to vrednost pretvorimo v analogno:
	- vhodno vrednost primerjamo s tvorjena - če smo tvorili preveč, je tist bit 0, če smo tvorili premalo, je tist bit 1
	- to ponavljamo od $b_n$ do $b_0$
- 1. zajamem analogno vrednost in jo začasno shranim
- 2. začnem ugibati:
	- predpostavim (ugibam) digitalno vrednost, to nato pretvorim v analogno (uporabi DAC) in primerjam z vhodno napetostjo
	- ponavljam
- zgled:
	- $V_{REF} = 3.3V$
	- $V_{SENS} = 2.5V$ (analogna vrednost, ki jo zajamem)
	- št. bitov = 4
	- 1. ugibam: 1000
		- $0b1000 \cdot V_{REF} / 16 = 1.65V$
		- primerjam: 1.65V < 2.5V => true
	- 2. ugibam: 1100
		- $0b1100 \cdot V_{REF}/16 = 2.475V$
		- primerjam: 2.475 < 2.5V => true
	- 3. ugibam: 1110
		- $0b1110 \cdot V_{REF}/16 = 2.8875 V$
		- primerjam 2.8875V < 2.5V => false
		- popravim ugibanje v 1100
	- 4. ugibam: 1101
		- $0b1101 \cdot V_{REF}/16 = 2.68V$
		- primerjam: 2.68V < 2.5V => false
		- popravim na 1100
	- zaključim: 1100
	- najbljižja digitalna vrednost od 2.5V je 0b1100 (12/16 od 3.3V)
- pretvorba ima toliko korakov, kolikor bitov imamo na voljo za predstavitev analogne vrednosti
- število bitov nam določa natančnost pretvorbe
- natančnost = $\frac{1}{2^n} \cdot V_{REF}$ = prispevek najnižjega bita
- n = št. bitov
- zajeto vrednost nekam shranim => kam?
	- digitalne vrednosti shranjujemo v register
	- analogne vrednosti bomo shranjevali v kondenzator
	- ADC pretvorba rabi čas, ki ni majhen (da se kondenzator napolni in naredimo pretvorbo); traja več urinih period
	- ko bo CPE sprožila pretvorbo, bo morala počakati, da se ta zaključi, preden prebere binarno vrednost
- temu rečemo ADC s suksesivno aproksimacijo
- n je tipično 12 => natančnost $\frac{1}{4096} \cdot V_{REF}$
	- če je $V_{REF} = 3.3V$ => natančnost 0.8mV

ADC v STM32H7:
- imamo tri ADC: ADC1, ADC2, ADC3 (mi bomo uporabili ADC3)
- vsi so 12-bitni
- vsak ima 20 vhodov za pretvorbo - so 20-kanalni (ne more hkrati prevajati toliko vrednosti, ker ima samo en 12-bitni izhod; zaženemo pretvorbo na enemu izmed kanalom; lahko mu rečemo, da pretvori vse kanale zaporedoma - ko enega končaš, me obvesti in nadaljuj)
- mi bomo uporabljali kanal 18, ker je na njemu vezan temperaturni senzor