- komunikacija vgrajenega sistema z analognim svetom - do zdaj smo vedno pošiljali digitalne signale prek GPIO in UART
- analogne naprave nekaj povedo z zveznim tokom ali napetostjo:
	- tipamo senzorje, ki nam svojo informacijo povejo kot zvezni tok ali napetost
	- merimo napetost na pinu, da dobimo temperaturo
- DAC - digitaln-to-analogni converter
- ADC - ravno obratno

DAC:
- ideja: imamo štiri bite, na razponu 0b0000 do 0b1111
- če je digitalni sistem napajan npr. s 3.3V, potem bo tudi analogna (zvezna) vrednost na razponu od 0 do 3.3V (če ne dodajamo napetosti od zunaj)
- kako pretvorimo `[0000, 1111] -> [0, 3.3V]`
- 3.3V bo $V_{REF}$ - DAC bo glede na binarno vrednost sklairal to referenčno napetost

ADC:
- zajamemo napetost in jo skušemo uganiti
- če znamo tvoriti napetost od 0 do 3.3V, potem mora biti tudi vhodna napetost do 3.3V
- npr. ugibam, da je npr. 1000 in to vrednost pretvorimo v analogno:
	- vhodno vrednost primerjamo s tvorjena - če smo tvorili preveč, je tist bit 0, če smo tvorili premalo, je tist bit 1
	- to ponavljamo od $b_n$ do $b_0$
- 1. zajamem analogno vrednost in jo začasno shranim
- 2. začnem ugibati:
	- predpostavim (ugibam) digitalno vrednost, to nato pretvorim v analogno (uporabi DAC) in primerjam z vhodno napetostjo
	- ponavljam
- zgled:
	- $V_{REF} = 3.3V$
	- $V_{SENS} = 2.5V$ (analogna vrednost, ki jo zajamem)
	- št. bitov = 4
	- 1. ugibam: 1000
		- $0b1000 \cdot V_{REF} / 16 = 1.65V$
		- primerjam: 1.65V < 2.5V => true
	- 2. ugibam: 1100
		- $0b1100 \cdot V_{REF}/16 = 2.475V$
		- primerjam: 2.475 < 2.5V => true
	- 3. ugibam: 1110
		- $0b1110 \cdot V_{REF}/16 = 2.8875 V$
		- primerjam 2.8875V < 2.5V => false
		- popravim ugibanje v 1100
	- 4. ugibam: 1101
		- $0b1101 \cdot V_{REF}/16 = 2.68V$
		- primerjam: 2.68V < 2.5V => false
		- popravim na 1100
	- zaključim: 1100
	- najbljižja digitalna vrednost od 2.5V je 0b1100 (12/16 od 3.3V)
- pretvorba ima toliko korakov, kolikor bitov imamo na voljo za predstavitev analogne vrednosti
- število bitov nam določa natančnost pretvorbe
- natančnost = $\frac{1}{2^n} \cdot V_{REF}$ = prispevek najnižjega bita
- n = št. bitov
- zajeto vrednost nekam shranim => kam?
	- digitalne vrednosti shranjujemo v register
	- analogne vrednosti bomo shranjevali v kondenzator
	- ADC pretvorba rabi čas, ki ni majhen (da se kondenzator napolni in naredimo pretvorbo); traja več urinih period
	- ko bo CPE sprožila pretvorbo, bo morala počakati, da se ta zaključi, preden prebere binarno vrednost
- temu rečemo ADC s suksesivno aproksimacijo
- n je tipično 12 => natančnost $\frac{1}{4096} \cdot V_{REF}$
	- če je $V_{REF} = 3.3V$ => natančnost 0.8mV

ADC v STM32H7:
- imamo tri ADC: ADC1, ADC2, ADC3 (mi bomo uporabili ADC3)
- vsi so 12-bitni
- vsak ima 20 vhodov za pretvorbo - so 20-kanalni (ne more hkrati prevajati toliko vrednosti, ker ima samo en 12-bitni izhod; zaženemo pretvorbo na enemu izmed kanalom; lahko mu rečemo, da pretvori vse kanale zaporedoma - ko enega končaš, me obvesti in nadaljuj - temu rečemo "scan" način)
- lahko naštimaš iz katerih kanalov naj pretvarja in v kakšnem vrstnem redu
- mi bomo uporabljali kanal 18, ker je na njemu vezan temperaturni senzor
- v čišu je temperaturni senzor na kanalu 18 od ADC3 - meri temperaturo znotraj silicija (temperaturo čipa)

- pri temperaturnem senzorju noben izdelan ne bo čisto enako meril - ga moramo skalibrirati - primerjamo kakšne vrednosti meri naš senzor pri določenih temperaturah in to preslikamo na pravo vrednost temperature, ki jo dobimo z nekim bolj natančnim senzorjem - dobimo kalibracijske vrednosti
- na našem čipu imamo dve kalibracijski vrednosti (2 byta) v čipu, s katerima moramo popraviti izmerjeno vrednost, da dobimo temperaturo

- proizvajalec umeri/kalibrira temepraturni senzor in nam poda dve kalibracijski vrednosti (TS_CAL1 in TS_CAL2)
- poda jih tako, da jih zapiše v dve pomnilniški besedi - 0x1FF1E820 in 0x1FF1E840
- izmerjeno temperaturo dobimo po enačbi:
	- ![500](../../Images4/Pasted%20image%2020260107103056.png)
	- TS_CAL2_TEMP = 110 ºC
	- TS_CAL2_TEMP = 30 ºC
- 1. inicializiraj ADC3 in kanal 18:
	- vedno je treba povedati, koliko časa naj ostane "stikalo" vklopljeno, da se bo kondenzator napolnil
	- ta čas je odvisen od izhodne upornosti senzorja, ki ga berem
- 2. preberemo TS_CAL1 in TS_CAL2
- 3. zaženemo pretvorbo
- 4. počakamo, da se pretvroba konča
- 5. preberemo TS_DATA iz ADC3
- 6. izračunamo temperaturo po zgornji enačbi

- lahko bi naredili, da zajamemo več vrednosti in jih potem povprečimo, ker vedno, ko zajamemo eno vrednost, bomo zajeli še nekaj šuma

- primer:
	- $f_{CLK ADC} = 80 \text{MHz}$
	- $T_{CLK ADC} = 12.5 \text{ns}$
	- sample time za temperaturni senzor = $9 \mu s$
		- to je 9000/12.5 = 720 urinih period => toliko časa mora biti odprto stikalo, da se kondenzator napolni
		- pri STM ne moremo napisati naj časka 720 period, ampak imamo 8 različnih vrednosti - mi bomo pri nas zato zbrali 810 period
	- 12 urinih period traja pretvorba, ker imamo 12 bitov => skupaj bomo čakali 732 urinih period