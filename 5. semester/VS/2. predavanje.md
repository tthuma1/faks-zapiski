ARM:
- 16 splošnonamenskih, 32-bitnih registrov
- R15 = PC; R14 = LR (za povratni naslov skokov); R13 = SP
- ortogonalni registri = format ukaza se ne spremeni v odvisnosti od registrov, ki jih uporabimo v ukazu (registri, ki jih uporabimo v ukazu, ne spremenijo formata ukaza)

Zastavice v PSR:
- postavijo se po izvedenih ukazih (npr. AL)
- s tem ugotoviš, da je npr. rezultat negativen, nič ...
- vsak ukaz vpliva na zastavice PSR (kaže zastavice zadnjega izvedenega ukaza)
- se lahko postavijo v EXEC ali WB stopnji cevovoda - problematično:
	- če se pogojni ukaz izvede glede na vrednost registra, bo vrednost registra enaka v vsaki stopnji cevovoda
	- če se pogojni ukaz izvede glede na zastavice, je problem, ker se lahko vmes spremenijo - zastavice so vezane na zadnji izveden ukaz

RTOS:
- ob prekinitvi začne izvajati drugo opravilo
- prekinitev = dogodek, ki ustavi trenutni tok ukazov
- drugi program lahko povozi registre od prvega programa:
	- ob prekinitvi se ne shranijo vsi registri
	- kdo naj shranjuje na sklad - SW ali HW (CPE):
		- lažje je če naredimo v SW, ampak bo počasneje
		- HW je hitreje, ker ne rabimo brati LOAD ukazov
	- katere registre shranimo na sklad - tiste, za katere je velika verjetnost, da jih bomo povozili:
		- R0, R1, R2, R3 - registri za argumente (če ima funkcija več kot 4 argumente, jih damo na sklad)
		- PC, LR, PSR
		- R12 - it's complicated
		- prekinitve morajo biti transparentne - prekinjeni program ne sme vedeti, da je bil prekinjen
	- ob prekinitvi :
		- CPE na sklad shrani zgornjih 8 registrov

- ARM full descdending sklad:
	- SP kaže na zadnje zasedeno mesto
	- sklad narašča s padanjem naslovov

- istočasno z nalaganjem registrov na sklad, CPE naredi še:
	- v PC da naslov ISR (PSP = prekinitveno servisni podprogram)
	- `PSR[7:0]` (spodnjih 8 bitov v PSR) => zapiše se exception number (id vira, ki je sprožil prekinitev):
		- prekinitve pridejo prek enega pina v CPE (non maskable in maskable interrupt):
			- ne rabi se odzivati na vse prekinitve - maskiranje
			- non maskable interrupt - CPE se bo vedno odzval
			- CPE reagira na stanje v pinu - ne prevzame novega ukaza, ampak sproži prekinitveno servisni cikel
			- če je več naprav na tem pinu, lahko ugotovi katera ga je prekinila tako, da:
				- vsako napravo vpraša, če jo je on prekinil ALI
				- imamo prekinitveni krmilnik - na našem boardu je 250 pinov in ko pride do prekinitve, gre prekinitveni krmilnik vprašati za exception number => vektorske prekinitve
Vektorske prekinitve:
- `PC <- M[4 * exception_number]`:
	- v PC se vpiše vsebina pomnilniške besede z naslovom 4x exception number
	- na tem naslovu je shranjen naslov PSP (naslov prvega ukaza)
	- ta pomnilniška beseda je torej "kazalec" oz. vektor na PSP
- vsaka prekinitev ima PSP na svojem naslovu
- premikamo se po 32 bitov, ker so registri toliko veliki
- 
