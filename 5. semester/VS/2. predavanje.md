ARM:
- 16 splošnonamenskih, 32-bitnih registrov
- R15 = PC; R14 = LR (za povratni naslov skokov); R13 = SP
- ortogonalni registri = format ukaza se ne spremeni v odvisnosti od registrov, ki jih uporabimo v ukazu (registri, ki jih uporabimo v ukazu, ne spremenijo formata ukaza)

Zastavice v PSR:
- postavijo se po izvedenih ukazih (npr. AL)
- s tem ugotoviš, da je npr. rezultat negativen, nič ...
- vsak ukaz vpliva na zastavice PSR (kaže zastavice zadnjega izvedenega ukaza)
- se lahko postavijo v EXEC ali WB stopnji cevovoda - problematično:
	- če se pogojni ukaz izvede glede na vrednost registra, bo vrednost registra enaka v vsaki stopnji cevovoda
	- če se pogojni ukaz izvede glede na zastavice, je problem, ker se lahko vmes spremenijo - zastavice so vezane na zadnji izveden ukaz

RTOS:
- ob prekinitvi začne izvajati drugo opravilo
- prekinitev = dogodek, ki ustavi trenutni tok ukazov
- drugi program lahko povozi registre od prvega programa:
	- ob prekinitvi se ne shranijo vsi registri
	- kdo naj shranjuje na sklad - SW ali HW (CPE):
		- lažje je če naredimo v SW, ampak bo počasneje
		- HW je hitreje, ker ne rabimo brati LOAD ukazov
	- katere registre shranimo na sklad - tiste, za katere je velika verjetnost, da jih bomo povozili:
		- R0, R1, R2, R3 - registri za argumente (če ima funkcija več kot 4 argumente, jih damo na sklad)
		- PC, LR, PSR
		- R12 - it's complicated
		- prekinitve morajo biti transparentne - prekinjeni program ne sme vedeti, da je bil prekinjen
	- ob prekinitvi :
		- CPE na sklad shrani zgornjih 8 registrov

- ARM full descdending sklad:
	- SP kaže na zadnje zasedeno mesto
	- sklad narašča s padanjem naslovov

- istočasno z nalaganjem registrov na sklad, CPE naredi še:
	- `PSR[7:0]` (spodnjih 8 bitov v PSR) => zapiše se exception number (id vira, ki je sprožil prekinitev):
		- prekinitve pridejo prek enega pina v CPE (non maskable in maskable interrupt):
			- ne rabi se odzivati na vse prekinitve - maskiranje
			- non maskable interrupt - CPE se bo vedno odzval
			- CPE reagira na stanje v pinu - ne prevzame novega ukaza, ampak sproži prekinitveno servisni cikel
			- če je več naprav na tem pinu, lahko ugotovi katera ga je prekinila tako, da:
				- vsako napravo vpraša, če jo je on prekinil ALI
				- imamo prekinitveni krmilnik - na našem boardu je 250 pinov in ko pride do prekinitve, gre prekinitveni krmilnik vprašati za exception number => vektorske prekinitve
Vektorske prekinitve:
- `PC <- M[4 * exception_number]`:
	- v PC se vpiše vsebina pomnilniške besede z naslovom 4x exception number
	- na tem naslovu je shranjen naslov ISR (naslov prvega ukaza)
	- ta pomnilniška beseda je torej "kazalec" oz. vektor na ISR
- vsaka prekinitev ima ISR na svojem naslovu
- premikamo se po 32 bitov, ker so registri toliko veliki
- ISR se lahko prekine, če pride prekinitev z višjo prioriteto
- v PC da naslov ISR (interrupt service routing) (PSP = prekinitveno servisni podprogram)

- rabimo shraniti, kje je bil program prekinjen, da se izvajanje lahko izvaja od tam naprej:
	- m
- da vem kdaj je ISR-ja konec:
	- rabimo interrupt return (IRET) ukaz - ARM nima tega ukaza
	- iz navadnih podprogramov se vračamo z RET, iz ISR se vračamo z IRET
	- višji programski jeziki (npr. C) ne morejo vedeti, ali se vračamo iz ISR ali iz navadne funkcije - prevajalnik ne ve, ali naj na konec vstavi RET ali IRET - dodamo neko oznako `__attribute__((interrupt))`, ampak potem vsak proizvajalec procesorjev gleda različno oznako
	- ker se vračanje iz ISR v višjih jezik zakomplicira, pri ARM ni IRET ukaza

- naslov `0x00000000` hrani prvo vrednost SP
- past je podobno kot prekinitev:
	- vse operacijske kode niso zapolnjene, zato obstajajo ukazi, ki jih procesor ne razume
	- v tem primeru pride do HardFault - CPE se ustavi in nam reče, da ne razume ukaza
- ![500](../../Images4/Pasted%20image%2020251015092323.png)

- ARM Cortex arhitektura nima ukaza za vračanje iz ISR (ni nekega IRET ukaza)
- ampak iz ISR se vračajo z istim ukazom kot pri navadnih podprogramih:
	- `bx lr  ;  pc <- lr`
	- ta ukaz bo obnovil PC, ampak ne povrne shranjenih vrednosti s sklada - rabimo hardware destacking
	- da bi zagotovili HW destacking operacijo, so se odločili, da to zakodirajo v LR:
		- če je v LR zgornjih 28 bitov enakih 1 (LR = 0xFFFFFFFx), potem CPE ne bo izvedla PC <- LR, ampak destacking; pravo vrednost, ki jo rabimo zapisati v PC, dobimo s sklada
	- `LR <- 0xFFFFFFFx`

- naloge desktop OS:
	- razvrščanje opravil
	- upravljanje s pomnilnikom, ščitenje pomnilnika enega procesa pred drugimi procesi - virtualizacija pomnilnika
	- večuporabništvo
- naloge vgrajenega OS:
	- razvršča opravila, ki so del istega procesa

- opravila morajo biti v pomnilniku ločena po kodi in podatkih:
	- vsako opravilo ima svoj ločen sklad
	- skladi so skupaj v pomnilniku, vsak sklad ima določeno velikost, torej se lahko sklad enega opravila prepriše v drugem opravilu
	- vsa opravila imajo en SP, torej te nič ne preprečuje, da bi pisal po drugem skladu
	- jedro OS se ne sme pokvariti, zato rabimo zagotoviti, da ima svoj nedotakljiv sklad
	- rešitev: navadna opravila imajo drugačen SP kot OS
		- dodamo še dva registra, ki nista del ortogonalnega niza registrov, ampak sta dostopna prek R13:
			- če CPE izvaja navadne programe, bo videl enega od teh dveh registrov (PSP - process stack pointer); če je v prekinitvi bo uporabil drugi register (MSP - main stack pointer)

- CPE mora vedeti koga je prekinil, ko se vrača iz ISR, da ve, katerega izmed skladovnih kazalcev mora dati tistemu, ki je bil prekinjen:
	- ko je v ISR, uporablja MSP in ima na interrupt zastavici 1
	- enkrat, ko vstopi v ISR ne ve več, kakšno je bilo prejšnje stanje - to si zapiše v spodnjih štirih bitih LR
	- `LR <- 0xFFFFFFFx` => v `x` se zapiše koga je prekinil oz. kateri SP se je uporalbjal (PSP ali MSP) 
	- če ob prekinitvi CPE izvaja navaden program: `LR <- 0XFFFFFFFD` (D=1101)
	- če ob prekinitvi CPE izvaja ISR: `LR <- 0XFFFFFFF1` (D=0001)
