Razvrščevalnik opravil - programiranje:
- pri vhodu v ISR se naredi HW stacking; pri izhodu se zgodi HW destacking
- ISR izbere novo opravilo in v SP zapiše vrednost shranjenega SP za novo opravilo
- ko zamenja SP, povzroči, da se bo HW destacking zgodil drugje kot HW stacking
- opravila se izvajajo v nepriviligiraneem načinu - uporabljajo PSP (process SP); ISR se izvaja v priviligiranem načinu (handler mode) - uporablja main SP (MSP):
	- tako zagotovimo, da taski nikoli ne posegajo po kazalcu jedra OS
	- če ima task stack overflow zaradi rekurzije, bo sklad od jedra ostal nedotaknjen

Kaj je opravilo:
- je funkcija, ki se nikoli ne sme zaključiti (lahko bi se, ampak na nek predpisan način; tako da obvesti razvrščevalnik opravil, da ga nikoli več ne bo izbral)
- opravilo ne bo nikoli klicano s `call` ASM ukazom:
	- mora obstajati njegova koda in sklad v pomnilniku
	- opravilo se začne izvajati po HW destackingu
	- nima argumentov, ničesar ne vrača
	- edino opravilo, ki ga pokličemo s `call`, bo čisto prvo (ampak tudi to ne bi bilo treba)
- `void Task() { while(1) { /* koda */ } }`

Kaj mora razvrščevalnik vedeti o opravilu:
- kje je njegova koda
- kje je vrh njegovega sklada - imamo pointer, ki kaže na zadnje viden vrh stacka ob prekinitvi funkcije
- to naredimo s strukturo, ki hrani dva kazalca - task control block (TCB)

- H750 = H753XIH6
- utility funkcije v "stm32h7xx_hal.c"
- `void*` = netipiziran kazalec, kaže na eno pomnilniško besedo; ga uporabljamo za kazalec na funkcijo (naslov prvega ukaza funkcije)
- kazalec na funkcijo, ki ničesar ne vrača in nima argumentov = `void (pTaskFunction)(void)`

Kaj je s skladom za posamezno opravilo:
- vsako opravilo mora imeti svoj sklad - znotraj while(1) lahko damo klic funkcije in se bo dodal klicni zapis na sklad, zato mora imeti vsako opravilo svoj sklad
- na sklad se bo zapisal HW stack frame ob HW stacking
- kako velik naj bo prostor na skladu - kako vemo, koliko bo sklad naraščal:
	- v našem preprostem primeru bomo dali vsakemu opravilu 1 kB za sklad (256 \* 4B, ker morajo biti vrednosti poravnane na 4B)
	- 1024 = 0x400

- v RAM bomo statično rezervirali 4x1kB
- full descending stack:
	- SP kaže na zadnjo vstavljeno besedo na sklad in sklad narašča v smeri padajočih naslovov
	- na začetku SP kaže en naslov pred začetkom sklada za Task i (v tisto pomnilniško besedo v bistvu ne smemo imeti ničesar)

Kaj je HSF (HW stack frame):
- zapis na skladu, ki ga avtomatično naredi CPE ob HW stacking
- gor shrani PSR, PC, LR ... (registre, ki jih bo podprogram zagotovo spremenil)
- v opravila se bo prvič vstopilo tako, da se naredi HW destacking, torej rabi biti HSF že vnaprej pripravljen:
	- HSF za vsako opravilo rabimo napolniti tako, kot da je bil prej že narejen HW stacking
	- na začetek sklada od vsakega opravila damo HSF s pravilnimi vrednostmi, kot da se je prej zgodil HW stacking:
		- PC = naslov, kjer se začne opravilo (naslov prvega ukaza)
		- PSR = vrednost, ki jo ARM nastavi ob reset
		- ostali registri nas ne zanimajo
	- v C si naredimo strukturo, ki posnama HSF

- za vsako opravilo napolnimo njegov TCB:
	- povemo, kje se začne sklad opravila in kje se začne funkcija opravila
	- `createTask()`
- za vsako opravilo (razen Task0) ustvarimo HSF s pravilnimi začetnimi vrednostmi in ga damo na začetek sklada opravila
	- `initTasks()`
	- tu rabimo popraviti SP v TCB, da kaže na zadnji zasedeni naslov na skladu

Process stack pointer (PSP):
- ne moremo pisati direktno s C v ta register, ker ne obstaja zares; ampak ga moramo nadzirati iz ASM
- imamo že implementirano v HAL

- ARM lahko uporablja dva formata ukazov - 16-bitni in 32-bitni:
	- mešati takih ukazov v kodi ni dovoljeno, ampak je treba spremeniti način delovanja v kontrolnem registru
	- CPE rabi vedeti ali bere 16-bitne ali 32-bitne ukaze => če je naslov ukaza lih (zadnji bit 1), potem bere 16-bitne ukaze

- koda je v flash, stack pa v RAM