Razvrščevalnik opravil - programiranje:
- pri vhodu v ISR se naredi HW stacking; pri izhodu se zgodi HW destacking
- ISR izbere novo opravilo in v SP zapiše vrednost shranjenega SP za novo opravilo
- ko zamenja SP, povzroči, da se bo HW destacking zgodil drugje kot HW stacking
- opravila se izvajajo v nepriviligiraneem načinu - uporabljajo PSP (process SP); ISR se izvaja v priviligiranem načinu (handler mode) - uporablja main SP (MSP):
	- tako zagotovimo, da taski nikoli ne posegajo po kazalcu jedra OS
	- če ima task stack overflow zaradi rekurzije, bo sklad od jedra ostal nedotaknjen

Kaj je opravilo:
- je funkcija, ki se nikoli ne sme zaključiti (lahko bi se, ampak na nek predpisan način; tako da obvesti razvrščevalnik opravil, da ga nikoli več ne bo izbral)
- opravilo ne bo nikoli klicano s `call` ASM ukazom:
	- mora obstajati njegova koda in sklad v pomnilniku
	- opravilo se začne izvajati po HW destackingu
	- nima argumentov, ničesar ne vrača
	- edino opravilo, ki ga pokličemo s `call`, bo čisto prvo (ampak tudi to ne bi bilo treba)
- `void Task() { while(1) { /* koda */ } }`

Kaj mora razvrščevalnik vedeti o opravilu:
- kje je njegova koda
- kje je vrh njegovega sklada - imamo pointer, ki kaže na zadnje viden vrh stacka ob prekinitvi funkcije
- to naredimo s strukturo, ki hrani dva kazalca - task control block (TCB)

- H750 = H753XIH6
- utility funkcije v "stm32h7xx_hal.c"
- `void*` = netipiziran kazalec, kaže na eno pomnilniško besedo; ga uporabljamo za kazalec na funkcijo (naslov prvega ukaza funkcije)
- kazalec na funkcijo, ki ničesar ne vrača in nima argumentov = `void (pTaskFunction)(void)`

Kaj je s skladom za posamezno opravilo:
- vsako opravilo mora imeti svoj sklad - znotraj while(1) lahko damo klic funkcije in se bo dodal klicni zapis na sklad, zato mora imeti vsako opravilo svoj sklad
- na sklad se bo zapisal HW stack frame ob HW stacking
- kako velik naj bo prostor na skladu - kako vemo, koliko bo sklad naraščal:
	- v našem preprostem primeru bomo dali vsakemu opravilu 1 kB za sklad (256 \* 4B, ker morajo biti vrednosti poravnane na 4B)
	- 1024 = 0x400