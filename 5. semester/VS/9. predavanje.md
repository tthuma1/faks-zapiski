### CAN

- serijski komunikacijski vmesnik - biti se prenašajo eden za drugim
- v vgrajenih sistemih najpopularnejši UART, I2C, SPI, CAN
- UART:
	- star, počasen, omogoča point-to-point povezavo, prenašajo se samo podatki + start/stop/pariteta bit
	- asinhronski - ne prenaša se urin signal, zaradi česar se morata sprejemnik in oddajnik vnaprej dogovoriti za dolžino bita (hitrost prenosa) ipd.
	- prenašajo se samo podatki, brez ure
- I2C:
	- preprost, omogoča komunikacijo med enim gospodarjem in množico sužnjev (master, slave)
	- gospodar naslovi sužnja in suženj ve, kako se odzvati
	- nizke prenosne hitrosti, robusten na fizični plasti
	- za povezavo s počasnimi preprostimi napravami - senzorji temperature, vlage
- SPI:
	- full duplex
	- prenos med več napravami po istem vodilu
	- sinhronski - prenaša tudi urin signal (imamo data in clock žico) => oba napravi vesta, kdaj se nekaj dogaja na vodilu
- npr. oddajnik bite pošilja ob pozitivni fronti, sprejemnik pa jih bere ob negativni fronti (na polovici periode) => urin signal ima dvakrat večjo frekvenco od data
- hitrost prenosa je vedno omejena s fizičnimi lastnostmi medija, po katerim prenašamo; signali se zaradi EM sevanja popačijo, slabijo, odboj, presluh
- vsak medij ima max frekvenco (pasovno širino), do katere je možno zanesljivo prenašati podatke
- če imamo npr. 1Mbit/s max za nek medij, bodo podatki šli z max 0,5Mbit/s
- sinhronski protokoli so dobri, ker gre lahko po daljših žicah in sprejemnik vedno tipa podatke na pravem mestu

CAN:
- za okolja z veliko motnjami, rabimo robusten sistem
- Controller Area Network
- serijski, asinhronski
- vsaka naprava, ki se priklopi na vodilo, rabi transciever - naprava, ki omogoča sprejem in oddajanje podatkov
- vse naprave (poljubno mnogo) se priključijo na CANH (CAN High) in CANL (CAN Low) žici

Fizična plast:
- CAN definira fizično plast kot diferencialno vodilo - vsak bit je predstavljen s parom napetosti
- vrednost bita se določa tako, da se ti dve napetosti odštejeta
- 0: CANH=3.5V, CANL=1V (lahko je tudi malo drugače, diff=2.5V)
- 1: CANH=2.5V, CANL=2.5V (diff=0V)
- imamo dolge žice (nekaj 10m) - če pride do EM motenj, se naredi enako velik "spike" na obeh žica (ker sta te dve žici vedno fizično skupaj) in diff ostane enak
- motnja ima na obeh žicah enako amplitudo in polariteto 

CAN transciever:
- prilagodi naše interne digitalne nivoje (lahko uporabljamo npr. 3,3V ali 5V za enico) v napetostne nivoje za CAN vodilo
- generira "bite" na CANH in CANL
- P-MOS in N-MOS tranzistorji - nosilci naboja so pozitivno ali negativno nabiti delci; gate, drain, source priključki
- ko bo moj digitalni sistem na Tx pisal "0", bota tranzistorja prevajala (stikali vklopljeni)
- ko bo moj digitalni sisten na Tx pisal "1", bota tranzistorrja zaprta (stikali izklopljeni)
- tranzistor, ki deluje kot stikalo, izjemno hitro preklaplja (mikro ali pikosekunde)
- Tx = 0:
	- napetost se aktivno določa; ker napetost na CANL in CANH določata le stikali (upora sta nepomembna v tem stanju) => aktivno določamo stanje na vodilu (to je dominantno stanje)
	- ne glede na breme, bo vedno diff=5V, ker breme ne vpliva na žico, ki je povezana direktno na napajanje (na vir napetosti)
- Tx = 1:
	- niti CANH niti CANL ni neposredno povezan na vir napetosti
	- ni nobene razlike napetosti => ni toka => padec napetosti na uporih bo 0V => na CANH in CANL bo 2.5V
	- ko povežemo neko aktivno breme na vodilo, lahko dobimo spremembo napetosti in steče tok => upora v transcieverju morata biti velika, da se padec napetosti na bremenu praktično ne pozna
	- to je recesivno stanje
	- preklop v to stanje je počasen, ker čakamo elektrone, da pridejo do konca dolge žice (npr. 100 metrov) - žica ima svojo kapacitivnost (imamo RC vezje)
- preklop v dominatno stanje je hiter, preklop v recesivno stanje je počasen

- povezovalna plast (data link layer) določa prenosne okvirje:
	- ![650](../../Images3/Pasted%20image%2020250506183855.png)
	- vodilo miruje v recesivne stanju
	- start bit = prvi prehod iz recesivnega v dominantno stanje
	- 12 arbitražnih bitov, 11 brez stuff bita => 2^11 naslovov
	- RTR => 0 = podatkovni okvir; 1 = request okvir
	- kontrolno polje 6 bitov - spreminjajo se samo spodnji štirje, ki povedo, koliko bytov sporočila vsebuje podatkovni paket
	- 7 enic označuje konec okvirja
	- na koncu so vedno tri enice med dvema okvirjema
- pakete mi tvorimo v kodi => ne neposredno:
	- mi bomo pripravili samo dele posameznega paketa
	- `ID[10..0]` => naslov ciljne naprave
	- `RTR=0` => podatkovni paket
	- `DLC[3..0]` => koliko bajtov nosi paket
	- `data`
	- iz tega bo CAN vmesnik tvoril frame
- programska koda pripravi dele paketa, jih pošlje v CAN Interface, ki zloži paket, in ga pošlje CAN Transcieverju:
	- CAN Interface in CAN Transciever je HW
	- CAN Interface je del našega embedded sistema, ki ga bomo morali skonfigurirati
	- CAN Transcieverja se ne bomo dotikali

- kako zagotoviti, da ne pride do trkov (da dve napravi ne oddajata istočasno):
	- delamo detekcijo kolizij
	- če dve napravi hkrati nastavita iz recesivnega v dominantno stanje, tega ne bomo morali zaznati, ampak s tem ni nič narobe
	- če en pošlje dominatno in en recesivno stanje, bo na vodilu prevladalo dominantno stanje in tisti, ki je postavil recesivno stanje, bo zaznal, da mu ni uspelo
	- po tem, ko pošljemo recesivno stanje, moramo čez nekaj časa preveriti, ali nam je uspelo => če nam ni, moramo počakati do konca frame-a (mora biti 10 recesivnih stanj zapored)
	- če pošljemo dominantno stanje, ne rabimo preveriti, ali nam je uspelo
	- manjši naslovi imajo zato višjo prioriteto (imajo na MSB ničle)
	- detekcijo kolizij dela CAN Transciever

- CAN ne pošilja ure
- problem => nimam ure, ki bi mi s fronto povedala, kdaj je na vodilu nov bit
- sprejemnik in oddajnik se morata prej dogovoriti za prenosne hitrosti (trajanje bita)
- signal želimo brati na sredini bita, ker je takrat najbolj stabilen
- ura oddajnika in prejemnika ni identična
- zares bomo bit brali malo pred/po sredini - lahko se nam zgodi, da bi dvakrat tipali en bit ali pa da bi en bit spustili
- rabimo bite, s katerimi bomo rekli "zdaj se je začel bit" - resinhronizacija
- resinhroniziramo vsakič, ko se zgodi prehod iz recesivnega v dominantno stanje
- problem nastane, ko dolgo časa ni prehoda (ko dolgo časa pošiljam isti bit)
- takrat moramo vriniti en bit, ki bo prinesel spremembo stanja => bit stuffing:
	- CAN: po 5 zaporednih enakih bitih se mora vriniti drugačen bit
	- s tem zagotovim prehod iz recesivnega v dominantno stanje
	- takrat vse naprave na vodilu začenjo znova šteti čas (resinhronizacija)
	- za to skrbi CAN Interface (vmesnik)
- če imam v svojem frame-u veliko front iz recesivnega v dominantno (iz 1 v 0), bo lepo sinhronizirano
- problem: dolgo zaporedje enakih bitov => treba ga je presekati z enim bitom, ki je drugačen (stuff bit)

Bit timing:
- določa, kdaj se začne bit
- koliko časa traja bit
- kje je "sredina" bita (mesto, kjer bom bral bit; zares želimo brati malo čez sredino bita)
- čas merimo z najmanjšo enoto časa, ki jo imamo => urin signal $T_{CLK} = \frac{1}{f_{CLK}} = t_q$
- $t_q$ = časovni kvant
- če ugotovimo, da štejemo prepočasi:
	- rabimo ponastaviti čas na 0 in zmanjšamo $t_{BIT}$ (npr. namesto, da štejemo do 40 $t_q$ za polovico bita, bomo šteli samo do 48)
- sprejemnik pričakuje nov bit znotraj 1 $t_q$ po pretečenem BS2:
	- 1. takrat res pride nov bit - vse okej
	- 2. nov bit pride znotraj BS1 => prehitro štejem => povečaj BS1
	- 3. nov bit pride znotraj BS2 => prepočasi štejem => povečaj BS2
- BS1/BS2 ne smemo premakniti za preveč naenkrat, da ne preskočimo kakšnega bita oz. da naj se naprava, ki nima dovolj natančne ure, umakne z vodila
- npr. BS1/BS2 smeš spremeniti samo za 10 $t_q$ naenkrat - SJW (Synchronisation Jump Width)