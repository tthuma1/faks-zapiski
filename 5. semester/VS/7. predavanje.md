- primerjalni izhodni način na časovnikih (output compare)
- TIMx_ARR določa periodo štetja tako, da se vedno primerja s TIMx_CNT - ko CNT prešteje do ARR, se CNT resetira
- ura določa kako hitro se vrti timer - se upočasni s PSC
- APB1_CLK - vodilo za uro, ki je namenjeno povezovanju perifernih naprav (ne komunikaciji z RAM) - te naprave ne delujejo z enako frekvenco kot CPE
- PSC je v bistvu spet števec, ki da na izhodu 1 na vsakih nekaj period
- časovna baza nam tvori dogodke na vsako periodo
- periodično krmilimo neke naprave:
	- npr. LED (s tem delamo PWM) in motorji (imajo krmilnike, ki sprejmejo digitalni signal in to pretvori v signale za krmiljenje motorja - z gostoto digitalnih pulzov mu povemo, kako hitro naj se obrača; hitrost vrtenja je odvisna od frekvence pulza)
- izhodni primerjalni kanali:
	- output compare register - OC
	- ob določeni vrednosti CNT se sproži prekinitev in/ali prižge PIN preko I/O logike
	- vsak OC register ima svoj kanal (channel)

- ko želimo nastaviti željeni način delovanja časovnika, moramo to početi s pisanjem ustreznih vrednosti v kontrolne registre
- TIMx_CCMR1 = capture compare mode register:
	- vsebuje kontrolne bite za vsakega izmed 4 output compare (OC) kanalov
	- OC1M = mode:
		- določajo, kaj se bo zgodilo s pinom, ko se vrednost v CNT izenači z vrednostjo v OC registru
		- 4 biti => 16 možnosti
		- 0011 = toggle
		- 0110 = PWM način
	- CC1S = selection:
		- 2 bita
		- določata, kako je konfiguriran kanal (4 možni načini)
		- 00 = izhodni način; kanal upravlja z GPIO pinom
	- OC1PE = preload enable:
		- določa, ali se za OC register uporablja senčni register (preload register)
		- v praksi je ponavadi zaželjeno ali zahtevano, da se uporablja
	- TIMx_CCER = capture compare enable register:
		- biti v njem omogočijo/onemogočijo posamezni kanal in polariteto kanala
		- CC1E - pri 0 kanal ne deluje, pri 1 je omogočen in deluje
		- CC1P = 0 => pin je aktiven v visokem stanju (in neaktiven v nizkem stanju)
		- CC1P = 1 => pin je akitven v nizkem stanju
		- polariteta = kakšna naj bo vrednost na izhodnem pinu, ko je OC enak CNT  (ali naj bo na izhodu 0 ali 1) - ko je OC enak CNT, temu rečemo aktivno stanje; če je aktivno stanje naše naprave 0, potem rabimo polariteto 1
	- ko CNT pride do OC, bomo sprožili toggle:
		- prvič se lahko toggle zgodi pred ARR periodami, potem se toggle vedno proži s periodo enako ARR
		- če želimo bolj pogosto prožiti toggle, rabimo zmanjšati ARR, ali pa ves čas premikamo OC naprej

```c
void Init_TIM3_OC1() {
	__HAL_RCC_TIM3_CLK_ENABLE();
	TIM3->PSC = 64-1; // 1 MHz
	TIM3->ARR = 65536 - 1; // max int, ker bomo evente prozili s premikanjem OC naprej
	
	// kontrolni register
	TIM3->CR1 = TIM3->CR1 | (1 << 7); // ARPE = 1
	TIM3->CR1 = TIM3->CR1 & ~(1 << 4); // DIR = 0 (upcounting)
		
	// na;in delovanja OC kanala (vhodni ali izhodni nacin)	
	TIM3->CCMR1 = TIM3->CCMR1 & 0xfffffffc; // CC1A = 00 (kanal OC1 bo krmilil PIN (output))
	TIM3->CCMR1 = TIM3->CCMR1 | (1 << 3); // OC1PE = 1 (enable)
	
	// nastavimo toggle nacin delovanja (OC1M = 0011)
	TIM3->CCMR1 = TIM3->CCMR1 & ~(1 << 16)
	TIM3->CCMR1 = TIM3->CCMR1 & ~(1 << 6)
	TIM3->CCMR1 = TIM3->CCMR1 | (0b11 << 4)
	
	// za polariteto nam je vseeno, ampak vseeno jo nastavimo
	TIM3->CCER = TIM3->CCER | 0x01; // omogoci OC1 kanal
	TIM3->CCER = TIM3->CCER & ~(1 << 1) // polariteta OC1 je pozitivna (CC1P = 0)
	
	TIM3->CCR = 50; // presteje do 50, pri uri 1 MHz bo to 50 mikrosekund
	
	TIM3->CR1 = TIM3->CR1 | 0x01; // zazeni timer
}

```


GPIO vmesnik:
- najbolj preprosta naprava, s katero lahko vplivam na vrednost pina
- i-ti bit v output data registru (ODR) vpliva na vrednost na pinu
- ODR je CPE viden kot ena pomnilniška beseda (je pomnilniško preslikan)
- IDR = input data register
- način GPIO vmesnika je lahko AF (alternate function):
	- v tem primeru vrednost pina lahko krmili ena izmed perifernih naprav
	- PB4 lahko nastavimo na AF in potem mu rečemo, da naj ga krmili TIM3

Kako premikati OC naprej vedno, ko se zgodi CNT == OC:
- moramo še omogočiti prekinitve časovnika - to se dogaja v registru DIER (DMA and interrupt register)
- DMIER b1 (CC1IE) moramo nastaviti na 1, da vklopimo prekinitve
- v `startup_stm32h753xx.s` imamo že napisane ISR, med njimi tudi TIM3_IRQHandler
- ISR mora ugotoviti, zakaj je prišlo do prekinitve in pobrisati prekinitvene zastavice:
	- `HAL_TIM_IRQHandler(htim: &htim3);` - ugotovi, ali je prekinitev prišla iz CC kanala

```c
int main() {
	// nastvi prekinitve na timerju
	Set_NVIC....
}
```