- CAN: serijski asinhronski protokol
- vrednost signala se ugotovi iz razlike med žicami (diferencialna linija)
- prehod v dominantno stanje je hipen, v recesivno pa počasen
- primerno za uporabo v industrijskih, šumnih okoljih; tam kjer so linije dolge - slabljenje signala ne vpliva veliko na detekcijo logičnega stanja, ker je na obeh žicah enak šum/slabljenje
- do 500 kbit/s ali 1 Mbit/s
- omogoča komunikacijo med več napravami - kdorkoli lahko oddaja
- ko postaviš recesivni bit, moraš čez nekaj časa tipati vodilo, da vidiš, če ti je uspelo, ali je prišlo do kolizije:
	- pri koliziji zmaga tista naprava, ki oddaja dominanten bit, druga naprava pa mora nehati in počakati do konca frame-a
	- naprave imajo prioriteto - pri koliziji bo zmagala tista, ki ima manjši ID

- ob start of frame se naprave resinhronizirajo
- na začetku določimo frekvenco ure, potem jo resinhroniziramo ob vsakem prehodu iz recesivnega v dominantno stanje
- bit stuffing - po petih enakih bitih, vrini nasproten bit:
	- to dela CAN Interface

Primer: nastavitve CAN vmesnika:
- $f_{CAN} = 40 \ \text{MHz}$ => $t_q = 25 \ \text{ns}$
- prenosna hitrost 500 kbit/s:
	- $T_{BIT} = \frac{1}{500 \ \text{kbit}} = 2 \mu s$
	- BS1 = 69 $t_q$
	- BS2 = 10 $t_q$
	- bit beremo v drugi polovici, da je zagotovo prava vrednost na liniji
- SJW = 10

- v avtomobilu se uporablja OBD-II za neke diagostične podatke

OBD-II:
- EU standard, da nekatere diagnostične podatke vsi proizvajalci zakodirajo na enak način
- vsi CAN okvirji so dolgi 8 B
- naslovi 0x7DF - okvir, ki je namenjen vsem ECU
- 0x7E0 do 0x7E7 - okvir, ki je namenjen ECU0 do ECU7
- odgovori iz posamezne ECU 0x7E8 do 0x7EF

- v kodi naredimo ISR, da obdela odgovor na našo zahtevo
- na CAN vodilu je ogromno okvirjev - da jih ne rabimo izločati programsko, kar bi bilo prepočasi, se to že v HW dela - HW dela filtriranje paketov po naslovu
- v MXCube - `FDCAN_FilterTypeDef`
	- nastavimo base ID in masko (podobno kot IP naslovi)