- v output compare mode časovnik dela tako, da se uporabi še capture compare register - vsako periodo se primerja vrednost števca s CCR - ko se vrednost izenači, lahko timer krmili nek zunanji pin:
	- ker imamo štiri capture compare kanale, bi lahko krmilili štiri pine s tem časovnikom
- pri nas se proži prekinitev, ko je timer izenačen s CCR, ki prižge nek pin
- vrednost s prescalerju nam določi resolucijo časa, ki jo lahko časovnik meri
- ko uporabimo output compare register, damo ARR na max, zato, da zagotovimo enakomerno štetje, ko CCR premikamo naprej
- npr. motorji se krmilijo z digitalnimi signali - za določeno hitrost imamo določeno dolžino enice in doloženo dolžino ničle - bolj hitro, kot se signal spreminja, hitreje se bo motor vrtel:
	- ko enkrat zaženemo časovnik, tvorjenje tega signala ne počne CPE
- s časovnikom lahko delamo PWM

Motor:
- rotor in stator, okoli statorja so navitja, ki naredijo magnetno polje, ko gre tok čez njih - to magnetno polje zavrti rotor
- rabimo preklapljati, katero navitje je vklopljeno, če hočemo, da se motor vrti v neskončnost - rabimo mu pošiljati pravokoten signal
- v motor driverju so tranzistorska stikala
- da pohitrimo vrtenje motorja, zmanjšamo vrednost v CCR

- spoznali smo OC (izhodni primerjalni = output compare) način, s katerim tvorimo pravokotni signal na pinu
- med drugim nam OC način omogoča periodičnih digitalnih signalov z izbrano frekvenco:
	- natančnost (resolucijo) določamo s prescalerjem (PSC register)
- včasih želimo imeti možnost, da poleg frekvence določamo dolžino ON/OFF trajanja 
- signala (nimamo pravilnega pravokotnega impulza, ampak imamo npr. ON daljši od OFF)
- želimo spreminjati (modulirati) širino pulza - pulzno širinska modulacija (PWM = pulse width modulation)

### PWM

- npr. luč je induktivno breme:
	- breme je lahko resistenčno (upor), kapacitivno (kondenzator) ali induktivno
	- induktivno breme se upira hitrim spremembam toka
	- kapacitivno breme se upira hitrim sprememba kapacitete (napetosti)

- časovnik zna generirati tudi PWM signal
- za to se uporabljajo capture compare kanali
- za tvorbo signala se CNT primerja s CCR **in** ARR registrom:
	- kadar se izenači s CCR gre ON in kadar se izenači z ARR gre OFF (oz. obratno)

- ARR določa periodo, CCR pa širino pulza

- rabimo nastaviti posamezne kanale
```c
// prej nastavimo časovno bazo (PSC, ARR, CR1), sedaj se lotimo nastavitve CC1 kanala
TIM3->CCMR1 = TIM3->CCMR1 & 0xfffffffc // nastavi OC Output za channel 1

// nastavimo PWM način delovanja (OC1M = 0110)
TIM3->CCMR1 = TIM3->CCMR1 & ~(1 << 16)
TIM3->CCMR1 = TIM3->CCMR1 | (0b11 << 5)
TIM3->CCMR1 = TIM3->CCMR1 & ~(1 << 4)

// za polariteto nam je vseeno, ampak vseeno jo nastavimo
TIM3->CCER = TIM3->CCER | 0x01; // omogoci OC1 kanal
TIM3->CCER = TIM3->CCER & ~(1 << 1) // polariteta OC1 je pozitivna (CC1P = 0), aktiven = visoko stanje 

// OC1PE mora biti na 1, če hočemo, da PWM dela (tako pravi dokumentacija)
TIM3->CCMR1 = TIM3->CCMR1 | (1 << 3) // OC1PE = 1 (output compare 1 preload enable)

TIM3->CCR = 50; // presteje do 50, pri uri 1 MHz bo to 50 mikrosekund

TIM3->CR1 = TIM3->CR1 | 0x01; // zazeni timer	
```

- imamo dva PWM načina:
	- mode 1 = kanal je aktiven, ko CNT < CCR, sicer je neaktivne
	- mode 2 = kanal je neaktiven, ko CNT < CCR, sicer je neaktiven
	- tu ne govorimo o nivoju signala, ampak samo ali je aktiven ali neaktiven - ali to pomeni 1 ali 0, določa polariteta

- ne rabimo prekinitev, ker nič ne bomo spreminjali CCR skozi izvajanje