### Časovniki (timer)
- velikokrat je delovanje sistema odvisno od časa:
	- periodično ponavljamo nekja
	- na določen čas začnemo zajem podatkov
	- generiranje signala na natančne trenutke, npr. krmiljenje motorja
- rabimo zelo natančen čas npr. na vsako mikrosekundo za npr. vzorčenje signala iz mikrofona
- imamo majhne časove, ki zahtevajo veliko natančnost (nekaj 10 ns)
- CPE ima svojo uro, ki je relativno natančna, ampak če bi programsko šteli, koliko urinih period je preteklo, bi bilo preveč nenatančno, ker se programsko merjenje časa lahko prekine (CPE zamudi periodo)
- zato imajo vsi računalniški sistemi časovnike
- vgrajeni sistemi imajo lahko več časovnikov - delujejo neodvisno od svoje okolice - dosežemo zanesljivo in natančno upravljanje s časom

- časovniki nam znajo povedati koliko časa je minilo od nekega trenutka
- merijo diskretni čas (štejejo št. urinih front, ki so se zgodile od nekega trenutka naprej)
- jedro časovnika je števec (counter):
	- digitalno vezje, ki se vsako urino preiodo spremeni za neko število
	- D-flip flopi
	- pri nas je števec 16-bitni, ampak ga sistem vidi kot 32-bitni register
	- timer counter številka x = TIMx_CNT
	- prostotekoči števec - če pride fronta, spremeni svojo vrednost
- imamo še en primerjalni register:
	- auto reload register (ARR)
	- kadarkoli se vrednost v števcu ujema z vrednostjo ARR, se lahko sproži dogodek (update event)
	- iz tega lahko periodično prožimo neke druge dogodke
	- update event = postavitev enega bita v statusnem registru in/ali proženje prekinitve
- timer prescaler (delilnik ure):
	- register s katerim se deli urinih signal
	- to je še en prosto tekoči števec s primarjalnim registrom, ki dobi noter urin signal in ko prišteje do npr. 6, bo postavil 1 na izhodu in spet šteje od začetka
	- s tem razširi uro periodnega signala
	- ta za vhod dobi advanced peripheral bus clock (APB_CLK)
- registri TIMx_CNT (timer counter), TIMx_ARR (auto reload register), TIMx_PSC (timer prescaler) so pomnilniško preslikani:
	- ti trije registri tvorijo "time base" (časovno bazo) časovnika
	- ARR določa pogostost proženja update eventa - nižja kot je vrednost, bolj pogosto se bodo prožili eventi
	- če upočasnim števec (povečam prescaler), se bo manj pogosto prožil event
	- če zmanjšamo prescaler, bo števec hitreje štel
	- na hitrost štetja vpliva le vrednost v prescalerju (PSC):
		- $f_\text{TIMx\_CLK} = \frac{f_\text{APB\_CLK}}{\text{TIMx\_PSC} + 1}$
		- APB povezuje CPU in V/I naprave
	- na pogostost dogodkov (update eventov) vplivata in ARR in PSC
		- $f_\text{UEV} = \frac{f_\text{TIMx\_CLK}}{\text{ARR} + 1}$

- ko se nam bo prožil dogodek, lahko beremo senzor ali kaj drugega naredimo:
	- lahko čakamo, da se vrednost bita v statusnem registru spremeni (slabo)
	- lahko čakamo, da nas časovnik prekine

- poleg prejšnjih treh registrov, ki tvorijo časovno bazo in so funkcionalni del vsakega časovnika, imamo pe 3 kontrolne in statusne registre, s katerimi določamo, kako časovnik deluje in nam časovnik v njih vrača svoje stanje:
	- 1. kontrolni register (TIMx_CR1):
		- 16-bitni register
		- b0 = CEN (Counter Enable): če je 0, CNT ne deluje, če je 1, CNT deluje
		- b4 = DIR (Direction; določa smer štetja CNT): 0 je UP, 1 je DOWN
		- b7 = ARPE (Auto-reload Preload Enable):
			- ko spremenimo ARR, se lahko odločiti, ali želimo spremembo upoštevati takoj, ali naj najprej prešteje do konca prejšnjega ARR in se potem novi upošteva
			- upoštevanje takoj je tvegano, ker če je CNT blizu novega ARR, ga lahko zgreši + pri digitalnih vezjih lahko pride do glitchov (špičk)
			- če želimo update po koncu štetja prejšnjega ARR, mora biti ARR register buffered/shadowed (senčen)
		- z vpisom neke vrednosti v ARR določimo periodo proženja UEV - dobimo dilemo - Ali želim, da mi ob CPE STORE ukazu nova vrednost vpiše takoj v ARR - Ali želim, da ob CPE STORE ukazu vrednost najprej odloži nekam in se v ARR vpiše šele po naslednjem UEV:
			- v drugem primeru potrebujem še en register, v katerega se bo začasno odložila nova vrednost in se bo iz njega prepisala v ARR šele ob UEV (CPE bo mislil, da piše v ARR, ampak zares se bo zapisalo v nek drug register)
			- rabimo še en ARR - shadow register
	- 2. DMA and Interrupt Enable Register (DIER):
		- b0 = UIE (Update Event Interrupt Enable):
			- 0 => ob UEV se ne proži prekinitev
			- 1 => ob UEV timer proži prekinitev - ta gre na prekinitveni krmilnik, ki prekini CPE, posreduje številko vhoda iz kjer je prišla prekinitev in iz katere CPE ugotovi, kje je ISR
			- uporaba časovnika brez prekinitve je neumno, ker če CPE ves čas preverja, ali se je UEV zgodil, izgubljamo veliko časa
	- 3. statusni register (SR)
		- b0 = UIF (Update Event Interrupt Flag):
			- pove nam dve stvari:
				- postavi se vsakič, ko se zgodi UEV
				- če omogočimo prekinitev v UIE, potem bo UIF označil, da imamo čakajočo prekinitveno zahtevo (interrupt pending)
			- prva naloga ISR, če imamo vklopljene prekinitve, je, da pobrišemo to zastavico

- za programiranje moramo vedeti, kje je časovnik v naslovnem prostoru in katero uro dobiva
- kje je časovnik v naslovnem prostoru:
	- imamo basic, advanced in general purpose timerje:
		- basic so to, kar smo delali danes - tvori se časovna baza; natančno se meri čas v računalniškem sistemu - to uporablja npr. RTOS, da se natančno ob periodi kličejo prekinitve
		- general purpose imajo dodatno funkcionalnost, da direktno upravljajo z V/I napravami (prek Output Control signala), da razbremenimo CPE (npr. če želimo na vsakih nekaj mikrosekund zavrteti motor, je bolje, če impulz pošilja direktno timer, namesto CPE):
			- TIM3 pri nas lahko dela z nekaterimi pini na boardu, zato ga bomo uporabili pri našem primeru - pri nas preslikan od 0x40000400 do 0x400003FF
			- offseti registrov:
				- ![500](../../Images4/Pasted%20image%2020251112102924.png)

- ko nastavljamo vhodni urin signal v časovnik, želimo čim počasnejši signal, da porabimo manj energije:
	- pri nas bo 64 MHz ($f_\text{APB1\_CLK})$)
- TIM3_CNT se lahko spreminja izven kode (koda nič ne spreminja te pomnilniške besede, prevajalnik ne ve za spremembe) - zato jo moramo označiti kot `volatile`:
	- vedno, ko želimo brati vrednost števca, ga bo šel CPE iskati v pomnilnik, namesto, da bi ga bral iz registra
	- lahko napišemo tudi `const volatile` - ne moremo programsko spreminjati vrednosti števca
- poleg nastavitve naštetih registrov moramo še omogočiti uro za cel časovnik:
	- v RCC vklopimo uro za TIM3 s `__HAL_RCC_TIM3_CLK_ENABLE()`
