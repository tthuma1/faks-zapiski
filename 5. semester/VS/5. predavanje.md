### Časovniki (timer)
- velikokrat je delovanje sistema odvisno od časa:
	- periodično ponavljamo nekja
	- na določen čas začnemo zajem podatkov
	- generiranje signala na natančne trenutke, npr. krmiljenje motorja
- rabimo zelo natančen čas npr. na vsako mikrosekundo za npr. vzorčenje signala iz mikrofona
- imamo majhne časove, ki zahtevajo veliko natančnost (nekaj 10 ns)
- CPE ima svojo uro, ki je relativno natančna, ampak če bi programsko šteli, koliko urinih period je preteklo, bi bilo preveč nenatančno, ker se programsko merjenje časa lahko prekine (CPE zamudi periodo)
- zato imajo vsi računalniški sistemi časovnike
- vgrajeni sistemi imajo lahko več časovnikov - delujejo neodvisno od svoje okolice - dosežemo zanesljivo in natančno upravljanje s časom

- časovniki nam znajo povedati koliko časa je minilo od nekega trenutka
- merijo diskretni čas (štejejo št. urinih front, ki so se zgodile od nekega trenutka naprej)
- jedro časovnika je števec (counter):
	- digitalno vezje, ki se vsako urino preiodo spremeni za neko število
	- D-flip flopi
	- pri nas je števec 16-bitni, ampak ga sistem vidi kot 32-bitni register
	- timer counter številka x = TIMx_CNT
	- prostotekoči števec - če pride fronta, spremeni svojo vrednost
- imamo še en primerjalni register:
	- auto reload register (ARR)
	- kadarkoli se vrednost v števcu ujema z vrednostjo ARR, se lahko sproži dogodek (update event)
	- iz tega lahko periodično prožimo neke druge dogodke
	- update event = postavitev enega bita v statusnem registru in/ali proženje prekinitve
- timer prescaler (delilnik ure):
	- register s katerim se deli urinih signal
	- to je še en prosto tekoči števec s primarjalnim registrom, ki dobi noter urin signal in ko prišteje do npr. 6, bo postavil 1 na izhodu in spet šteje od začetka
	- s tem razširi uro periodnega signala
	- ta za vhod dobi advanced peripheral bus clock (APB_CLK)
- registri TIMx_CNT (timer counter), TIMx_ARR (auto reload register), TIMx_PSC (timer prescaler) so pomnilniško preslikani:
	- ti trije registri tvorijo "time base" (časovno bazo) časovnika
	- ARR določa pogostost proženja update eventa - nižja kot je vrednost, bolj pogosto se bodo prožili eventi
	- če upočasnim števec (povečam prescaler), se bo manj pogosto prožil event
	- če zmanjšamo prescaler, bo števec hitreje štel
	- na hitrost štetja vpliva le vrednost v prescalerju (PSC):
		- $f_{TIMx\_CLK} = \frac{f_{APB\_CLK}}{TIMx\_PSC + 1}$
		- APB povezuje CPU in V/I naprave
	- na pogostost dogodkov (update eventov) vplivata in ARR in PSC
		- $f_{UEV} = \frac{f_{TIMx\_CLK}}{ARR + 1}$

- ko se nam bo prožil dogodek, lahko beremo senzor ali kaj drugega naredimo:
	- lahko čakamo, da se vrednost bita v statusnem registru spremeni (slabo)
	- lahko čakamo, da nas časovnik prekine