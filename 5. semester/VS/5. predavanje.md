### Časovniki (timer)
- velikokrat je delovanje sistema odvisno od časa:
	- periodično ponavljamo nekja
	- na določen čas začnemo zajem podatkov
	- generiranje signala na natančne trenutke, npr. krmiljenje motorja
- rabimo zelo natančen čas npr. na vsako mikrosekundo za npr. vzorčenje signala iz mikrofona
- imamo majhne časove, ki zahtevajo veliko natančnost (nekaj 10 ns)
- CPE ima svojo uro, ki je relativno natančna, ampak če bi programsko šteli, koliko urinih period je preteklo, bi bilo preveč nenatančno, ker se programsko merjenje časa lahko prekine (CPE zamudi periodo)
- zato imajo vsi računalniški sistemi časovnike
- vgrajeni sistemi imajo lahko več časovnikov - delujejo neodvisno od svoje okolice - dosežemo zanesljivo in natančno upravljanje s časom

- časovniki nam znajo povedati koliko časa je minilo od nekega trenutka
- merijo diskretni čas (štejejo št. urinih front, ki so se zgodile od nekega trenutka naprej)
- jedro časovnika je števec (counter):
	- digitalno vezje, ki se vsako urino preiodo spremeni za neko število
	- D-flip flopi
	- pri nas je števec 16-bitni, ampak ga sistem vidi kot 32-bitni register
	- timer counter številka x = TIMx_CNT
	- prostotekoči števec - če pride fronta, spremeni svojo vrednost
- imamo še en primerjalni register:
	- auto reload register (ARR)
	- kadarkoli se vrednost v števcu ujema z vrednostjo ARR, se lahko sproži dogodek (update event)
	- iz tega lahko periodično prožimo neke druge dogodke
	- update event = postavitev enega bita v statusnem registru in/ali proženje prekinitve
- timer prescaler (delilnik ure):
	- register s katerim se deli urinih signal
	- to je še en prosto tekoči števec s primarjalnim registrom, ki dobi noter urin signal in ko prišteje do npr. 6, bo postavil 1 na izhodu in spet šteje od začetka
	- s tem razširi uro periodnega signala
	- ta za vhod dobi advanced peripheral bus clock (APB_CLK)
- registri TIMx_CNT (timer counter), TIMx_ARR (auto reload register), TIMx_PSC (timer prescaler) so pomnilniško preslikani:
	- ti trije registri tvorijo "time base" (časovno bazo) časovnika
	- ARR določa pogostost proženja update eventa - nižja kot je vrednost, bolj pogosto se bodo prožili eventi
	- če upočasnim števec (povečam prescaler), se bo manj pogosto prožil event
	- če zmanjšamo prescaler, bo števec hitreje štel
	- na hitrost štetja vpliva le vrednost v prescalerju (PSC):
		- $f_{TIMx\_CLK} = \frac{f_{APB\_CLK}}{TIMx\_PSC + 1}$
		- APB povezuje CPU in V/I naprave
	- na pogostost dogodkov (update eventov) vplivata in ARR in PSC
		- $f_{UEV} = \frac{f_{TIMx\_CLK}}{ARR + 1}$

- ko se nam bo prožil dogodek, lahko beremo senzor ali kaj drugega naredimo:
	- lahko čakamo, da se vrednost bita v statusnem registru spremeni (slabo)
	- lahko čakamo, da nas časovnik prekine

- poleg prejšnjih treh registrov, ki tvorijo časovno bazo in so funkcionalni del vsakega časovnika, imamo pe 3 kontrolne in statusne registre, s katerimi določamo, kako časovnik deluje in nam časovnik v njih vrača svoje stanje:
	- 1. kontrolni register (TIMx_CR1):
		- 16-bitni register
		- b0 = CEN (Counter Enable): če je 0, CNT ne deluje, če je 1, CNT deluje
		- b4 = DIR (Direction; določa smer štetja CNT): 0 je UP, 1 je DOWN
		- b7 = ARPE (Auto-reload Preload Enable):
			- ko spremenimo ARR, se lahko odločiti, ali želimo spremembo upoštevati takoj, ali naj najprej prešteje do konca prejšnjega ARR in se potem novi upošteva
			- upoštevanje takoj je tvegano, ker če je CNT blizu novega ARR, ga lahko zgreši + pri digitalnih vezjih lahko pride do glitchov (špičk)
			- če želimo update po koncu štetja prejšnjega ARR, mora biti ARR register buffered/shadowed (senčen)
		- z vpisom neke vrednosti v ARR določimo periodo proženja UEV - dobimo dilemo - Ali želim, da mi ob CPE STORE ukazu nova vrednost vpiše takoj v ARR - Ali želim, da ob CPE STORE ukazu vrednost najprej odloži nekam in se v ARR vpiše šele po naslednjem UEV:
			- v drugem primeru potrebujem še en register, v katerega se bo začasno odložila nova vrednost in se bo iz njega prepisala v ARR šele ob UEV (CPE bo mislil, da piše v ARR, ampak zares se bo zapisalo v nek drug register)
			- rabimo še en ARR - shadow register
	- 2. DMA and Interrupt Enable Register (DIER):
		- b0 = UIE (Update Event Interrupt Enable):
			- 0 => ob UEV se ne proži prekinitev
			- 1 => ob UEV timer proži prekinitev - ta gre na prekinitveni krmilnik, ki prekini CPE, posreduje številko vhoda iz kjer je prišla prekinitev in iz katere CPE ugotovi, kje je ISR