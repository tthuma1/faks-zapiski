- na desktop računalniku programiramo, nato prevedeno izvršljivo datoteko naložimo na vgrajeni sistem in tam zaženemo
- če želimo spremeniti program, rabimo na novo uploadati
- vgrajeni sistem ima zelo omejen uporabniški vmesnik - tega vmesnika ne moremo uporabljati da bi spreminjali kodo, ampak jo moramo vedno spreminjati prek nekega desktopa
- rečemo, da imajo vgrajeni sistemi vgrajeno kodo

- če imamo gor OS, ta ni večuporabniški - drugačen OS kot na desktopih
- v desktopih ne moremo spreminjati sistemskih virov - alocirati poljubnega dela pomnilnika, komukacija s HW brez posredovanja OS
- v vgrajenih sistemih HW enote niso enkapsulirane v OS, ampak so nam direktno dane v uporabo - ves HW uporabljamo neposredno (brez OS posrednika):
	- lahko npr. spreminjamo prekinitveno tabelo
	- lahko DMA prenos neposredno uporabimo

- HW in SW codesign - skupaj designamo HW in  SW
- pri nas se lahko HW spreminja skozi nastavitve določenih bitov

- ARM ima arhitekture tipa A, M, R:
	- A za aplikacijske namene (gor damo OS)
	- M za embedded
	- R za realtime aplikacije
	- mi imamo v boardu M7

Kaj bomo počeli:
- prekinitve in večopravilnost - sami bomo implementirali svoj tiny RTOS
- lahko se izvaja več opravil:
	- spraševanje po stanju motorja, prikazovanje na zaslon, branje senzorja ...
	- ni samo ena main funkcija, ampak več opravil - to je možno, ker imaš prekinitve in shranjeni program
	- von Neumann - naj bo računalnik s shranjenim programom in računalnik naj se odziva samo na ukaze; ukazi se izvajajo zaporedno, razen če imamo skočni ukaz ali prekinitev
- HAL in komunikacijski vmesniki (UART, I2C, CAN)
- ADC/DAC
- DMA prenos
- timerji
- grafični knjižnica na vgrajenih sistemih (TouchGFX)

### Prekinitve in večopravilnost

- FreeRTOS
- prekinitev je dogodek, ki ustavi izvajanje določenega ukaznega zaporedja, ustavi instruction fetch in spremeni vrednost PC po nekem določenem pravilu
- ko začnemo z naslednjim fetchom, bomo dobili ukaz iz nekega drugega ukaznega zaporedja
- prekinitve morajo biti transparentne - program ne sme videti spremembe, če se mu zgodi prekinitev
- ob skoku na prekinitveno servisni program (ISR) si moramo shraniti PC in registre (stanje)

Programski model Cortex M7:
- program vidi samo registre
- 16 32-bitnih registrov R0, R1, ..., R15
- to so splošnonamenski registri (ortoganelen):
	- da je registrski niz ortogonalen pomeni, da v ukazu lahko uporabimo katerikoli register in se format ukaza zaradi tega ne bo spremenil
	- format ukaza = op. koda, dolžina ukaza, razporeditev bitov
	- včasih lahko nekatere ukaze zapišemo z manj biti, zato Intel nima ortogonalnega registrskega niza (preferira AX in BX registra za vhod v ALU, zato jiju sploh ne rabi kodirati v ukaz)
	- lažje je narediti procesor in cevovod za ortogonalen registrski niz
- R14 = link register (hrani povratni naslov skoka)
- R15 = PC
- R13 = stack pointer
- PSR = program status register z zastavicami N, Z, V, C:
	- pri RISC-V moramo sami ugotoviti te zastavice, pri ARM pa je že vgrajeno
	- to je slabo za cevovod, ker dve različni stopnji lahko probata spremeniti PSR
	- ukazi v stopnji EX, MEM, WB stopnji vplivajo na zastavice
	- branch pogoj se potem nanaša na nek drug ukaz, ne več na en pogoj, ker je hkrati več pogojev, ki je prižgalo različne zastavice

- ukaza push in pop imata dva destinacijskega registra - preberi vrednost iz sklada v register in posodobi SP - to ni čisto v skladu z RISC
- CR = control register
- stanje (kontekst) programa:
	- R0 do R15 + PSR => to je treba shraniti (na sklad) ob vsaki prekinitvi in pozneje obnoviti
	- registre na sklad shrani procesor z ukazi - to se shrani na začetku ISR, ampak tega ne naredi SW, ker bi bilo počasi shranjevanje 17 registrov, ampak znotraj HW, da preskočimo fetchanje in dekodiranje ukazov
	- ISR rabi shraniti PSR, PC, LR, R12 za velikost pusha vsaj 4 registre porabimo za argumente ko kličemo podprograme
	- ISR bo skoraj zagotovo rabil vsaj 8 registrov

Sklad:
- lahko raste z naslovi gor ali dol
- SP lahko kaže ne zadnje polno ali prvo prazno mesto
- ARM - full descending sklad, narašča v smeri padajočih naslovov in SP kaže na zadnji podatek
- 8 registrov se shrani hardversko, ostali se po potrebi s SW
- imamo latenco prekinitev = čas, ki je potreben, da se začne izvajati ISR

- če je odziv na dogodek treba izvesti takoj, lahko tudi nič ne shranimo na sklad