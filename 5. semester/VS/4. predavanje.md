- opravil ne kličemo, ampak jih bo zagnal razvrščevalnik tako, da se bo vračal iz ISR:
	- ISR pobere shranjeno stanje v katerega se želi vrniti - hardware stack frame (HSF)
	- zato rabimo za vsako od opravil na skladu prednastaviti pravilne vrednosti za PC in PSR
- `TaskCreate` - naredi TCB za vsako opravilo
- `TaskInit` - napolni HSF
- TCB-jev je toliko, kot opravil
- za ničto opravilo ne rabimo prednastaviti HSF, ker ga bomo zagnali z navadnim `call`
- opravila so implementirana v neskončni zanki, ker se ne smejo sama od sebe zaključiti
- skladi opravil so omejeni, nobeno opravilo nima neskončnega sklada:
	- nevarno za rekurzivne klice

- ko kličemo Task0, se bo procesor ujel v njem - rabimo prekiniti opravilo s prekinitvijo (interrupt)
- kdo bo prekinjal - sistemski časovnik:
	- ima nek števec, ki vsako urino periodo zmanjša svojo vrednost in ko pride do 0, se sproži prekinitev in se ponastavi nazaj na tisto vrednost, na kateri je začel
	- se nastvi že v `HAL_Init()`
- ob prekinitvi se shrani kontekst opravila na sklad
- iz ISR se vračamo tako, da preberemo vrednosti s sklada, ki pripadajo naslednjemu opravilu
- ISR pišemo v `stm32h7xx_it.c`:
	- npr. hard fault ISR se proži ob napaki v CPU (neveljaven ukaz, dostop do neporavnanih naslovov) in se ujame v neskončno zanko
	- `SysTick_Handler`

- da vemo, na katerem opravilu smo, bomo uporabili števec `int current_task`:
	- prevajalnik ne ve, kdaj se bo spremenljivka spremenila
	- če prevajalnik ne ve, kdaj se bo spremenljivka spremenila, jo bo dal v en register v CPU (za pogosto uporabljene spremenljivke lahko rezervira en register)
	- če bo to spremenljivko spreminjal nek ISR, prevajalnik tega ne bo vedel, zato ne bomo videli, da se je spremenila
	- spremenljivke, ki jih lahko spreminjajo neke V/I enote ali ISR rabimo označiti, naj je ne hrani v registru, ampak jo vedno spreminja v pomnilniku - `volatile int current_task`
	- `volatile` = vedno spreminjaj/beri vrednost spremenljivke iz pomnilnika

Funkcija ContextSwitch:
- 1. shrani PSP prekinjenega opravila v njegov TCB
- 2. določi indeks naslednjegaa opravila
- 3. zamenjava stack pointerja - preberi v PSP skladovni kazalec iz TCB novega opravila

- macro `__get_PSP()` - vrne vrednost PSP; PSP se prebere v nek register in se vrne rezultat iz tega registra

- RISC filozofija pravi, da nimaš skritih registrov, ampak ARM deli R13 na PSP in MSP
- control register nPriv = nivo priviligiranosti, ki nam pove, katere ukaze sme CPE izvajati:
	- katere ukaze in do katerih registrov sme dostopati program, kadar je CPE v nekem nivoju priviligiranosti
	- imamo vsaj dva nivoja - v bolj priviligiranem načinu lahko počnemo vse (npr. spreminjamo kontrolni register; ali dovolimo določene prekinitve)
	- uporabnikom damo nižji nivo priviligiranosti, da ne morejo delati stvari, ki se jih ne tičejo
- kadar CPE stopi v ISR, se preklopi v priviligiran način delovanja

- ISR se izvaja v priviligiranem načinu in uporablja MSP
- naša opravila naj uporabljajo PSP:
	- ko vstopimo v ISR, bo ta zagotovo rabil sklad, ampak nočemo, da bi pisal po skladu opravila
	- opravila naj uporabljajo tisti pomnilniški blok, ki smo ga rezervirali za njih na začetku

- ARM ima lahko 16-bitno ali 32-bitno kodo - če uporabimo 16-bitne ukaza, mora biti naslov ukaza tak, da je bit0 = 1, ampak zares ko se bo prebral ukaz na tem naslovu, bo  bit0 = 0, ker mora biti poravnan na naslove deljive z 2

- preklop na PSP preden kličemo Task0:
	- `__set_CONTROL(0x00000003)` - naj gre v nepriviligiran način in naj uporablja PSP
	- ko se zgodi prekinitev, se naredi HW stacking tam, kjer kaže SP - SP je trenutno PSP
	- nato CPE sam spremeni zadnja dva bita kontrolnega registra na 0 (priviligiran način in MSP)

- ob SysTick prekinitvi:
	- zaenkrat samo spremeni na MSP, ampak ostane nepriviligiran
	- CPE porine 9 vrednosti ob HW stackingu, ne 8

- virov prekinitev pri Cortex M7 je nekaj 100:
	- prekinitveni krmilnik pove, kdo je sprožil prekinitev prek vector numberja (številke prekinitve)
	- prekinitve imajo različno prioriteto - če pride prekinitev z višjo prioriteto, lahko prekinemo ISR med izvajanjem - dobimo gnezdene prekinitve
	- naš razvrščevalnik temelji na tem, da prekine opravilo:
		- ne želimo, da naš časovnik prekine ISR, ker bo napačno v TCB od opravila shranil SP od ISR, namesto SP od opravila
		- časovnik mora imeti najnižjo prioriteto od vseh prekinitev - tega nima pri nas
		- sistemski časovnik ne sme imeti najnižje prioritete, ker mora prekiniti neke stvari, da ne zamudi ticka
		- če ne vem, kaj sem prekinil, odložim zamenjavo opravil
		- odložena prekinitev (software interrupt, pending interrupt) - ima najnižjo prioriteto od vseh prekinitev v sistemu

- predposrtavka je, da ISR, ki bo izvedel zamenjavo opravila (klical ContextSwitch) prekine le opravila:
	- ne sme prekiniti drugih ISR, ker bomo SP od prekinjenega ISR shranili v TCB opravila, za katerega napačno mislimo, da smo ga prekinili
- rešitev:
	- 1. sistemski časovnik še vedno proži periodične prekinitve
	- 2. v ISR od časovnika ne bomo klicali funkcije ContextSwitch, ampak bomo sprožili SW prekinitev z najnižjo prioriteto - ta ne more prekiniti drugih prekinitev, ampak le opravila
	- ARM tej prekinitvi reče PendSV
	- proži se jo s programom tako, da se v poseben register z imenom ICSR postavi bit 28
	- znotraj ISR od PendSV bomo naredili ContextSwitch

- kaj če opravilo uporabi registre R4, R5 ..., ki se ne shranijo v HW stackingu:
	- ne bomo dobili nazaj pravilnega prejšnjega stanja pri HW destackingu
	- na sklad vsakega opravila moramo nad HSF shraniti še ostale registre (R4 do R11)

- možne nadgradnje razvrščevalnika: dodajanje, ubijanje opravil, prioritete opravil