- UDP nima seje
- ![400](../../Images4/Pasted%20image%2020251126183325.png)
	- --array = naredil bom 5 nalog - dobimo podnaloge znotraj posla, če pogledamo z `squeue --me`

Domača naloga:
- narediti moraš broadcast po UDP - proces 0 pošlje sporočilo vsem procesom, ki poslušajo
- lahko se zgodi da npr. proces 3 še ni pokonci, ko proces 0 želi poslati:
	- naj poskusi petkrat poslati - če petkrat ne dobi potrditve, potem obupa
	- vmes med poskusi daj delay 500ms
- ne rabiš heartBeat
- ničla pošilja enemu za drugim sporočilo in od vsakega želimo dobiti potrdilo, da je res dobil sporočilo
- setDeadline - koliko časa so vrata lahko odprta, da jih OS lahko potem zapre:
	- če samo zapremo program, bodo vrata še nekaj časa zasedena

Projektna naloga:
- delaš fake reddit - uporabniki objavljajo teme, ki lahko dobijo komentarje in všečke
- narediš strežnik in odjemalca - odjemalec se poveže na strežnik in izvaja operacije
- vmesn je s protobuf
- uporabniki in teme imajo zaporedne ID-je
- več odjemalcev se hkrati lahko poveže na strežnik
- lahko imamo več strežnikov:
	- ![300](../../Images4/Pasted%20image%2020251126185838.png)
	- glava in rep
	- pisalni zahtevki se vedno pošiljajo glavi (vse, kar spreminja vsebino razpravljalnice - like, post, comment)
	- bralne dostope poskušamo porazdeliti med ostale strežnike (procese)
	- tudi ostali strežniki morajo vsebovati celotno bazo razpravljalnice => glava mora posredovati vse spremembe, ki se dogajajo v njeni bazi - to se posreduje po verigi (verižna replikacija)
	- tisto, kar se bere, ne gre iz glave, ampak iz repa:
		- ![300](../../Images4/Pasted%20image%2020251126190044.png)
		- listTopics in getMessages
		- s tem bomo razbremenili glavo, ker se del zahtevkov preusmeri na rep
	- SubscribeTopic:
		- nek odjemalec se naroči na temo in prejme obvestila o vseh spremembah - za to bodo skrbela vmesna vozlišča in rep
		- ![300](../../Images4/Pasted%20image%2020251126190257.png)
		- kako se odločimo, preko katerega vozlišča se bo odjemalec naročil na topic - za to skrbi glava z getSubscriptionNode
		- glava naj ima nek razvrščevalnik, ki npr. da subscription tistemu vozlišču, ki je najmanj obremenjeno
	- subscribeToken:
		- ko se odjemalec naroči na temo, mu glava vrne par (nodeId, token)
		- token = naključno generiran niz
		- s tem tokenom odjemalec pokliče SubscribeToken
		- to vozlišče mora imeti vmesno vozlišče pri sebi (more mu ga glava sporočiti) - v svojo bazo tokenov pogleda, če je token veljaven (če obstaja) in potem dovoli odjemalcu, 
		- s tem ne dovolimo uporpabniku, da se sam od sebe poveže na poljubno vozlišče
		- odjemalec nazaj dobi stream MessageEvent struktur - stalna povezava med odjemalcem in vozliščem:
			- odjemalec posluša na tem streamu (tej povezavi)
			- tako odjemalcu pošljemo spremembo samo, ko se zgodi (odjemalec ne rabi pollat)
- gRPC vmesnike lahko spreminjaš, če rabiš
- med odjemalcem in strežnikom mora biti gRPC
- za komunikacijo med glavo in ostalimi vozlišči, lahko uporabljaš drugo tehnologijo (npr. RPC)