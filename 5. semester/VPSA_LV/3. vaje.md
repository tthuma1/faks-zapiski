- gorutine = niti, ki niso ekvivalentne nitim od OS, ampak so lažje in jih nadzira Go (Go izvaja razvrščevanje in orkestracijo)
- niti v OS je lahko manj kot imamo gorutin
- kanali s kapaciteto nič:
	- branja in pisanje iz kanala ustavi izvajanje gorutine, če na drugi strani ni nikogar, ki piše/bere
- če imamo kapaciteto kanala različno od nič in kanal ni poln, bomo vanj pisali brez, da bi se nit blokirala
- če v bufferju od kanala ni nobenega sporočila, bo branje blokirajoče

- `select` stavek:
	- če sta hkrati na voljo kanala v dve `case` stavkih, se izbere random, kateri `case` se bo izvedel

```go
func main() {
	input := make(chan bool)
	done := make(chan bool)
	w := 0
	// Zaženemo gorutino, ki čaka na pritisk tipke
	go readKey(input)
	// Zaženemo prvega delavca
	go worker(w, done)
	// Anonimna funkcija z neskončno zanko
	func() {
		for {
			select {
			// Pritisk tipke: končamo
			case <-input:
				return
			// Delavec zaključil, zaženimo novega
			case <-done:
				fmt.Println()
				w = w + 1
				go worker(w, done)
			// Če se nič ne zgodi izvedemo privzeto akcijo
			default:
				time.Sleep(200 * time.Millisecond)
				fmt.Print(".")
			}
		}
	}()
	// Počakamo na zadnjega delavca
	<-done
}
```
- ^ če bi zbrisali anonimno funkcijo, bi return prekinil `main` in zadnji `<-done` se ne bi nikoli izvedel; če bi nadomestili `return` z `break`, bi se breakal samo `select`, ne `for`
- mutex ključavnice:
	- samo ena gorutina jo lahko naenkrat zaklene, potem vse ostale gorutine čakajo, da se ključavnica odklene
	- ko gorutina čaka, da se ključavnica sprosti, gre v blokirano stanje, zato ne zaseda časa na CPU

Domača naloga:
- imaš tri senzorje (tlak, vlaga, temperatura), ki pošiljajo merive v kanal kapacitete 3
- imaš tri gorutine, eno za vsak senzor
- s stavkom select spremljamo vse tri kanale + kanal za pritisk Enter
- po petih sekundah neodzivnosti (če 5 sekund pademo v `default`, se zaključi vse; 5 sekund štej s time.After())