- `proizvajalec-porabnik-1.go`:
	- če zmanjšamo sleep interval, se lahko zgodi, da dobimo negativen rezultat
	- glavna nit nič ne čaka, da proizvajalci in porabniki končajo, zato medtem ko se izvaja `checkWork`, lahko proizvajalci še vedno delajo stvari in porabniki vzemajo
	- negativen rezultat je zato, ker se najprej prištevajo counterji proizvajalcev (te se vmes lahko še povečujejo), potem pa se odštejejo counterji porabnikov (te se vmes lahko še povečujejo) - na koncu bodo counterji porabnikov večji kot so bili counterji proizvajalcev, ker imamo for loop za porabnike za for loopom za proizvajalce in se counterji za porabnike lahko dalj časa povečujejo (če obrneš for looper, dobiš pozitiev rezultat)
	- če povečaš `intervalProducers` in `intervalConsumers`, se bo zgodilo, da se bo `checkWork` začel in končal medtem, ko bodo vsi proizvajalci in porabniki spali - zato dobiš pravilen rezultat (0) (med izvajanjem `checkWork` se counterji ne bodo povečevali, ker vsi čakajo v `Sleep`)
- `proizvajalec-porabnik-2.go`:
	- če se pošelje signal v quit, ko data še ni prazen, se bo porabnik random odločil, katerega bo bral in se lahko zgodi, da v kanalu ostanejo še nesprocerirana sporočila
- `proizvajalec-porabnik-3.go`:
	- dodamo waitgroup, s katero po quit počakamo, da vsi proizvajalci končajo
	- potem zapremo kanal data, s čimer povemo porabnikom, da ne bo več novih stvari v kanalu in se tudi lahko zaključijo

Domača naloga:
- zadnjič smo imeli za vsako naročilo svojo gorutino
- zdaj nimamo vnaprej pripravljenih naročil, ampak imamo gorutine, ki delajo naročila (proizvajalci) in gorutine, ki jih obdelujejo (consumer)
- 5 gorutin za producer in 5 gorutin za consumer
- 1 naročilo se generira na pol sekunde na producer
- ko pritisnemo na tipko, se trgovina zaustavi (ne sprejema več novih naročil); vsa naročila, ki so bila poslana v obdelavo pa se morajo še obdelati do konca
- na koncu izpišeš skupen promet in št. naročil